/**********************************************************************************************
*
*   raylib-umka v0.0.3 - Umka bindings for raylib.
*
*   https://github.com/RobLoach/raylib-umka
*
*   DEPENDENCIES:
*       - raylib 4.2 https://www.raylib.com/
*       - Umka https://github.com/vtereshkov/umka-lang
*
*   NOTE: Do not edit this file, as it is automatically generated.
*
*   LICENSE: zlib/libpng
*
*   raylib-umka is licensed under an unmodified zlib/libpng license, which is an OSI-certified,
*   BSD-like license that allows static linking with closed source software:
*
*   Copyright (c) 2022 Rob Loach (@RobLoach)
*
*   This software is provided "as-is", without any express or implied warranty. In no event
*   will the authors be held liable for any damages arising from the use of this software.
*
*   Permission is granted to anyone to use this software for any purpose, including commercial
*   applications, and to alter it and redistribute it freely, subject to the following restrictions:
*
*     1. The origin of this software must not be misrepresented; you must not claim that you
*     wrote the original software. If you use this software in a product, an acknowledgment
*     in the product documentation would be appreciated but is not required.
*
*     2. Altered source versions must be plainly marked as such, and must not be misrepresented
*     as being the original software.
*
*     3. This notice may not be removed or altered from any source distribution.
*
**********************************************************************************************/

#ifndef RAYLIB_UMKA_H_
#define RAYLIB_UMKA_H_

#if defined(__cplusplus)
extern "C" {
#endif

/**
 * Adds the raylib module to an Umka instance.
 *
 * @param umka The Umka instance you would like to add the raylib module to.
 *
 * @return True if it succeeds, false otherwise.
 */
bool umkaAddRaylib(void *umka);

#if defined(__cplusplus)
}
#endif

#endif  // RAYLIB_UMKA_H_

#ifdef RAYLIB_UMKA_IMPLEMENTATION
#ifndef RAYLIB_UMKA_IMPLEMENTATION_ONCE
#define RAYLIB_UMKA_IMPLEMENTATION_ONCE

// raylib.h
#ifndef RAYLIB_UMKA_RAYLIB_H
#define RAYLIB_UMKA_RAYLIB_H "raylib.h"
#endif
#include RAYLIB_UMKA_RAYLIB_H

// raymath.h
#ifndef RAYLIB_UMKA_RAYMATH_H
#define RAYLIB_UMKA_RAYMATH_H "raymath.h"
#endif
#include RAYLIB_UMKA_RAYMATH_H

// umka_api.h
#ifndef RAYLIB_UMKA_UMKA_API_H
#define RAYLIB_UMKA_UMKA_API_H "umka_api.h"
#endif
#include RAYLIB_UMKA_UMKA_API_H

// memcpy()
#ifndef RAYLIB_UMKA_MEMCPY
#include <string.h>
#define RAYLIB_UMKA_MEMCPY memcpy
#endif

#if defined(__cplusplus)
extern "C" {
#endif

/**
 * Umka bindings for InitWindow.
 *
 * @see InitWindow()
 */
void umkaInitWindow(UmkaStackSlot *params, UmkaStackSlot *result) {
    int width = params[2].intVal;
    int height = params[1].intVal;
    const char * title = (const char *)params[0].ptrVal;
    InitWindow(width, height, title);
}

/**
 * Umka bindings for WindowShouldClose.
 *
 * @see WindowShouldClose()
 */
void umkaWindowShouldClose(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->intVal = (int)WindowShouldClose();
}

/**
 * Umka bindings for CloseWindow.
 *
 * @see CloseWindow()
 */
void umkaCloseWindow(UmkaStackSlot *params, UmkaStackSlot *result) {
    CloseWindow();
}

/**
 * Umka bindings for IsWindowReady.
 *
 * @see IsWindowReady()
 */
void umkaIsWindowReady(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->intVal = (int)IsWindowReady();
}

/**
 * Umka bindings for IsWindowFullscreen.
 *
 * @see IsWindowFullscreen()
 */
void umkaIsWindowFullscreen(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->intVal = (int)IsWindowFullscreen();
}

/**
 * Umka bindings for IsWindowHidden.
 *
 * @see IsWindowHidden()
 */
void umkaIsWindowHidden(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->intVal = (int)IsWindowHidden();
}

/**
 * Umka bindings for IsWindowMinimized.
 *
 * @see IsWindowMinimized()
 */
void umkaIsWindowMinimized(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->intVal = (int)IsWindowMinimized();
}

/**
 * Umka bindings for IsWindowMaximized.
 *
 * @see IsWindowMaximized()
 */
void umkaIsWindowMaximized(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->intVal = (int)IsWindowMaximized();
}

/**
 * Umka bindings for IsWindowFocused.
 *
 * @see IsWindowFocused()
 */
void umkaIsWindowFocused(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->intVal = (int)IsWindowFocused();
}

/**
 * Umka bindings for IsWindowResized.
 *
 * @see IsWindowResized()
 */
void umkaIsWindowResized(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->intVal = (int)IsWindowResized();
}

/**
 * Umka bindings for IsWindowState.
 *
 * @see IsWindowState()
 */
void umkaIsWindowState(UmkaStackSlot *params, UmkaStackSlot *result) {
    unsigned int flag = params[0].uintVal;
    result->intVal = (int)IsWindowState(flag);
}

/**
 * Umka bindings for SetWindowState.
 *
 * @see SetWindowState()
 */
void umkaSetWindowState(UmkaStackSlot *params, UmkaStackSlot *result) {
    unsigned int flags = params[0].uintVal;
    SetWindowState(flags);
}

/**
 * Umka bindings for ClearWindowState.
 *
 * @see ClearWindowState()
 */
void umkaClearWindowState(UmkaStackSlot *params, UmkaStackSlot *result) {
    unsigned int flags = params[0].uintVal;
    ClearWindowState(flags);
}

/**
 * Umka bindings for ToggleFullscreen.
 *
 * @see ToggleFullscreen()
 */
void umkaToggleFullscreen(UmkaStackSlot *params, UmkaStackSlot *result) {
    ToggleFullscreen();
}

/**
 * Umka bindings for MaximizeWindow.
 *
 * @see MaximizeWindow()
 */
void umkaMaximizeWindow(UmkaStackSlot *params, UmkaStackSlot *result) {
    MaximizeWindow();
}

/**
 * Umka bindings for MinimizeWindow.
 *
 * @see MinimizeWindow()
 */
void umkaMinimizeWindow(UmkaStackSlot *params, UmkaStackSlot *result) {
    MinimizeWindow();
}

/**
 * Umka bindings for RestoreWindow.
 *
 * @see RestoreWindow()
 */
void umkaRestoreWindow(UmkaStackSlot *params, UmkaStackSlot *result) {
    RestoreWindow();
}

/**
 * Umka bindings for SetWindowIcon.
 *
 * @see SetWindowIcon()
 */
void umkaSetWindowIcon(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image* image = (Image*)&params[0];
    SetWindowIcon(*image);
}

/**
 * Umka bindings for SetWindowTitle.
 *
 * @see SetWindowTitle()
 */
void umkaSetWindowTitle(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * title = (const char *)params[0].ptrVal;
    SetWindowTitle(title);
}

/**
 * Umka bindings for SetWindowPosition.
 *
 * @see SetWindowPosition()
 */
void umkaSetWindowPosition(UmkaStackSlot *params, UmkaStackSlot *result) {
    int x = params[1].intVal;
    int y = params[0].intVal;
    SetWindowPosition(x, y);
}

/**
 * Umka bindings for SetWindowMonitor.
 *
 * @see SetWindowMonitor()
 */
void umkaSetWindowMonitor(UmkaStackSlot *params, UmkaStackSlot *result) {
    int monitor = params[0].intVal;
    SetWindowMonitor(monitor);
}

/**
 * Umka bindings for SetWindowMinSize.
 *
 * @see SetWindowMinSize()
 */
void umkaSetWindowMinSize(UmkaStackSlot *params, UmkaStackSlot *result) {
    int width = params[1].intVal;
    int height = params[0].intVal;
    SetWindowMinSize(width, height);
}

/**
 * Umka bindings for SetWindowSize.
 *
 * @see SetWindowSize()
 */
void umkaSetWindowSize(UmkaStackSlot *params, UmkaStackSlot *result) {
    int width = params[1].intVal;
    int height = params[0].intVal;
    SetWindowSize(width, height);
}

/**
 * Umka bindings for SetWindowOpacity.
 *
 * @see SetWindowOpacity()
 */
void umkaSetWindowOpacity(UmkaStackSlot *params, UmkaStackSlot *result) {
    float opacity = params[0].real32Val;
    SetWindowOpacity(opacity);
}

/**
 * Umka bindings for GetWindowHandle.
 *
 * @see GetWindowHandle()
 */
void umkaGetWindowHandle(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->ptrVal = (void*)GetWindowHandle();
}

/**
 * Umka bindings for GetScreenWidth.
 *
 * @see GetScreenWidth()
 */
void umkaGetScreenWidth(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->intVal = GetScreenWidth();
}

/**
 * Umka bindings for GetScreenHeight.
 *
 * @see GetScreenHeight()
 */
void umkaGetScreenHeight(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->intVal = GetScreenHeight();
}

/**
 * Umka bindings for GetRenderWidth.
 *
 * @see GetRenderWidth()
 */
void umkaGetRenderWidth(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->intVal = GetRenderWidth();
}

/**
 * Umka bindings for GetRenderHeight.
 *
 * @see GetRenderHeight()
 */
void umkaGetRenderHeight(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->intVal = GetRenderHeight();
}

/**
 * Umka bindings for GetMonitorCount.
 *
 * @see GetMonitorCount()
 */
void umkaGetMonitorCount(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->intVal = GetMonitorCount();
}

/**
 * Umka bindings for GetCurrentMonitor.
 *
 * @see GetCurrentMonitor()
 */
void umkaGetCurrentMonitor(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->intVal = GetCurrentMonitor();
}

/**
 * Umka bindings for GetMonitorPosition.
 *
 * @see GetMonitorPosition()
 */
void umkaGetMonitorPosition(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    int monitor = params[1].intVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector2), NULL);
    Vector2 out = GetMonitorPosition(monitor);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector2));
}

/**
 * Umka bindings for GetMonitorWidth.
 *
 * @see GetMonitorWidth()
 */
void umkaGetMonitorWidth(UmkaStackSlot *params, UmkaStackSlot *result) {
    int monitor = params[0].intVal;
    result->intVal = GetMonitorWidth(monitor);
}

/**
 * Umka bindings for GetMonitorHeight.
 *
 * @see GetMonitorHeight()
 */
void umkaGetMonitorHeight(UmkaStackSlot *params, UmkaStackSlot *result) {
    int monitor = params[0].intVal;
    result->intVal = GetMonitorHeight(monitor);
}

/**
 * Umka bindings for GetMonitorPhysicalWidth.
 *
 * @see GetMonitorPhysicalWidth()
 */
void umkaGetMonitorPhysicalWidth(UmkaStackSlot *params, UmkaStackSlot *result) {
    int monitor = params[0].intVal;
    result->intVal = GetMonitorPhysicalWidth(monitor);
}

/**
 * Umka bindings for GetMonitorPhysicalHeight.
 *
 * @see GetMonitorPhysicalHeight()
 */
void umkaGetMonitorPhysicalHeight(UmkaStackSlot *params, UmkaStackSlot *result) {
    int monitor = params[0].intVal;
    result->intVal = GetMonitorPhysicalHeight(monitor);
}

/**
 * Umka bindings for GetMonitorRefreshRate.
 *
 * @see GetMonitorRefreshRate()
 */
void umkaGetMonitorRefreshRate(UmkaStackSlot *params, UmkaStackSlot *result) {
    int monitor = params[0].intVal;
    result->intVal = GetMonitorRefreshRate(monitor);
}

/**
 * Umka bindings for GetWindowPosition.
 *
 * @see GetWindowPosition()
 */
void umkaGetWindowPosition(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector2), NULL);
    Vector2 out = GetWindowPosition();
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector2));
}

/**
 * Umka bindings for GetWindowScaleDPI.
 *
 * @see GetWindowScaleDPI()
 */
void umkaGetWindowScaleDPI(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector2), NULL);
    Vector2 out = GetWindowScaleDPI();
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector2));
}

/**
 * Umka bindings for GetMonitorName.
 *
 * @see GetMonitorName()
 */
void umkaGetMonitorName(UmkaStackSlot *params, UmkaStackSlot *result) {
    int monitor = params[0].intVal;
    result->ptrVal = (void*)GetMonitorName(monitor);
}

/**
 * Umka bindings for SetClipboardText.
 *
 * @see SetClipboardText()
 */
void umkaSetClipboardText(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * text = (const char *)params[0].ptrVal;
    SetClipboardText(text);
}

/**
 * Umka bindings for GetClipboardText.
 *
 * @see GetClipboardText()
 */
void umkaGetClipboardText(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->ptrVal = (void*)GetClipboardText();
}

/**
 * Umka bindings for EnableEventWaiting.
 *
 * @see EnableEventWaiting()
 */
void umkaEnableEventWaiting(UmkaStackSlot *params, UmkaStackSlot *result) {
    EnableEventWaiting();
}

/**
 * Umka bindings for DisableEventWaiting.
 *
 * @see DisableEventWaiting()
 */
void umkaDisableEventWaiting(UmkaStackSlot *params, UmkaStackSlot *result) {
    DisableEventWaiting();
}

/**
 * Umka bindings for SwapScreenBuffer.
 *
 * @see SwapScreenBuffer()
 */
void umkaSwapScreenBuffer(UmkaStackSlot *params, UmkaStackSlot *result) {
    SwapScreenBuffer();
}

/**
 * Umka bindings for PollInputEvents.
 *
 * @see PollInputEvents()
 */
void umkaPollInputEvents(UmkaStackSlot *params, UmkaStackSlot *result) {
    PollInputEvents();
}

/**
 * Umka bindings for WaitTime.
 *
 * @see WaitTime()
 */
void umkaWaitTime(UmkaStackSlot *params, UmkaStackSlot *result) {
    double seconds = params[0].realVal;
    WaitTime(seconds);
}

/**
 * Umka bindings for ShowCursor.
 *
 * @see ShowCursor()
 */
void umkaShowCursor(UmkaStackSlot *params, UmkaStackSlot *result) {
    ShowCursor();
}

/**
 * Umka bindings for HideCursor.
 *
 * @see HideCursor()
 */
void umkaHideCursor(UmkaStackSlot *params, UmkaStackSlot *result) {
    HideCursor();
}

/**
 * Umka bindings for IsCursorHidden.
 *
 * @see IsCursorHidden()
 */
void umkaIsCursorHidden(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->intVal = (int)IsCursorHidden();
}

/**
 * Umka bindings for EnableCursor.
 *
 * @see EnableCursor()
 */
void umkaEnableCursor(UmkaStackSlot *params, UmkaStackSlot *result) {
    EnableCursor();
}

/**
 * Umka bindings for DisableCursor.
 *
 * @see DisableCursor()
 */
void umkaDisableCursor(UmkaStackSlot *params, UmkaStackSlot *result) {
    DisableCursor();
}

/**
 * Umka bindings for IsCursorOnScreen.
 *
 * @see IsCursorOnScreen()
 */
void umkaIsCursorOnScreen(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->intVal = (int)IsCursorOnScreen();
}

/**
 * Umka bindings for ClearBackground.
 *
 * @see ClearBackground()
 */
void umkaClearBackground(UmkaStackSlot *params, UmkaStackSlot *result) {
    Color* color = (Color*)&params[0];
    ClearBackground(*color);
}

/**
 * Umka bindings for BeginDrawing.
 *
 * @see BeginDrawing()
 */
void umkaBeginDrawing(UmkaStackSlot *params, UmkaStackSlot *result) {
    BeginDrawing();
}

/**
 * Umka bindings for EndDrawing.
 *
 * @see EndDrawing()
 */
void umkaEndDrawing(UmkaStackSlot *params, UmkaStackSlot *result) {
    EndDrawing();
}

/**
 * Umka bindings for BeginMode2D.
 *
 * @see BeginMode2D()
 */
void umkaBeginMode2D(UmkaStackSlot *params, UmkaStackSlot *result) {
    Camera2D* camera = (Camera2D*)&params[0];
    BeginMode2D(*camera);
}

/**
 * Umka bindings for EndMode2D.
 *
 * @see EndMode2D()
 */
void umkaEndMode2D(UmkaStackSlot *params, UmkaStackSlot *result) {
    EndMode2D();
}

/**
 * Umka bindings for BeginMode3D.
 *
 * @see BeginMode3D()
 */
void umkaBeginMode3D(UmkaStackSlot *params, UmkaStackSlot *result) {
    Camera3D* camera = (Camera3D*)&params[0];
    BeginMode3D(*camera);
}

/**
 * Umka bindings for EndMode3D.
 *
 * @see EndMode3D()
 */
void umkaEndMode3D(UmkaStackSlot *params, UmkaStackSlot *result) {
    EndMode3D();
}

/**
 * Umka bindings for BeginTextureMode.
 *
 * @see BeginTextureMode()
 */
void umkaBeginTextureMode(UmkaStackSlot *params, UmkaStackSlot *result) {
    RenderTexture2D* target = (RenderTexture2D*)&params[0];
    BeginTextureMode(*target);
}

/**
 * Umka bindings for EndTextureMode.
 *
 * @see EndTextureMode()
 */
void umkaEndTextureMode(UmkaStackSlot *params, UmkaStackSlot *result) {
    EndTextureMode();
}

/**
 * Umka bindings for BeginShaderMode.
 *
 * @see BeginShaderMode()
 */
void umkaBeginShaderMode(UmkaStackSlot *params, UmkaStackSlot *result) {
    Shader* shader = (Shader*)&params[0];
    BeginShaderMode(*shader);
}

/**
 * Umka bindings for EndShaderMode.
 *
 * @see EndShaderMode()
 */
void umkaEndShaderMode(UmkaStackSlot *params, UmkaStackSlot *result) {
    EndShaderMode();
}

/**
 * Umka bindings for BeginBlendMode.
 *
 * @see BeginBlendMode()
 */
void umkaBeginBlendMode(UmkaStackSlot *params, UmkaStackSlot *result) {
    int mode = params[0].intVal;
    BeginBlendMode(mode);
}

/**
 * Umka bindings for EndBlendMode.
 *
 * @see EndBlendMode()
 */
void umkaEndBlendMode(UmkaStackSlot *params, UmkaStackSlot *result) {
    EndBlendMode();
}

/**
 * Umka bindings for BeginScissorMode.
 *
 * @see BeginScissorMode()
 */
void umkaBeginScissorMode(UmkaStackSlot *params, UmkaStackSlot *result) {
    int x = params[3].intVal;
    int y = params[2].intVal;
    int width = params[1].intVal;
    int height = params[0].intVal;
    BeginScissorMode(x, y, width, height);
}

/**
 * Umka bindings for EndScissorMode.
 *
 * @see EndScissorMode()
 */
void umkaEndScissorMode(UmkaStackSlot *params, UmkaStackSlot *result) {
    EndScissorMode();
}

/**
 * Umka bindings for BeginVrStereoMode.
 *
 * @see BeginVrStereoMode()
 */
void umkaBeginVrStereoMode(UmkaStackSlot *params, UmkaStackSlot *result) {
    VrStereoConfig* config = (VrStereoConfig*)&params[0];
    BeginVrStereoMode(*config);
}

/**
 * Umka bindings for EndVrStereoMode.
 *
 * @see EndVrStereoMode()
 */
void umkaEndVrStereoMode(UmkaStackSlot *params, UmkaStackSlot *result) {
    EndVrStereoMode();
}

/**
 * Umka bindings for LoadVrStereoConfig.
 *
 * @see LoadVrStereoConfig()
 */
void umkaLoadVrStereoConfig(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    VrDeviceInfo* device = (VrDeviceInfo*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(VrStereoConfig), NULL);
    VrStereoConfig out = LoadVrStereoConfig(*device);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(VrStereoConfig));
}

/**
 * Umka bindings for UnloadVrStereoConfig.
 *
 * @see UnloadVrStereoConfig()
 */
void umkaUnloadVrStereoConfig(UmkaStackSlot *params, UmkaStackSlot *result) {
    VrStereoConfig* config = (VrStereoConfig*)&params[0];
    UnloadVrStereoConfig(*config);
}

/**
 * Umka bindings for LoadShader.
 *
 * @see LoadShader()
 */
void umkaLoadShader(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    const char * vsFileName = (const char *)params[2].ptrVal;
    const char * fsFileName = (const char *)params[1].ptrVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Shader), NULL);
    Shader out = LoadShader(vsFileName, fsFileName);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Shader));
}

/**
 * Umka bindings for LoadShaderFromMemory.
 *
 * @see LoadShaderFromMemory()
 */
void umkaLoadShaderFromMemory(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    const char * vsCode = (const char *)params[2].ptrVal;
    const char * fsCode = (const char *)params[1].ptrVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Shader), NULL);
    Shader out = LoadShaderFromMemory(vsCode, fsCode);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Shader));
}

/**
 * Umka bindings for GetShaderLocation.
 *
 * @see GetShaderLocation()
 */
void umkaGetShaderLocation(UmkaStackSlot *params, UmkaStackSlot *result) {
    Shader* shader = (Shader*)&params[1];
    const char * uniformName = (const char *)params[0].ptrVal;
    result->intVal = GetShaderLocation(*shader, uniformName);
}

/**
 * Umka bindings for GetShaderLocationAttrib.
 *
 * @see GetShaderLocationAttrib()
 */
void umkaGetShaderLocationAttrib(UmkaStackSlot *params, UmkaStackSlot *result) {
    Shader* shader = (Shader*)&params[1];
    const char * attribName = (const char *)params[0].ptrVal;
    result->intVal = GetShaderLocationAttrib(*shader, attribName);
}

/**
 * Umka bindings for SetShaderValue.
 *
 * @see SetShaderValue()
 */
void umkaSetShaderValue(UmkaStackSlot *params, UmkaStackSlot *result) {
    Shader* shader = (Shader*)&params[3];
    int locIndex = params[2].intVal;
    const void * value = (const void *)params[1].ptrVal;
    int uniformType = params[0].intVal;
    SetShaderValue(*shader, locIndex, value, uniformType);
}

/**
 * Umka bindings for SetShaderValueV.
 *
 * @see SetShaderValueV()
 */
void umkaSetShaderValueV(UmkaStackSlot *params, UmkaStackSlot *result) {
    Shader* shader = (Shader*)&params[4];
    int locIndex = params[3].intVal;
    const void * value = (const void *)params[2].ptrVal;
    int uniformType = params[1].intVal;
    int count = params[0].intVal;
    SetShaderValueV(*shader, locIndex, value, uniformType, count);
}

/**
 * Umka bindings for SetShaderValueMatrix.
 *
 * @see SetShaderValueMatrix()
 */
void umkaSetShaderValueMatrix(UmkaStackSlot *params, UmkaStackSlot *result) {
    Shader* shader = (Shader*)&params[2];
    int locIndex = params[1].intVal;
    Matrix* mat = (Matrix*)&params[0];
    SetShaderValueMatrix(*shader, locIndex, *mat);
}

/**
 * Umka bindings for SetShaderValueTexture.
 *
 * @see SetShaderValueTexture()
 */
void umkaSetShaderValueTexture(UmkaStackSlot *params, UmkaStackSlot *result) {
    Shader* shader = (Shader*)&params[2];
    int locIndex = params[1].intVal;
    Texture2D* texture = (Texture2D*)&params[0];
    SetShaderValueTexture(*shader, locIndex, *texture);
}

/**
 * Umka bindings for UnloadShader.
 *
 * @see UnloadShader()
 */
void umkaUnloadShader(UmkaStackSlot *params, UmkaStackSlot *result) {
    Shader* shader = (Shader*)&params[0];
    UnloadShader(*shader);
}

/**
 * Umka bindings for GetMouseRay.
 *
 * @see GetMouseRay()
 */
void umkaGetMouseRay(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector2* mousePosition = (Vector2*)&params[2];
    Camera* camera = (Camera*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Ray), NULL);
    Ray out = GetMouseRay(*mousePosition, *camera);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Ray));
}

/**
 * Umka bindings for GetCameraMatrix.
 *
 * @see GetCameraMatrix()
 */
void umkaGetCameraMatrix(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Camera* camera = (Camera*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Matrix), NULL);
    Matrix out = GetCameraMatrix(*camera);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Matrix));
}

/**
 * Umka bindings for GetCameraMatrix2D.
 *
 * @see GetCameraMatrix2D()
 */
void umkaGetCameraMatrix2D(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Camera2D* camera = (Camera2D*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Matrix), NULL);
    Matrix out = GetCameraMatrix2D(*camera);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Matrix));
}

/**
 * Umka bindings for GetWorldToScreen.
 *
 * @see GetWorldToScreen()
 */
void umkaGetWorldToScreen(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector3* position = (Vector3*)&params[2];
    Camera* camera = (Camera*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector2), NULL);
    Vector2 out = GetWorldToScreen(*position, *camera);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector2));
}

/**
 * Umka bindings for GetScreenToWorld2D.
 *
 * @see GetScreenToWorld2D()
 */
void umkaGetScreenToWorld2D(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector2* position = (Vector2*)&params[2];
    Camera2D* camera = (Camera2D*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector2), NULL);
    Vector2 out = GetScreenToWorld2D(*position, *camera);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector2));
}

/**
 * Umka bindings for GetWorldToScreenEx.
 *
 * @see GetWorldToScreenEx()
 */
void umkaGetWorldToScreenEx(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector3* position = (Vector3*)&params[4];
    Camera* camera = (Camera*)&params[3];
    int width = params[2].intVal;
    int height = params[1].intVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector2), NULL);
    Vector2 out = GetWorldToScreenEx(*position, *camera, width, height);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector2));
}

/**
 * Umka bindings for GetWorldToScreen2D.
 *
 * @see GetWorldToScreen2D()
 */
void umkaGetWorldToScreen2D(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector2* position = (Vector2*)&params[2];
    Camera2D* camera = (Camera2D*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector2), NULL);
    Vector2 out = GetWorldToScreen2D(*position, *camera);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector2));
}

/**
 * Umka bindings for SetTargetFPS.
 *
 * @see SetTargetFPS()
 */
void umkaSetTargetFPS(UmkaStackSlot *params, UmkaStackSlot *result) {
    int fps = params[0].intVal;
    SetTargetFPS(fps);
}

/**
 * Umka bindings for GetFPS.
 *
 * @see GetFPS()
 */
void umkaGetFPS(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->intVal = GetFPS();
}

/**
 * Umka bindings for GetFrameTime.
 *
 * @see GetFrameTime()
 */
void umkaGetFrameTime(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->real32Val = GetFrameTime();
}

/**
 * Umka bindings for GetTime.
 *
 * @see GetTime()
 */
void umkaGetTime(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->realVal = GetTime();
}

/**
 * Umka bindings for GetRandomValue.
 *
 * @see GetRandomValue()
 */
void umkaGetRandomValue(UmkaStackSlot *params, UmkaStackSlot *result) {
    int min = params[1].intVal;
    int max = params[0].intVal;
    result->intVal = GetRandomValue(min, max);
}

/**
 * Umka bindings for SetRandomSeed.
 *
 * @see SetRandomSeed()
 */
void umkaSetRandomSeed(UmkaStackSlot *params, UmkaStackSlot *result) {
    unsigned int seed = params[0].uintVal;
    SetRandomSeed(seed);
}

/**
 * Umka bindings for TakeScreenshot.
 *
 * @see TakeScreenshot()
 */
void umkaTakeScreenshot(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * fileName = (const char *)params[0].ptrVal;
    TakeScreenshot(fileName);
}

/**
 * Umka bindings for SetConfigFlags.
 *
 * @see SetConfigFlags()
 */
void umkaSetConfigFlags(UmkaStackSlot *params, UmkaStackSlot *result) {
    unsigned int flags = params[0].uintVal;
    SetConfigFlags(flags);
}

// Function TraceLog() skipped

/**
 * Umka bindings for SetTraceLogLevel.
 *
 * @see SetTraceLogLevel()
 */
void umkaSetTraceLogLevel(UmkaStackSlot *params, UmkaStackSlot *result) {
    int logLevel = params[0].intVal;
    SetTraceLogLevel(logLevel);
}

/**
 * Umka bindings for MemAlloc.
 *
 * @see MemAlloc()
 */
void umkaMemAlloc(UmkaStackSlot *params, UmkaStackSlot *result) {
    int size = params[0].intVal;
    result->ptrVal = (void*)MemAlloc(size);
}

/**
 * Umka bindings for MemRealloc.
 *
 * @see MemRealloc()
 */
void umkaMemRealloc(UmkaStackSlot *params, UmkaStackSlot *result) {
    void * ptr = (void *)params[1].ptrVal;
    int size = params[0].intVal;
    result->ptrVal = (void*)MemRealloc(ptr, size);
}

/**
 * Umka bindings for MemFree.
 *
 * @see MemFree()
 */
void umkaMemFree(UmkaStackSlot *params, UmkaStackSlot *result) {
    void * ptr = (void *)params[0].ptrVal;
    MemFree(ptr);
}

/**
 * Umka bindings for OpenURL.
 *
 * @see OpenURL()
 */
void umkaOpenURL(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * url = (const char *)params[0].ptrVal;
    OpenURL(url);
}

// Function SetTraceLogCallback() skipped

// Function SetLoadFileDataCallback() skipped

// Function SetSaveFileDataCallback() skipped

// Function SetLoadFileTextCallback() skipped

// Function SetSaveFileTextCallback() skipped

/**
 * Umka bindings for LoadFileData.
 *
 * @see LoadFileData()
 */
void umkaLoadFileData(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * fileName = (const char *)params[1].ptrVal;
    unsigned int * bytesRead = (unsigned int *)params[0].ptrVal;
    result->ptrVal = (void*)LoadFileData(fileName, bytesRead);
}

/**
 * Umka bindings for UnloadFileData.
 *
 * @see UnloadFileData()
 */
void umkaUnloadFileData(UmkaStackSlot *params, UmkaStackSlot *result) {
    unsigned char * data = (unsigned char *)params[0].ptrVal;
    UnloadFileData(data);
}

/**
 * Umka bindings for SaveFileData.
 *
 * @see SaveFileData()
 */
void umkaSaveFileData(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * fileName = (const char *)params[2].ptrVal;
    void * data = (void *)params[1].ptrVal;
    unsigned int bytesToWrite = params[0].uintVal;
    result->intVal = (int)SaveFileData(fileName, data, bytesToWrite);
}

/**
 * Umka bindings for ExportDataAsCode.
 *
 * @see ExportDataAsCode()
 */
void umkaExportDataAsCode(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * data = (const char *)params[2].ptrVal;
    unsigned int size = params[1].uintVal;
    const char * fileName = (const char *)params[0].ptrVal;
    result->intVal = (int)ExportDataAsCode(data, size, fileName);
}

/**
 * Umka bindings for LoadFileText.
 *
 * @see LoadFileText()
 */
void umkaLoadFileText(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * fileName = (const char *)params[0].ptrVal;
    result->ptrVal = (void*)LoadFileText(fileName);
}

/**
 * Umka bindings for UnloadFileText.
 *
 * @see UnloadFileText()
 */
void umkaUnloadFileText(UmkaStackSlot *params, UmkaStackSlot *result) {
    char * text = (char *)params[0].ptrVal;
    UnloadFileText(text);
}

/**
 * Umka bindings for SaveFileText.
 *
 * @see SaveFileText()
 */
void umkaSaveFileText(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * fileName = (const char *)params[1].ptrVal;
    char * text = (char *)params[0].ptrVal;
    result->intVal = (int)SaveFileText(fileName, text);
}

/**
 * Umka bindings for FileExists.
 *
 * @see FileExists()
 */
void umkaFileExists(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * fileName = (const char *)params[0].ptrVal;
    result->intVal = (int)FileExists(fileName);
}

/**
 * Umka bindings for DirectoryExists.
 *
 * @see DirectoryExists()
 */
void umkaDirectoryExists(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * dirPath = (const char *)params[0].ptrVal;
    result->intVal = (int)DirectoryExists(dirPath);
}

/**
 * Umka bindings for IsFileExtension.
 *
 * @see IsFileExtension()
 */
void umkaIsFileExtension(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * fileName = (const char *)params[1].ptrVal;
    const char * ext = (const char *)params[0].ptrVal;
    result->intVal = (int)IsFileExtension(fileName, ext);
}

/**
 * Umka bindings for GetFileLength.
 *
 * @see GetFileLength()
 */
void umkaGetFileLength(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * fileName = (const char *)params[0].ptrVal;
    result->intVal = GetFileLength(fileName);
}

/**
 * Umka bindings for GetFileExtension.
 *
 * @see GetFileExtension()
 */
void umkaGetFileExtension(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * fileName = (const char *)params[0].ptrVal;
    result->ptrVal = (void*)GetFileExtension(fileName);
}

/**
 * Umka bindings for GetFileName.
 *
 * @see GetFileName()
 */
void umkaGetFileName(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * filePath = (const char *)params[0].ptrVal;
    result->ptrVal = (void*)GetFileName(filePath);
}

/**
 * Umka bindings for GetFileNameWithoutExt.
 *
 * @see GetFileNameWithoutExt()
 */
void umkaGetFileNameWithoutExt(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * filePath = (const char *)params[0].ptrVal;
    result->ptrVal = (void*)GetFileNameWithoutExt(filePath);
}

/**
 * Umka bindings for GetDirectoryPath.
 *
 * @see GetDirectoryPath()
 */
void umkaGetDirectoryPath(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * filePath = (const char *)params[0].ptrVal;
    result->ptrVal = (void*)GetDirectoryPath(filePath);
}

/**
 * Umka bindings for GetPrevDirectoryPath.
 *
 * @see GetPrevDirectoryPath()
 */
void umkaGetPrevDirectoryPath(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * dirPath = (const char *)params[0].ptrVal;
    result->ptrVal = (void*)GetPrevDirectoryPath(dirPath);
}

/**
 * Umka bindings for GetWorkingDirectory.
 *
 * @see GetWorkingDirectory()
 */
void umkaGetWorkingDirectory(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->ptrVal = (void*)GetWorkingDirectory();
}

/**
 * Umka bindings for GetApplicationDirectory.
 *
 * @see GetApplicationDirectory()
 */
void umkaGetApplicationDirectory(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->ptrVal = (void*)GetApplicationDirectory();
}

/**
 * Umka bindings for ChangeDirectory.
 *
 * @see ChangeDirectory()
 */
void umkaChangeDirectory(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * dir = (const char *)params[0].ptrVal;
    result->intVal = (int)ChangeDirectory(dir);
}

/**
 * Umka bindings for IsPathFile.
 *
 * @see IsPathFile()
 */
void umkaIsPathFile(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * path = (const char *)params[0].ptrVal;
    result->intVal = (int)IsPathFile(path);
}

/**
 * Umka bindings for LoadDirectoryFiles.
 *
 * @see LoadDirectoryFiles()
 */
void umkaLoadDirectoryFiles(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    const char * dirPath = (const char *)params[1].ptrVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(FilePathList), NULL);
    FilePathList out = LoadDirectoryFiles(dirPath);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(FilePathList));
}

/**
 * Umka bindings for LoadDirectoryFilesEx.
 *
 * @see LoadDirectoryFilesEx()
 */
void umkaLoadDirectoryFilesEx(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    const char * basePath = (const char *)params[3].ptrVal;
    const char * filter = (const char *)params[2].ptrVal;
    bool scanSubdirs = (bool)params[1].intVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(FilePathList), NULL);
    FilePathList out = LoadDirectoryFilesEx(basePath, filter, scanSubdirs);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(FilePathList));
}

/**
 * Umka bindings for UnloadDirectoryFiles.
 *
 * @see UnloadDirectoryFiles()
 */
void umkaUnloadDirectoryFiles(UmkaStackSlot *params, UmkaStackSlot *result) {
    FilePathList* files = (FilePathList*)&params[0];
    UnloadDirectoryFiles(*files);
}

/**
 * Umka bindings for IsFileDropped.
 *
 * @see IsFileDropped()
 */
void umkaIsFileDropped(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->intVal = (int)IsFileDropped();
}

/**
 * Umka bindings for LoadDroppedFiles.
 *
 * @see LoadDroppedFiles()
 */
void umkaLoadDroppedFiles(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(FilePathList), NULL);
    FilePathList out = LoadDroppedFiles();
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(FilePathList));
}

/**
 * Umka bindings for UnloadDroppedFiles.
 *
 * @see UnloadDroppedFiles()
 */
void umkaUnloadDroppedFiles(UmkaStackSlot *params, UmkaStackSlot *result) {
    FilePathList* files = (FilePathList*)&params[0];
    UnloadDroppedFiles(*files);
}

/**
 * Umka bindings for GetFileModTime.
 *
 * @see GetFileModTime()
 */
void umkaGetFileModTime(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * fileName = (const char *)params[0].ptrVal;
    result->intVal = GetFileModTime(fileName);
}

/**
 * Umka bindings for CompressData.
 *
 * @see CompressData()
 */
void umkaCompressData(UmkaStackSlot *params, UmkaStackSlot *result) {
    const unsigned char * data = (const unsigned char *)params[2].ptrVal;
    int dataSize = params[1].intVal;
    int * compDataSize = (int *)params[0].ptrVal;
    result->ptrVal = (void*)CompressData(data, dataSize, compDataSize);
}

/**
 * Umka bindings for DecompressData.
 *
 * @see DecompressData()
 */
void umkaDecompressData(UmkaStackSlot *params, UmkaStackSlot *result) {
    const unsigned char * compData = (const unsigned char *)params[2].ptrVal;
    int compDataSize = params[1].intVal;
    int * dataSize = (int *)params[0].ptrVal;
    result->ptrVal = (void*)DecompressData(compData, compDataSize, dataSize);
}

/**
 * Umka bindings for EncodeDataBase64.
 *
 * @see EncodeDataBase64()
 */
void umkaEncodeDataBase64(UmkaStackSlot *params, UmkaStackSlot *result) {
    const unsigned char * data = (const unsigned char *)params[2].ptrVal;
    int dataSize = params[1].intVal;
    int * outputSize = (int *)params[0].ptrVal;
    result->ptrVal = (void*)EncodeDataBase64(data, dataSize, outputSize);
}

/**
 * Umka bindings for DecodeDataBase64.
 *
 * @see DecodeDataBase64()
 */
void umkaDecodeDataBase64(UmkaStackSlot *params, UmkaStackSlot *result) {
    const unsigned char * data = (const unsigned char *)params[1].ptrVal;
    int * outputSize = (int *)params[0].ptrVal;
    result->ptrVal = (void*)DecodeDataBase64(data, outputSize);
}

/**
 * Umka bindings for IsKeyPressed.
 *
 * @see IsKeyPressed()
 */
void umkaIsKeyPressed(UmkaStackSlot *params, UmkaStackSlot *result) {
    int key = params[0].intVal;
    result->intVal = (int)IsKeyPressed(key);
}

/**
 * Umka bindings for IsKeyDown.
 *
 * @see IsKeyDown()
 */
void umkaIsKeyDown(UmkaStackSlot *params, UmkaStackSlot *result) {
    int key = params[0].intVal;
    result->intVal = (int)IsKeyDown(key);
}

/**
 * Umka bindings for IsKeyReleased.
 *
 * @see IsKeyReleased()
 */
void umkaIsKeyReleased(UmkaStackSlot *params, UmkaStackSlot *result) {
    int key = params[0].intVal;
    result->intVal = (int)IsKeyReleased(key);
}

/**
 * Umka bindings for IsKeyUp.
 *
 * @see IsKeyUp()
 */
void umkaIsKeyUp(UmkaStackSlot *params, UmkaStackSlot *result) {
    int key = params[0].intVal;
    result->intVal = (int)IsKeyUp(key);
}

/**
 * Umka bindings for SetExitKey.
 *
 * @see SetExitKey()
 */
void umkaSetExitKey(UmkaStackSlot *params, UmkaStackSlot *result) {
    int key = params[0].intVal;
    SetExitKey(key);
}

/**
 * Umka bindings for GetKeyPressed.
 *
 * @see GetKeyPressed()
 */
void umkaGetKeyPressed(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->intVal = GetKeyPressed();
}

/**
 * Umka bindings for GetCharPressed.
 *
 * @see GetCharPressed()
 */
void umkaGetCharPressed(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->intVal = GetCharPressed();
}

/**
 * Umka bindings for IsGamepadAvailable.
 *
 * @see IsGamepadAvailable()
 */
void umkaIsGamepadAvailable(UmkaStackSlot *params, UmkaStackSlot *result) {
    int gamepad = params[0].intVal;
    result->intVal = (int)IsGamepadAvailable(gamepad);
}

/**
 * Umka bindings for GetGamepadName.
 *
 * @see GetGamepadName()
 */
void umkaGetGamepadName(UmkaStackSlot *params, UmkaStackSlot *result) {
    int gamepad = params[0].intVal;
    result->ptrVal = (void*)GetGamepadName(gamepad);
}

/**
 * Umka bindings for IsGamepadButtonPressed.
 *
 * @see IsGamepadButtonPressed()
 */
void umkaIsGamepadButtonPressed(UmkaStackSlot *params, UmkaStackSlot *result) {
    int gamepad = params[1].intVal;
    int button = params[0].intVal;
    result->intVal = (int)IsGamepadButtonPressed(gamepad, button);
}

/**
 * Umka bindings for IsGamepadButtonDown.
 *
 * @see IsGamepadButtonDown()
 */
void umkaIsGamepadButtonDown(UmkaStackSlot *params, UmkaStackSlot *result) {
    int gamepad = params[1].intVal;
    int button = params[0].intVal;
    result->intVal = (int)IsGamepadButtonDown(gamepad, button);
}

/**
 * Umka bindings for IsGamepadButtonReleased.
 *
 * @see IsGamepadButtonReleased()
 */
void umkaIsGamepadButtonReleased(UmkaStackSlot *params, UmkaStackSlot *result) {
    int gamepad = params[1].intVal;
    int button = params[0].intVal;
    result->intVal = (int)IsGamepadButtonReleased(gamepad, button);
}

/**
 * Umka bindings for IsGamepadButtonUp.
 *
 * @see IsGamepadButtonUp()
 */
void umkaIsGamepadButtonUp(UmkaStackSlot *params, UmkaStackSlot *result) {
    int gamepad = params[1].intVal;
    int button = params[0].intVal;
    result->intVal = (int)IsGamepadButtonUp(gamepad, button);
}

/**
 * Umka bindings for GetGamepadButtonPressed.
 *
 * @see GetGamepadButtonPressed()
 */
void umkaGetGamepadButtonPressed(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->intVal = GetGamepadButtonPressed();
}

/**
 * Umka bindings for GetGamepadAxisCount.
 *
 * @see GetGamepadAxisCount()
 */
void umkaGetGamepadAxisCount(UmkaStackSlot *params, UmkaStackSlot *result) {
    int gamepad = params[0].intVal;
    result->intVal = GetGamepadAxisCount(gamepad);
}

/**
 * Umka bindings for GetGamepadAxisMovement.
 *
 * @see GetGamepadAxisMovement()
 */
void umkaGetGamepadAxisMovement(UmkaStackSlot *params, UmkaStackSlot *result) {
    int gamepad = params[1].intVal;
    int axis = params[0].intVal;
    result->real32Val = GetGamepadAxisMovement(gamepad, axis);
}

/**
 * Umka bindings for SetGamepadMappings.
 *
 * @see SetGamepadMappings()
 */
void umkaSetGamepadMappings(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * mappings = (const char *)params[0].ptrVal;
    result->intVal = SetGamepadMappings(mappings);
}

/**
 * Umka bindings for IsMouseButtonPressed.
 *
 * @see IsMouseButtonPressed()
 */
void umkaIsMouseButtonPressed(UmkaStackSlot *params, UmkaStackSlot *result) {
    int button = params[0].intVal;
    result->intVal = (int)IsMouseButtonPressed(button);
}

/**
 * Umka bindings for IsMouseButtonDown.
 *
 * @see IsMouseButtonDown()
 */
void umkaIsMouseButtonDown(UmkaStackSlot *params, UmkaStackSlot *result) {
    int button = params[0].intVal;
    result->intVal = (int)IsMouseButtonDown(button);
}

/**
 * Umka bindings for IsMouseButtonReleased.
 *
 * @see IsMouseButtonReleased()
 */
void umkaIsMouseButtonReleased(UmkaStackSlot *params, UmkaStackSlot *result) {
    int button = params[0].intVal;
    result->intVal = (int)IsMouseButtonReleased(button);
}

/**
 * Umka bindings for IsMouseButtonUp.
 *
 * @see IsMouseButtonUp()
 */
void umkaIsMouseButtonUp(UmkaStackSlot *params, UmkaStackSlot *result) {
    int button = params[0].intVal;
    result->intVal = (int)IsMouseButtonUp(button);
}

/**
 * Umka bindings for GetMouseX.
 *
 * @see GetMouseX()
 */
void umkaGetMouseX(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->intVal = GetMouseX();
}

/**
 * Umka bindings for GetMouseY.
 *
 * @see GetMouseY()
 */
void umkaGetMouseY(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->intVal = GetMouseY();
}

/**
 * Umka bindings for GetMousePosition.
 *
 * @see GetMousePosition()
 */
void umkaGetMousePosition(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector2), NULL);
    Vector2 out = GetMousePosition();
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector2));
}

/**
 * Umka bindings for GetMouseDelta.
 *
 * @see GetMouseDelta()
 */
void umkaGetMouseDelta(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector2), NULL);
    Vector2 out = GetMouseDelta();
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector2));
}

/**
 * Umka bindings for SetMousePosition.
 *
 * @see SetMousePosition()
 */
void umkaSetMousePosition(UmkaStackSlot *params, UmkaStackSlot *result) {
    int x = params[1].intVal;
    int y = params[0].intVal;
    SetMousePosition(x, y);
}

/**
 * Umka bindings for SetMouseOffset.
 *
 * @see SetMouseOffset()
 */
void umkaSetMouseOffset(UmkaStackSlot *params, UmkaStackSlot *result) {
    int offsetX = params[1].intVal;
    int offsetY = params[0].intVal;
    SetMouseOffset(offsetX, offsetY);
}

/**
 * Umka bindings for SetMouseScale.
 *
 * @see SetMouseScale()
 */
void umkaSetMouseScale(UmkaStackSlot *params, UmkaStackSlot *result) {
    float scaleX = params[1].real32Val;
    float scaleY = params[0].real32Val;
    SetMouseScale(scaleX, scaleY);
}

/**
 * Umka bindings for GetMouseWheelMove.
 *
 * @see GetMouseWheelMove()
 */
void umkaGetMouseWheelMove(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->real32Val = GetMouseWheelMove();
}

/**
 * Umka bindings for GetMouseWheelMoveV.
 *
 * @see GetMouseWheelMoveV()
 */
void umkaGetMouseWheelMoveV(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector2), NULL);
    Vector2 out = GetMouseWheelMoveV();
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector2));
}

/**
 * Umka bindings for SetMouseCursor.
 *
 * @see SetMouseCursor()
 */
void umkaSetMouseCursor(UmkaStackSlot *params, UmkaStackSlot *result) {
    int cursor = params[0].intVal;
    SetMouseCursor(cursor);
}

/**
 * Umka bindings for GetTouchX.
 *
 * @see GetTouchX()
 */
void umkaGetTouchX(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->intVal = GetTouchX();
}

/**
 * Umka bindings for GetTouchY.
 *
 * @see GetTouchY()
 */
void umkaGetTouchY(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->intVal = GetTouchY();
}

/**
 * Umka bindings for GetTouchPosition.
 *
 * @see GetTouchPosition()
 */
void umkaGetTouchPosition(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    int index = params[1].intVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector2), NULL);
    Vector2 out = GetTouchPosition(index);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector2));
}

/**
 * Umka bindings for GetTouchPointId.
 *
 * @see GetTouchPointId()
 */
void umkaGetTouchPointId(UmkaStackSlot *params, UmkaStackSlot *result) {
    int index = params[0].intVal;
    result->intVal = GetTouchPointId(index);
}

/**
 * Umka bindings for GetTouchPointCount.
 *
 * @see GetTouchPointCount()
 */
void umkaGetTouchPointCount(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->intVal = GetTouchPointCount();
}

/**
 * Umka bindings for SetGesturesEnabled.
 *
 * @see SetGesturesEnabled()
 */
void umkaSetGesturesEnabled(UmkaStackSlot *params, UmkaStackSlot *result) {
    unsigned int flags = params[0].uintVal;
    SetGesturesEnabled(flags);
}

/**
 * Umka bindings for IsGestureDetected.
 *
 * @see IsGestureDetected()
 */
void umkaIsGestureDetected(UmkaStackSlot *params, UmkaStackSlot *result) {
    int gesture = params[0].intVal;
    result->intVal = (int)IsGestureDetected(gesture);
}

/**
 * Umka bindings for GetGestureDetected.
 *
 * @see GetGestureDetected()
 */
void umkaGetGestureDetected(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->intVal = GetGestureDetected();
}

/**
 * Umka bindings for GetGestureHoldDuration.
 *
 * @see GetGestureHoldDuration()
 */
void umkaGetGestureHoldDuration(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->real32Val = GetGestureHoldDuration();
}

/**
 * Umka bindings for GetGestureDragVector.
 *
 * @see GetGestureDragVector()
 */
void umkaGetGestureDragVector(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector2), NULL);
    Vector2 out = GetGestureDragVector();
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector2));
}

/**
 * Umka bindings for GetGestureDragAngle.
 *
 * @see GetGestureDragAngle()
 */
void umkaGetGestureDragAngle(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->real32Val = GetGestureDragAngle();
}

/**
 * Umka bindings for GetGesturePinchVector.
 *
 * @see GetGesturePinchVector()
 */
void umkaGetGesturePinchVector(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector2), NULL);
    Vector2 out = GetGesturePinchVector();
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector2));
}

/**
 * Umka bindings for GetGesturePinchAngle.
 *
 * @see GetGesturePinchAngle()
 */
void umkaGetGesturePinchAngle(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->real32Val = GetGesturePinchAngle();
}

/**
 * Umka bindings for SetCameraMode.
 *
 * @see SetCameraMode()
 */
void umkaSetCameraMode(UmkaStackSlot *params, UmkaStackSlot *result) {
    Camera* camera = (Camera*)&params[1];
    int mode = params[0].intVal;
    SetCameraMode(*camera, mode);
}

/**
 * Umka bindings for UpdateCamera.
 *
 * @see UpdateCamera()
 */
void umkaUpdateCamera(UmkaStackSlot *params, UmkaStackSlot *result) {
    Camera * camera = (Camera *)params[0].ptrVal;
    UpdateCamera(camera);
}

/**
 * Umka bindings for SetCameraPanControl.
 *
 * @see SetCameraPanControl()
 */
void umkaSetCameraPanControl(UmkaStackSlot *params, UmkaStackSlot *result) {
    int keyPan = params[0].intVal;
    SetCameraPanControl(keyPan);
}

/**
 * Umka bindings for SetCameraAltControl.
 *
 * @see SetCameraAltControl()
 */
void umkaSetCameraAltControl(UmkaStackSlot *params, UmkaStackSlot *result) {
    int keyAlt = params[0].intVal;
    SetCameraAltControl(keyAlt);
}

/**
 * Umka bindings for SetCameraSmoothZoomControl.
 *
 * @see SetCameraSmoothZoomControl()
 */
void umkaSetCameraSmoothZoomControl(UmkaStackSlot *params, UmkaStackSlot *result) {
    int keySmoothZoom = params[0].intVal;
    SetCameraSmoothZoomControl(keySmoothZoom);
}

/**
 * Umka bindings for SetCameraMoveControls.
 *
 * @see SetCameraMoveControls()
 */
void umkaSetCameraMoveControls(UmkaStackSlot *params, UmkaStackSlot *result) {
    int keyFront = params[5].intVal;
    int keyBack = params[4].intVal;
    int keyRight = params[3].intVal;
    int keyLeft = params[2].intVal;
    int keyUp = params[1].intVal;
    int keyDown = params[0].intVal;
    SetCameraMoveControls(keyFront, keyBack, keyRight, keyLeft, keyUp, keyDown);
}

/**
 * Umka bindings for SetShapesTexture.
 *
 * @see SetShapesTexture()
 */
void umkaSetShapesTexture(UmkaStackSlot *params, UmkaStackSlot *result) {
    Texture2D* texture = (Texture2D*)&params[1];
    Rectangle* source = (Rectangle*)&params[0];
    SetShapesTexture(*texture, *source);
}

/**
 * Umka bindings for DrawPixel.
 *
 * @see DrawPixel()
 */
void umkaDrawPixel(UmkaStackSlot *params, UmkaStackSlot *result) {
    int posX = params[2].intVal;
    int posY = params[1].intVal;
    Color* color = (Color*)&params[0];
    DrawPixel(posX, posY, *color);
}

/**
 * Umka bindings for DrawPixelV.
 *
 * @see DrawPixelV()
 */
void umkaDrawPixelV(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2* position = (Vector2*)&params[1];
    Color* color = (Color*)&params[0];
    DrawPixelV(*position, *color);
}

/**
 * Umka bindings for DrawLine.
 *
 * @see DrawLine()
 */
void umkaDrawLine(UmkaStackSlot *params, UmkaStackSlot *result) {
    int startPosX = params[4].intVal;
    int startPosY = params[3].intVal;
    int endPosX = params[2].intVal;
    int endPosY = params[1].intVal;
    Color* color = (Color*)&params[0];
    DrawLine(startPosX, startPosY, endPosX, endPosY, *color);
}

/**
 * Umka bindings for DrawLineV.
 *
 * @see DrawLineV()
 */
void umkaDrawLineV(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2* startPos = (Vector2*)&params[2];
    Vector2* endPos = (Vector2*)&params[1];
    Color* color = (Color*)&params[0];
    DrawLineV(*startPos, *endPos, *color);
}

/**
 * Umka bindings for DrawLineEx.
 *
 * @see DrawLineEx()
 */
void umkaDrawLineEx(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2* startPos = (Vector2*)&params[3];
    Vector2* endPos = (Vector2*)&params[2];
    float thick = params[1].real32Val;
    Color* color = (Color*)&params[0];
    DrawLineEx(*startPos, *endPos, thick, *color);
}

/**
 * Umka bindings for DrawLineBezier.
 *
 * @see DrawLineBezier()
 */
void umkaDrawLineBezier(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2* startPos = (Vector2*)&params[3];
    Vector2* endPos = (Vector2*)&params[2];
    float thick = params[1].real32Val;
    Color* color = (Color*)&params[0];
    DrawLineBezier(*startPos, *endPos, thick, *color);
}

/**
 * Umka bindings for DrawLineBezierQuad.
 *
 * @see DrawLineBezierQuad()
 */
void umkaDrawLineBezierQuad(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2* startPos = (Vector2*)&params[4];
    Vector2* endPos = (Vector2*)&params[3];
    Vector2* controlPos = (Vector2*)&params[2];
    float thick = params[1].real32Val;
    Color* color = (Color*)&params[0];
    DrawLineBezierQuad(*startPos, *endPos, *controlPos, thick, *color);
}

/**
 * Umka bindings for DrawLineBezierCubic.
 *
 * @see DrawLineBezierCubic()
 */
void umkaDrawLineBezierCubic(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2* startPos = (Vector2*)&params[5];
    Vector2* endPos = (Vector2*)&params[4];
    Vector2* startControlPos = (Vector2*)&params[3];
    Vector2* endControlPos = (Vector2*)&params[2];
    float thick = params[1].real32Val;
    Color* color = (Color*)&params[0];
    DrawLineBezierCubic(*startPos, *endPos, *startControlPos, *endControlPos, thick, *color);
}

/**
 * Umka bindings for DrawLineStrip.
 *
 * @see DrawLineStrip()
 */
void umkaDrawLineStrip(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2 * points = (Vector2 *)params[2].ptrVal;
    int pointCount = params[1].intVal;
    Color* color = (Color*)&params[0];
    DrawLineStrip(points, pointCount, *color);
}

/**
 * Umka bindings for DrawCircle.
 *
 * @see DrawCircle()
 */
void umkaDrawCircle(UmkaStackSlot *params, UmkaStackSlot *result) {
    int centerX = params[3].intVal;
    int centerY = params[2].intVal;
    float radius = params[1].real32Val;
    Color* color = (Color*)&params[0];
    DrawCircle(centerX, centerY, radius, *color);
}

/**
 * Umka bindings for DrawCircleSector.
 *
 * @see DrawCircleSector()
 */
void umkaDrawCircleSector(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2* center = (Vector2*)&params[5];
    float radius = params[4].real32Val;
    float startAngle = params[3].real32Val;
    float endAngle = params[2].real32Val;
    int segments = params[1].intVal;
    Color* color = (Color*)&params[0];
    DrawCircleSector(*center, radius, startAngle, endAngle, segments, *color);
}

/**
 * Umka bindings for DrawCircleSectorLines.
 *
 * @see DrawCircleSectorLines()
 */
void umkaDrawCircleSectorLines(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2* center = (Vector2*)&params[5];
    float radius = params[4].real32Val;
    float startAngle = params[3].real32Val;
    float endAngle = params[2].real32Val;
    int segments = params[1].intVal;
    Color* color = (Color*)&params[0];
    DrawCircleSectorLines(*center, radius, startAngle, endAngle, segments, *color);
}

/**
 * Umka bindings for DrawCircleGradient.
 *
 * @see DrawCircleGradient()
 */
void umkaDrawCircleGradient(UmkaStackSlot *params, UmkaStackSlot *result) {
    int centerX = params[4].intVal;
    int centerY = params[3].intVal;
    float radius = params[2].real32Val;
    Color* color1 = (Color*)&params[1];
    Color* color2 = (Color*)&params[0];
    DrawCircleGradient(centerX, centerY, radius, *color1, *color2);
}

/**
 * Umka bindings for DrawCircleV.
 *
 * @see DrawCircleV()
 */
void umkaDrawCircleV(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2* center = (Vector2*)&params[2];
    float radius = params[1].real32Val;
    Color* color = (Color*)&params[0];
    DrawCircleV(*center, radius, *color);
}

/**
 * Umka bindings for DrawCircleLines.
 *
 * @see DrawCircleLines()
 */
void umkaDrawCircleLines(UmkaStackSlot *params, UmkaStackSlot *result) {
    int centerX = params[3].intVal;
    int centerY = params[2].intVal;
    float radius = params[1].real32Val;
    Color* color = (Color*)&params[0];
    DrawCircleLines(centerX, centerY, radius, *color);
}

/**
 * Umka bindings for DrawEllipse.
 *
 * @see DrawEllipse()
 */
void umkaDrawEllipse(UmkaStackSlot *params, UmkaStackSlot *result) {
    int centerX = params[4].intVal;
    int centerY = params[3].intVal;
    float radiusH = params[2].real32Val;
    float radiusV = params[1].real32Val;
    Color* color = (Color*)&params[0];
    DrawEllipse(centerX, centerY, radiusH, radiusV, *color);
}

/**
 * Umka bindings for DrawEllipseLines.
 *
 * @see DrawEllipseLines()
 */
void umkaDrawEllipseLines(UmkaStackSlot *params, UmkaStackSlot *result) {
    int centerX = params[4].intVal;
    int centerY = params[3].intVal;
    float radiusH = params[2].real32Val;
    float radiusV = params[1].real32Val;
    Color* color = (Color*)&params[0];
    DrawEllipseLines(centerX, centerY, radiusH, radiusV, *color);
}

/**
 * Umka bindings for DrawRing.
 *
 * @see DrawRing()
 */
void umkaDrawRing(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2* center = (Vector2*)&params[6];
    float innerRadius = params[5].real32Val;
    float outerRadius = params[4].real32Val;
    float startAngle = params[3].real32Val;
    float endAngle = params[2].real32Val;
    int segments = params[1].intVal;
    Color* color = (Color*)&params[0];
    DrawRing(*center, innerRadius, outerRadius, startAngle, endAngle, segments, *color);
}

/**
 * Umka bindings for DrawRingLines.
 *
 * @see DrawRingLines()
 */
void umkaDrawRingLines(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2* center = (Vector2*)&params[6];
    float innerRadius = params[5].real32Val;
    float outerRadius = params[4].real32Val;
    float startAngle = params[3].real32Val;
    float endAngle = params[2].real32Val;
    int segments = params[1].intVal;
    Color* color = (Color*)&params[0];
    DrawRingLines(*center, innerRadius, outerRadius, startAngle, endAngle, segments, *color);
}

/**
 * Umka bindings for DrawRectangle.
 *
 * @see DrawRectangle()
 */
void umkaDrawRectangle(UmkaStackSlot *params, UmkaStackSlot *result) {
    int posX = params[4].intVal;
    int posY = params[3].intVal;
    int width = params[2].intVal;
    int height = params[1].intVal;
    Color* color = (Color*)&params[0];
    DrawRectangle(posX, posY, width, height, *color);
}

/**
 * Umka bindings for DrawRectangleV.
 *
 * @see DrawRectangleV()
 */
void umkaDrawRectangleV(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2* position = (Vector2*)&params[2];
    Vector2* size = (Vector2*)&params[1];
    Color* color = (Color*)&params[0];
    DrawRectangleV(*position, *size, *color);
}

/**
 * Umka bindings for DrawRectangleRec.
 *
 * @see DrawRectangleRec()
 */
void umkaDrawRectangleRec(UmkaStackSlot *params, UmkaStackSlot *result) {
    Rectangle* rec = (Rectangle*)&params[1];
    Color* color = (Color*)&params[0];
    DrawRectangleRec(*rec, *color);
}

/**
 * Umka bindings for DrawRectanglePro.
 *
 * @see DrawRectanglePro()
 */
void umkaDrawRectanglePro(UmkaStackSlot *params, UmkaStackSlot *result) {
    Rectangle* rec = (Rectangle*)&params[3];
    Vector2* origin = (Vector2*)&params[2];
    float rotation = params[1].real32Val;
    Color* color = (Color*)&params[0];
    DrawRectanglePro(*rec, *origin, rotation, *color);
}

/**
 * Umka bindings for DrawRectangleGradientV.
 *
 * @see DrawRectangleGradientV()
 */
void umkaDrawRectangleGradientV(UmkaStackSlot *params, UmkaStackSlot *result) {
    int posX = params[5].intVal;
    int posY = params[4].intVal;
    int width = params[3].intVal;
    int height = params[2].intVal;
    Color* color1 = (Color*)&params[1];
    Color* color2 = (Color*)&params[0];
    DrawRectangleGradientV(posX, posY, width, height, *color1, *color2);
}

/**
 * Umka bindings for DrawRectangleGradientH.
 *
 * @see DrawRectangleGradientH()
 */
void umkaDrawRectangleGradientH(UmkaStackSlot *params, UmkaStackSlot *result) {
    int posX = params[5].intVal;
    int posY = params[4].intVal;
    int width = params[3].intVal;
    int height = params[2].intVal;
    Color* color1 = (Color*)&params[1];
    Color* color2 = (Color*)&params[0];
    DrawRectangleGradientH(posX, posY, width, height, *color1, *color2);
}

/**
 * Umka bindings for DrawRectangleGradientEx.
 *
 * @see DrawRectangleGradientEx()
 */
void umkaDrawRectangleGradientEx(UmkaStackSlot *params, UmkaStackSlot *result) {
    Rectangle* rec = (Rectangle*)&params[4];
    Color* col1 = (Color*)&params[3];
    Color* col2 = (Color*)&params[2];
    Color* col3 = (Color*)&params[1];
    Color* col4 = (Color*)&params[0];
    DrawRectangleGradientEx(*rec, *col1, *col2, *col3, *col4);
}

/**
 * Umka bindings for DrawRectangleLines.
 *
 * @see DrawRectangleLines()
 */
void umkaDrawRectangleLines(UmkaStackSlot *params, UmkaStackSlot *result) {
    int posX = params[4].intVal;
    int posY = params[3].intVal;
    int width = params[2].intVal;
    int height = params[1].intVal;
    Color* color = (Color*)&params[0];
    DrawRectangleLines(posX, posY, width, height, *color);
}

/**
 * Umka bindings for DrawRectangleLinesEx.
 *
 * @see DrawRectangleLinesEx()
 */
void umkaDrawRectangleLinesEx(UmkaStackSlot *params, UmkaStackSlot *result) {
    Rectangle* rec = (Rectangle*)&params[2];
    float lineThick = params[1].real32Val;
    Color* color = (Color*)&params[0];
    DrawRectangleLinesEx(*rec, lineThick, *color);
}

/**
 * Umka bindings for DrawRectangleRounded.
 *
 * @see DrawRectangleRounded()
 */
void umkaDrawRectangleRounded(UmkaStackSlot *params, UmkaStackSlot *result) {
    Rectangle* rec = (Rectangle*)&params[3];
    float roundness = params[2].real32Val;
    int segments = params[1].intVal;
    Color* color = (Color*)&params[0];
    DrawRectangleRounded(*rec, roundness, segments, *color);
}

/**
 * Umka bindings for DrawRectangleRoundedLines.
 *
 * @see DrawRectangleRoundedLines()
 */
void umkaDrawRectangleRoundedLines(UmkaStackSlot *params, UmkaStackSlot *result) {
    Rectangle* rec = (Rectangle*)&params[4];
    float roundness = params[3].real32Val;
    int segments = params[2].intVal;
    float lineThick = params[1].real32Val;
    Color* color = (Color*)&params[0];
    DrawRectangleRoundedLines(*rec, roundness, segments, lineThick, *color);
}

/**
 * Umka bindings for DrawTriangle.
 *
 * @see DrawTriangle()
 */
void umkaDrawTriangle(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2* v1 = (Vector2*)&params[3];
    Vector2* v2 = (Vector2*)&params[2];
    Vector2* v3 = (Vector2*)&params[1];
    Color* color = (Color*)&params[0];
    DrawTriangle(*v1, *v2, *v3, *color);
}

/**
 * Umka bindings for DrawTriangleLines.
 *
 * @see DrawTriangleLines()
 */
void umkaDrawTriangleLines(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2* v1 = (Vector2*)&params[3];
    Vector2* v2 = (Vector2*)&params[2];
    Vector2* v3 = (Vector2*)&params[1];
    Color* color = (Color*)&params[0];
    DrawTriangleLines(*v1, *v2, *v3, *color);
}

/**
 * Umka bindings for DrawTriangleFan.
 *
 * @see DrawTriangleFan()
 */
void umkaDrawTriangleFan(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2 * points = (Vector2 *)params[2].ptrVal;
    int pointCount = params[1].intVal;
    Color* color = (Color*)&params[0];
    DrawTriangleFan(points, pointCount, *color);
}

/**
 * Umka bindings for DrawTriangleStrip.
 *
 * @see DrawTriangleStrip()
 */
void umkaDrawTriangleStrip(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2 * points = (Vector2 *)params[2].ptrVal;
    int pointCount = params[1].intVal;
    Color* color = (Color*)&params[0];
    DrawTriangleStrip(points, pointCount, *color);
}

/**
 * Umka bindings for DrawPoly.
 *
 * @see DrawPoly()
 */
void umkaDrawPoly(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2* center = (Vector2*)&params[4];
    int sides = params[3].intVal;
    float radius = params[2].real32Val;
    float rotation = params[1].real32Val;
    Color* color = (Color*)&params[0];
    DrawPoly(*center, sides, radius, rotation, *color);
}

/**
 * Umka bindings for DrawPolyLines.
 *
 * @see DrawPolyLines()
 */
void umkaDrawPolyLines(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2* center = (Vector2*)&params[4];
    int sides = params[3].intVal;
    float radius = params[2].real32Val;
    float rotation = params[1].real32Val;
    Color* color = (Color*)&params[0];
    DrawPolyLines(*center, sides, radius, rotation, *color);
}

/**
 * Umka bindings for DrawPolyLinesEx.
 *
 * @see DrawPolyLinesEx()
 */
void umkaDrawPolyLinesEx(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2* center = (Vector2*)&params[5];
    int sides = params[4].intVal;
    float radius = params[3].real32Val;
    float rotation = params[2].real32Val;
    float lineThick = params[1].real32Val;
    Color* color = (Color*)&params[0];
    DrawPolyLinesEx(*center, sides, radius, rotation, lineThick, *color);
}

/**
 * Umka bindings for CheckCollisionRecs.
 *
 * @see CheckCollisionRecs()
 */
void umkaCheckCollisionRecs(UmkaStackSlot *params, UmkaStackSlot *result) {
    Rectangle* rec1 = (Rectangle*)&params[1];
    Rectangle* rec2 = (Rectangle*)&params[0];
    result->intVal = (int)CheckCollisionRecs(*rec1, *rec2);
}

/**
 * Umka bindings for CheckCollisionCircles.
 *
 * @see CheckCollisionCircles()
 */
void umkaCheckCollisionCircles(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2* center1 = (Vector2*)&params[3];
    float radius1 = params[2].real32Val;
    Vector2* center2 = (Vector2*)&params[1];
    float radius2 = params[0].real32Val;
    result->intVal = (int)CheckCollisionCircles(*center1, radius1, *center2, radius2);
}

/**
 * Umka bindings for CheckCollisionCircleRec.
 *
 * @see CheckCollisionCircleRec()
 */
void umkaCheckCollisionCircleRec(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2* center = (Vector2*)&params[2];
    float radius = params[1].real32Val;
    Rectangle* rec = (Rectangle*)&params[0];
    result->intVal = (int)CheckCollisionCircleRec(*center, radius, *rec);
}

/**
 * Umka bindings for CheckCollisionPointRec.
 *
 * @see CheckCollisionPointRec()
 */
void umkaCheckCollisionPointRec(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2* point = (Vector2*)&params[1];
    Rectangle* rec = (Rectangle*)&params[0];
    result->intVal = (int)CheckCollisionPointRec(*point, *rec);
}

/**
 * Umka bindings for CheckCollisionPointCircle.
 *
 * @see CheckCollisionPointCircle()
 */
void umkaCheckCollisionPointCircle(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2* point = (Vector2*)&params[2];
    Vector2* center = (Vector2*)&params[1];
    float radius = params[0].real32Val;
    result->intVal = (int)CheckCollisionPointCircle(*point, *center, radius);
}

/**
 * Umka bindings for CheckCollisionPointTriangle.
 *
 * @see CheckCollisionPointTriangle()
 */
void umkaCheckCollisionPointTriangle(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2* point = (Vector2*)&params[3];
    Vector2* p1 = (Vector2*)&params[2];
    Vector2* p2 = (Vector2*)&params[1];
    Vector2* p3 = (Vector2*)&params[0];
    result->intVal = (int)CheckCollisionPointTriangle(*point, *p1, *p2, *p3);
}

/**
 * Umka bindings for CheckCollisionLines.
 *
 * @see CheckCollisionLines()
 */
void umkaCheckCollisionLines(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2* startPos1 = (Vector2*)&params[4];
    Vector2* endPos1 = (Vector2*)&params[3];
    Vector2* startPos2 = (Vector2*)&params[2];
    Vector2* endPos2 = (Vector2*)&params[1];
    Vector2 * collisionPoint = (Vector2 *)params[0].ptrVal;
    result->intVal = (int)CheckCollisionLines(*startPos1, *endPos1, *startPos2, *endPos2, collisionPoint);
}

/**
 * Umka bindings for CheckCollisionPointLine.
 *
 * @see CheckCollisionPointLine()
 */
void umkaCheckCollisionPointLine(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2* point = (Vector2*)&params[3];
    Vector2* p1 = (Vector2*)&params[2];
    Vector2* p2 = (Vector2*)&params[1];
    int threshold = params[0].intVal;
    result->intVal = (int)CheckCollisionPointLine(*point, *p1, *p2, threshold);
}

/**
 * Umka bindings for GetCollisionRec.
 *
 * @see GetCollisionRec()
 */
void umkaGetCollisionRec(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Rectangle* rec1 = (Rectangle*)&params[2];
    Rectangle* rec2 = (Rectangle*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Rectangle), NULL);
    Rectangle out = GetCollisionRec(*rec1, *rec2);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Rectangle));
}

/**
 * Umka bindings for LoadImage.
 *
 * @see LoadImage()
 */
void umkaLoadImage(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    const char * fileName = (const char *)params[1].ptrVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Image), NULL);
    Image out = LoadImage(fileName);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Image));
}

/**
 * Umka bindings for LoadImageRaw.
 *
 * @see LoadImageRaw()
 */
void umkaLoadImageRaw(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    const char * fileName = (const char *)params[5].ptrVal;
    int width = params[4].intVal;
    int height = params[3].intVal;
    int format = params[2].intVal;
    int headerSize = params[1].intVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Image), NULL);
    Image out = LoadImageRaw(fileName, width, height, format, headerSize);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Image));
}

/**
 * Umka bindings for LoadImageAnim.
 *
 * @see LoadImageAnim()
 */
void umkaLoadImageAnim(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    const char * fileName = (const char *)params[2].ptrVal;
    int * frames = (int *)params[1].ptrVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Image), NULL);
    Image out = LoadImageAnim(fileName, frames);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Image));
}

/**
 * Umka bindings for LoadImageFromMemory.
 *
 * @see LoadImageFromMemory()
 */
void umkaLoadImageFromMemory(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    const char * fileType = (const char *)params[3].ptrVal;
    const unsigned char * fileData = (const unsigned char *)params[2].ptrVal;
    int dataSize = params[1].intVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Image), NULL);
    Image out = LoadImageFromMemory(fileType, fileData, dataSize);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Image));
}

/**
 * Umka bindings for LoadImageFromTexture.
 *
 * @see LoadImageFromTexture()
 */
void umkaLoadImageFromTexture(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Texture2D* texture = (Texture2D*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Image), NULL);
    Image out = LoadImageFromTexture(*texture);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Image));
}

/**
 * Umka bindings for LoadImageFromScreen.
 *
 * @see LoadImageFromScreen()
 */
void umkaLoadImageFromScreen(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Image), NULL);
    Image out = LoadImageFromScreen();
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Image));
}

/**
 * Umka bindings for UnloadImage.
 *
 * @see UnloadImage()
 */
void umkaUnloadImage(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image* image = (Image*)&params[0];
    UnloadImage(*image);
}

/**
 * Umka bindings for ExportImage.
 *
 * @see ExportImage()
 */
void umkaExportImage(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image* image = (Image*)&params[1];
    const char * fileName = (const char *)params[0].ptrVal;
    result->intVal = (int)ExportImage(*image, fileName);
}

/**
 * Umka bindings for ExportImageAsCode.
 *
 * @see ExportImageAsCode()
 */
void umkaExportImageAsCode(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image* image = (Image*)&params[1];
    const char * fileName = (const char *)params[0].ptrVal;
    result->intVal = (int)ExportImageAsCode(*image, fileName);
}

/**
 * Umka bindings for GenImageColor.
 *
 * @see GenImageColor()
 */
void umkaGenImageColor(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    int width = params[3].intVal;
    int height = params[2].intVal;
    Color* color = (Color*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Image), NULL);
    Image out = GenImageColor(width, height, *color);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Image));
}

/**
 * Umka bindings for GenImageGradientV.
 *
 * @see GenImageGradientV()
 */
void umkaGenImageGradientV(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    int width = params[4].intVal;
    int height = params[3].intVal;
    Color* top = (Color*)&params[2];
    Color* bottom = (Color*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Image), NULL);
    Image out = GenImageGradientV(width, height, *top, *bottom);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Image));
}

/**
 * Umka bindings for GenImageGradientH.
 *
 * @see GenImageGradientH()
 */
void umkaGenImageGradientH(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    int width = params[4].intVal;
    int height = params[3].intVal;
    Color* left = (Color*)&params[2];
    Color* right = (Color*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Image), NULL);
    Image out = GenImageGradientH(width, height, *left, *right);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Image));
}

/**
 * Umka bindings for GenImageGradientRadial.
 *
 * @see GenImageGradientRadial()
 */
void umkaGenImageGradientRadial(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    int width = params[5].intVal;
    int height = params[4].intVal;
    float density = params[3].real32Val;
    Color* inner = (Color*)&params[2];
    Color* outer = (Color*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Image), NULL);
    Image out = GenImageGradientRadial(width, height, density, *inner, *outer);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Image));
}

/**
 * Umka bindings for GenImageChecked.
 *
 * @see GenImageChecked()
 */
void umkaGenImageChecked(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    int width = params[6].intVal;
    int height = params[5].intVal;
    int checksX = params[4].intVal;
    int checksY = params[3].intVal;
    Color* col1 = (Color*)&params[2];
    Color* col2 = (Color*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Image), NULL);
    Image out = GenImageChecked(width, height, checksX, checksY, *col1, *col2);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Image));
}

/**
 * Umka bindings for GenImageWhiteNoise.
 *
 * @see GenImageWhiteNoise()
 */
void umkaGenImageWhiteNoise(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    int width = params[3].intVal;
    int height = params[2].intVal;
    float factor = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Image), NULL);
    Image out = GenImageWhiteNoise(width, height, factor);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Image));
}

/**
 * Umka bindings for GenImageCellular.
 *
 * @see GenImageCellular()
 */
void umkaGenImageCellular(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    int width = params[3].intVal;
    int height = params[2].intVal;
    int tileSize = params[1].intVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Image), NULL);
    Image out = GenImageCellular(width, height, tileSize);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Image));
}

/**
 * Umka bindings for ImageCopy.
 *
 * @see ImageCopy()
 */
void umkaImageCopy(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Image* image = (Image*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Image), NULL);
    Image out = ImageCopy(*image);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Image));
}

/**
 * Umka bindings for ImageFromImage.
 *
 * @see ImageFromImage()
 */
void umkaImageFromImage(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Image* image = (Image*)&params[2];
    Rectangle* rec = (Rectangle*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Image), NULL);
    Image out = ImageFromImage(*image, *rec);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Image));
}

/**
 * Umka bindings for ImageText.
 *
 * @see ImageText()
 */
void umkaImageText(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    const char * text = (const char *)params[3].ptrVal;
    int fontSize = params[2].intVal;
    Color* color = (Color*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Image), NULL);
    Image out = ImageText(text, fontSize, *color);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Image));
}

/**
 * Umka bindings for ImageTextEx.
 *
 * @see ImageTextEx()
 */
void umkaImageTextEx(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Font* font = (Font*)&params[5];
    const char * text = (const char *)params[4].ptrVal;
    float fontSize = params[3].real32Val;
    float spacing = params[2].real32Val;
    Color* tint = (Color*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Image), NULL);
    Image out = ImageTextEx(*font, text, fontSize, spacing, *tint);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Image));
}

/**
 * Umka bindings for ImageFormat.
 *
 * @see ImageFormat()
 */
void umkaImageFormat(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * image = (Image *)params[1].ptrVal;
    int newFormat = params[0].intVal;
    ImageFormat(image, newFormat);
}

/**
 * Umka bindings for ImageToPOT.
 *
 * @see ImageToPOT()
 */
void umkaImageToPOT(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * image = (Image *)params[1].ptrVal;
    Color* fill = (Color*)&params[0];
    ImageToPOT(image, *fill);
}

/**
 * Umka bindings for ImageCrop.
 *
 * @see ImageCrop()
 */
void umkaImageCrop(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * image = (Image *)params[1].ptrVal;
    Rectangle* crop = (Rectangle*)&params[0];
    ImageCrop(image, *crop);
}

/**
 * Umka bindings for ImageAlphaCrop.
 *
 * @see ImageAlphaCrop()
 */
void umkaImageAlphaCrop(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * image = (Image *)params[1].ptrVal;
    float threshold = params[0].real32Val;
    ImageAlphaCrop(image, threshold);
}

/**
 * Umka bindings for ImageAlphaClear.
 *
 * @see ImageAlphaClear()
 */
void umkaImageAlphaClear(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * image = (Image *)params[2].ptrVal;
    Color* color = (Color*)&params[1];
    float threshold = params[0].real32Val;
    ImageAlphaClear(image, *color, threshold);
}

/**
 * Umka bindings for ImageAlphaMask.
 *
 * @see ImageAlphaMask()
 */
void umkaImageAlphaMask(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * image = (Image *)params[1].ptrVal;
    Image* alphaMask = (Image*)&params[0];
    ImageAlphaMask(image, *alphaMask);
}

/**
 * Umka bindings for ImageAlphaPremultiply.
 *
 * @see ImageAlphaPremultiply()
 */
void umkaImageAlphaPremultiply(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * image = (Image *)params[0].ptrVal;
    ImageAlphaPremultiply(image);
}

/**
 * Umka bindings for ImageResize.
 *
 * @see ImageResize()
 */
void umkaImageResize(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * image = (Image *)params[2].ptrVal;
    int newWidth = params[1].intVal;
    int newHeight = params[0].intVal;
    ImageResize(image, newWidth, newHeight);
}

/**
 * Umka bindings for ImageResizeNN.
 *
 * @see ImageResizeNN()
 */
void umkaImageResizeNN(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * image = (Image *)params[2].ptrVal;
    int newWidth = params[1].intVal;
    int newHeight = params[0].intVal;
    ImageResizeNN(image, newWidth, newHeight);
}

/**
 * Umka bindings for ImageResizeCanvas.
 *
 * @see ImageResizeCanvas()
 */
void umkaImageResizeCanvas(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * image = (Image *)params[5].ptrVal;
    int newWidth = params[4].intVal;
    int newHeight = params[3].intVal;
    int offsetX = params[2].intVal;
    int offsetY = params[1].intVal;
    Color* fill = (Color*)&params[0];
    ImageResizeCanvas(image, newWidth, newHeight, offsetX, offsetY, *fill);
}

/**
 * Umka bindings for ImageMipmaps.
 *
 * @see ImageMipmaps()
 */
void umkaImageMipmaps(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * image = (Image *)params[0].ptrVal;
    ImageMipmaps(image);
}

/**
 * Umka bindings for ImageDither.
 *
 * @see ImageDither()
 */
void umkaImageDither(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * image = (Image *)params[4].ptrVal;
    int rBpp = params[3].intVal;
    int gBpp = params[2].intVal;
    int bBpp = params[1].intVal;
    int aBpp = params[0].intVal;
    ImageDither(image, rBpp, gBpp, bBpp, aBpp);
}

/**
 * Umka bindings for ImageFlipVertical.
 *
 * @see ImageFlipVertical()
 */
void umkaImageFlipVertical(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * image = (Image *)params[0].ptrVal;
    ImageFlipVertical(image);
}

/**
 * Umka bindings for ImageFlipHorizontal.
 *
 * @see ImageFlipHorizontal()
 */
void umkaImageFlipHorizontal(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * image = (Image *)params[0].ptrVal;
    ImageFlipHorizontal(image);
}

/**
 * Umka bindings for ImageRotateCW.
 *
 * @see ImageRotateCW()
 */
void umkaImageRotateCW(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * image = (Image *)params[0].ptrVal;
    ImageRotateCW(image);
}

/**
 * Umka bindings for ImageRotateCCW.
 *
 * @see ImageRotateCCW()
 */
void umkaImageRotateCCW(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * image = (Image *)params[0].ptrVal;
    ImageRotateCCW(image);
}

/**
 * Umka bindings for ImageColorTint.
 *
 * @see ImageColorTint()
 */
void umkaImageColorTint(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * image = (Image *)params[1].ptrVal;
    Color* color = (Color*)&params[0];
    ImageColorTint(image, *color);
}

/**
 * Umka bindings for ImageColorInvert.
 *
 * @see ImageColorInvert()
 */
void umkaImageColorInvert(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * image = (Image *)params[0].ptrVal;
    ImageColorInvert(image);
}

/**
 * Umka bindings for ImageColorGrayscale.
 *
 * @see ImageColorGrayscale()
 */
void umkaImageColorGrayscale(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * image = (Image *)params[0].ptrVal;
    ImageColorGrayscale(image);
}

/**
 * Umka bindings for ImageColorContrast.
 *
 * @see ImageColorContrast()
 */
void umkaImageColorContrast(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * image = (Image *)params[1].ptrVal;
    float contrast = params[0].real32Val;
    ImageColorContrast(image, contrast);
}

/**
 * Umka bindings for ImageColorBrightness.
 *
 * @see ImageColorBrightness()
 */
void umkaImageColorBrightness(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * image = (Image *)params[1].ptrVal;
    int brightness = params[0].intVal;
    ImageColorBrightness(image, brightness);
}

/**
 * Umka bindings for ImageColorReplace.
 *
 * @see ImageColorReplace()
 */
void umkaImageColorReplace(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * image = (Image *)params[2].ptrVal;
    Color* color = (Color*)&params[1];
    Color* replace = (Color*)&params[0];
    ImageColorReplace(image, *color, *replace);
}

/**
 * Umka bindings for LoadImageColors.
 *
 * @see LoadImageColors()
 */
void umkaLoadImageColors(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image* image = (Image*)&params[0];
    result->ptrVal = (void*)LoadImageColors(*image);
}

/**
 * Umka bindings for LoadImagePalette.
 *
 * @see LoadImagePalette()
 */
void umkaLoadImagePalette(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image* image = (Image*)&params[2];
    int maxPaletteSize = params[1].intVal;
    int * colorCount = (int *)params[0].ptrVal;
    result->ptrVal = (void*)LoadImagePalette(*image, maxPaletteSize, colorCount);
}

/**
 * Umka bindings for UnloadImageColors.
 *
 * @see UnloadImageColors()
 */
void umkaUnloadImageColors(UmkaStackSlot *params, UmkaStackSlot *result) {
    Color * colors = (Color *)params[0].ptrVal;
    UnloadImageColors(colors);
}

/**
 * Umka bindings for UnloadImagePalette.
 *
 * @see UnloadImagePalette()
 */
void umkaUnloadImagePalette(UmkaStackSlot *params, UmkaStackSlot *result) {
    Color * colors = (Color *)params[0].ptrVal;
    UnloadImagePalette(colors);
}

/**
 * Umka bindings for GetImageAlphaBorder.
 *
 * @see GetImageAlphaBorder()
 */
void umkaGetImageAlphaBorder(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Image* image = (Image*)&params[2];
    float threshold = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Rectangle), NULL);
    Rectangle out = GetImageAlphaBorder(*image, threshold);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Rectangle));
}

/**
 * Umka bindings for GetImageColor.
 *
 * @see GetImageColor()
 */
void umkaGetImageColor(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Image* image = (Image*)&params[3];
    int x = params[2].intVal;
    int y = params[1].intVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Color), NULL);
    Color out = GetImageColor(*image, x, y);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Color));
}

/**
 * Umka bindings for ImageClearBackground.
 *
 * @see ImageClearBackground()
 */
void umkaImageClearBackground(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * dst = (Image *)params[1].ptrVal;
    Color* color = (Color*)&params[0];
    ImageClearBackground(dst, *color);
}

/**
 * Umka bindings for ImageDrawPixel.
 *
 * @see ImageDrawPixel()
 */
void umkaImageDrawPixel(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * dst = (Image *)params[3].ptrVal;
    int posX = params[2].intVal;
    int posY = params[1].intVal;
    Color* color = (Color*)&params[0];
    ImageDrawPixel(dst, posX, posY, *color);
}

/**
 * Umka bindings for ImageDrawPixelV.
 *
 * @see ImageDrawPixelV()
 */
void umkaImageDrawPixelV(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * dst = (Image *)params[2].ptrVal;
    Vector2* position = (Vector2*)&params[1];
    Color* color = (Color*)&params[0];
    ImageDrawPixelV(dst, *position, *color);
}

/**
 * Umka bindings for ImageDrawLine.
 *
 * @see ImageDrawLine()
 */
void umkaImageDrawLine(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * dst = (Image *)params[5].ptrVal;
    int startPosX = params[4].intVal;
    int startPosY = params[3].intVal;
    int endPosX = params[2].intVal;
    int endPosY = params[1].intVal;
    Color* color = (Color*)&params[0];
    ImageDrawLine(dst, startPosX, startPosY, endPosX, endPosY, *color);
}

/**
 * Umka bindings for ImageDrawLineV.
 *
 * @see ImageDrawLineV()
 */
void umkaImageDrawLineV(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * dst = (Image *)params[3].ptrVal;
    Vector2* start = (Vector2*)&params[2];
    Vector2* end = (Vector2*)&params[1];
    Color* color = (Color*)&params[0];
    ImageDrawLineV(dst, *start, *end, *color);
}

/**
 * Umka bindings for ImageDrawCircle.
 *
 * @see ImageDrawCircle()
 */
void umkaImageDrawCircle(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * dst = (Image *)params[4].ptrVal;
    int centerX = params[3].intVal;
    int centerY = params[2].intVal;
    int radius = params[1].intVal;
    Color* color = (Color*)&params[0];
    ImageDrawCircle(dst, centerX, centerY, radius, *color);
}

/**
 * Umka bindings for ImageDrawCircleV.
 *
 * @see ImageDrawCircleV()
 */
void umkaImageDrawCircleV(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * dst = (Image *)params[3].ptrVal;
    Vector2* center = (Vector2*)&params[2];
    int radius = params[1].intVal;
    Color* color = (Color*)&params[0];
    ImageDrawCircleV(dst, *center, radius, *color);
}

/**
 * Umka bindings for ImageDrawRectangle.
 *
 * @see ImageDrawRectangle()
 */
void umkaImageDrawRectangle(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * dst = (Image *)params[5].ptrVal;
    int posX = params[4].intVal;
    int posY = params[3].intVal;
    int width = params[2].intVal;
    int height = params[1].intVal;
    Color* color = (Color*)&params[0];
    ImageDrawRectangle(dst, posX, posY, width, height, *color);
}

/**
 * Umka bindings for ImageDrawRectangleV.
 *
 * @see ImageDrawRectangleV()
 */
void umkaImageDrawRectangleV(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * dst = (Image *)params[3].ptrVal;
    Vector2* position = (Vector2*)&params[2];
    Vector2* size = (Vector2*)&params[1];
    Color* color = (Color*)&params[0];
    ImageDrawRectangleV(dst, *position, *size, *color);
}

/**
 * Umka bindings for ImageDrawRectangleRec.
 *
 * @see ImageDrawRectangleRec()
 */
void umkaImageDrawRectangleRec(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * dst = (Image *)params[2].ptrVal;
    Rectangle* rec = (Rectangle*)&params[1];
    Color* color = (Color*)&params[0];
    ImageDrawRectangleRec(dst, *rec, *color);
}

/**
 * Umka bindings for ImageDrawRectangleLines.
 *
 * @see ImageDrawRectangleLines()
 */
void umkaImageDrawRectangleLines(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * dst = (Image *)params[3].ptrVal;
    Rectangle* rec = (Rectangle*)&params[2];
    int thick = params[1].intVal;
    Color* color = (Color*)&params[0];
    ImageDrawRectangleLines(dst, *rec, thick, *color);
}

/**
 * Umka bindings for ImageDraw.
 *
 * @see ImageDraw()
 */
void umkaImageDraw(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * dst = (Image *)params[4].ptrVal;
    Image* src = (Image*)&params[3];
    Rectangle* srcRec = (Rectangle*)&params[2];
    Rectangle* dstRec = (Rectangle*)&params[1];
    Color* tint = (Color*)&params[0];
    ImageDraw(dst, *src, *srcRec, *dstRec, *tint);
}

/**
 * Umka bindings for ImageDrawText.
 *
 * @see ImageDrawText()
 */
void umkaImageDrawText(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * dst = (Image *)params[5].ptrVal;
    const char * text = (const char *)params[4].ptrVal;
    int posX = params[3].intVal;
    int posY = params[2].intVal;
    int fontSize = params[1].intVal;
    Color* color = (Color*)&params[0];
    ImageDrawText(dst, text, posX, posY, fontSize, *color);
}

/**
 * Umka bindings for ImageDrawTextEx.
 *
 * @see ImageDrawTextEx()
 */
void umkaImageDrawTextEx(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * dst = (Image *)params[6].ptrVal;
    Font* font = (Font*)&params[5];
    const char * text = (const char *)params[4].ptrVal;
    Vector2* position = (Vector2*)&params[3];
    float fontSize = params[2].real32Val;
    float spacing = params[1].real32Val;
    Color* tint = (Color*)&params[0];
    ImageDrawTextEx(dst, *font, text, *position, fontSize, spacing, *tint);
}

/**
 * Umka bindings for LoadTexture.
 *
 * @see LoadTexture()
 */
void umkaLoadTexture(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    const char * fileName = (const char *)params[1].ptrVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Texture2D), NULL);
    Texture2D out = LoadTexture(fileName);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Texture2D));
}

/**
 * Umka bindings for LoadTextureFromImage.
 *
 * @see LoadTextureFromImage()
 */
void umkaLoadTextureFromImage(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Image* image = (Image*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Texture2D), NULL);
    Texture2D out = LoadTextureFromImage(*image);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Texture2D));
}

/**
 * Umka bindings for LoadTextureCubemap.
 *
 * @see LoadTextureCubemap()
 */
void umkaLoadTextureCubemap(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Image* image = (Image*)&params[2];
    int layout = params[1].intVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(TextureCubemap), NULL);
    TextureCubemap out = LoadTextureCubemap(*image, layout);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(TextureCubemap));
}

/**
 * Umka bindings for LoadRenderTexture.
 *
 * @see LoadRenderTexture()
 */
void umkaLoadRenderTexture(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    int width = params[2].intVal;
    int height = params[1].intVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(RenderTexture2D), NULL);
    RenderTexture2D out = LoadRenderTexture(width, height);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(RenderTexture2D));
}

/**
 * Umka bindings for UnloadTexture.
 *
 * @see UnloadTexture()
 */
void umkaUnloadTexture(UmkaStackSlot *params, UmkaStackSlot *result) {
    Texture2D* texture = (Texture2D*)&params[0];
    UnloadTexture(*texture);
}

/**
 * Umka bindings for UnloadRenderTexture.
 *
 * @see UnloadRenderTexture()
 */
void umkaUnloadRenderTexture(UmkaStackSlot *params, UmkaStackSlot *result) {
    RenderTexture2D* target = (RenderTexture2D*)&params[0];
    UnloadRenderTexture(*target);
}

/**
 * Umka bindings for UpdateTexture.
 *
 * @see UpdateTexture()
 */
void umkaUpdateTexture(UmkaStackSlot *params, UmkaStackSlot *result) {
    Texture2D* texture = (Texture2D*)&params[1];
    const void * pixels = (const void *)params[0].ptrVal;
    UpdateTexture(*texture, pixels);
}

/**
 * Umka bindings for UpdateTextureRec.
 *
 * @see UpdateTextureRec()
 */
void umkaUpdateTextureRec(UmkaStackSlot *params, UmkaStackSlot *result) {
    Texture2D* texture = (Texture2D*)&params[2];
    Rectangle* rec = (Rectangle*)&params[1];
    const void * pixels = (const void *)params[0].ptrVal;
    UpdateTextureRec(*texture, *rec, pixels);
}

/**
 * Umka bindings for GenTextureMipmaps.
 *
 * @see GenTextureMipmaps()
 */
void umkaGenTextureMipmaps(UmkaStackSlot *params, UmkaStackSlot *result) {
    Texture2D * texture = (Texture2D *)params[0].ptrVal;
    GenTextureMipmaps(texture);
}

/**
 * Umka bindings for SetTextureFilter.
 *
 * @see SetTextureFilter()
 */
void umkaSetTextureFilter(UmkaStackSlot *params, UmkaStackSlot *result) {
    Texture2D* texture = (Texture2D*)&params[1];
    int filter = params[0].intVal;
    SetTextureFilter(*texture, filter);
}

/**
 * Umka bindings for SetTextureWrap.
 *
 * @see SetTextureWrap()
 */
void umkaSetTextureWrap(UmkaStackSlot *params, UmkaStackSlot *result) {
    Texture2D* texture = (Texture2D*)&params[1];
    int wrap = params[0].intVal;
    SetTextureWrap(*texture, wrap);
}

/**
 * Umka bindings for DrawTexture.
 *
 * @see DrawTexture()
 */
void umkaDrawTexture(UmkaStackSlot *params, UmkaStackSlot *result) {
    Texture2D* texture = (Texture2D*)&params[3];
    int posX = params[2].intVal;
    int posY = params[1].intVal;
    Color* tint = (Color*)&params[0];
    DrawTexture(*texture, posX, posY, *tint);
}

/**
 * Umka bindings for DrawTextureV.
 *
 * @see DrawTextureV()
 */
void umkaDrawTextureV(UmkaStackSlot *params, UmkaStackSlot *result) {
    Texture2D* texture = (Texture2D*)&params[2];
    Vector2* position = (Vector2*)&params[1];
    Color* tint = (Color*)&params[0];
    DrawTextureV(*texture, *position, *tint);
}

/**
 * Umka bindings for DrawTextureEx.
 *
 * @see DrawTextureEx()
 */
void umkaDrawTextureEx(UmkaStackSlot *params, UmkaStackSlot *result) {
    Texture2D* texture = (Texture2D*)&params[4];
    Vector2* position = (Vector2*)&params[3];
    float rotation = params[2].real32Val;
    float scale = params[1].real32Val;
    Color* tint = (Color*)&params[0];
    DrawTextureEx(*texture, *position, rotation, scale, *tint);
}

/**
 * Umka bindings for DrawTextureRec.
 *
 * @see DrawTextureRec()
 */
void umkaDrawTextureRec(UmkaStackSlot *params, UmkaStackSlot *result) {
    Texture2D* texture = (Texture2D*)&params[3];
    Rectangle* source = (Rectangle*)&params[2];
    Vector2* position = (Vector2*)&params[1];
    Color* tint = (Color*)&params[0];
    DrawTextureRec(*texture, *source, *position, *tint);
}

/**
 * Umka bindings for DrawTextureQuad.
 *
 * @see DrawTextureQuad()
 */
void umkaDrawTextureQuad(UmkaStackSlot *params, UmkaStackSlot *result) {
    Texture2D* texture = (Texture2D*)&params[4];
    Vector2* tiling = (Vector2*)&params[3];
    Vector2* offset = (Vector2*)&params[2];
    Rectangle* quad = (Rectangle*)&params[1];
    Color* tint = (Color*)&params[0];
    DrawTextureQuad(*texture, *tiling, *offset, *quad, *tint);
}

/**
 * Umka bindings for DrawTextureTiled.
 *
 * @see DrawTextureTiled()
 */
void umkaDrawTextureTiled(UmkaStackSlot *params, UmkaStackSlot *result) {
    Texture2D* texture = (Texture2D*)&params[6];
    Rectangle* source = (Rectangle*)&params[5];
    Rectangle* dest = (Rectangle*)&params[4];
    Vector2* origin = (Vector2*)&params[3];
    float rotation = params[2].real32Val;
    float scale = params[1].real32Val;
    Color* tint = (Color*)&params[0];
    DrawTextureTiled(*texture, *source, *dest, *origin, rotation, scale, *tint);
}

/**
 * Umka bindings for DrawTexturePro.
 *
 * @see DrawTexturePro()
 */
void umkaDrawTexturePro(UmkaStackSlot *params, UmkaStackSlot *result) {
    Texture2D* texture = (Texture2D*)&params[5];
    Rectangle* source = (Rectangle*)&params[4];
    Rectangle* dest = (Rectangle*)&params[3];
    Vector2* origin = (Vector2*)&params[2];
    float rotation = params[1].real32Val;
    Color* tint = (Color*)&params[0];
    DrawTexturePro(*texture, *source, *dest, *origin, rotation, *tint);
}

/**
 * Umka bindings for DrawTextureNPatch.
 *
 * @see DrawTextureNPatch()
 */
void umkaDrawTextureNPatch(UmkaStackSlot *params, UmkaStackSlot *result) {
    Texture2D* texture = (Texture2D*)&params[5];
    NPatchInfo* nPatchInfo = (NPatchInfo*)&params[4];
    Rectangle* dest = (Rectangle*)&params[3];
    Vector2* origin = (Vector2*)&params[2];
    float rotation = params[1].real32Val;
    Color* tint = (Color*)&params[0];
    DrawTextureNPatch(*texture, *nPatchInfo, *dest, *origin, rotation, *tint);
}

/**
 * Umka bindings for DrawTexturePoly.
 *
 * @see DrawTexturePoly()
 */
void umkaDrawTexturePoly(UmkaStackSlot *params, UmkaStackSlot *result) {
    Texture2D* texture = (Texture2D*)&params[5];
    Vector2* center = (Vector2*)&params[4];
    Vector2 * points = (Vector2 *)params[3].ptrVal;
    Vector2 * texcoords = (Vector2 *)params[2].ptrVal;
    int pointCount = params[1].intVal;
    Color* tint = (Color*)&params[0];
    DrawTexturePoly(*texture, *center, points, texcoords, pointCount, *tint);
}

/**
 * Umka bindings for Fade.
 *
 * @see Fade()
 */
void umkaFade(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Color* color = (Color*)&params[2];
    float alpha = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Color), NULL);
    Color out = Fade(*color, alpha);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Color));
}

/**
 * Umka bindings for ColorToInt.
 *
 * @see ColorToInt()
 */
void umkaColorToInt(UmkaStackSlot *params, UmkaStackSlot *result) {
    Color* color = (Color*)&params[0];
    result->intVal = ColorToInt(*color);
}

/**
 * Umka bindings for ColorNormalize.
 *
 * @see ColorNormalize()
 */
void umkaColorNormalize(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Color* color = (Color*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector4), NULL);
    Vector4 out = ColorNormalize(*color);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector4));
}

/**
 * Umka bindings for ColorFromNormalized.
 *
 * @see ColorFromNormalized()
 */
void umkaColorFromNormalized(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector4* normalized = (Vector4*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Color), NULL);
    Color out = ColorFromNormalized(*normalized);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Color));
}

/**
 * Umka bindings for ColorToHSV.
 *
 * @see ColorToHSV()
 */
void umkaColorToHSV(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Color* color = (Color*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector3), NULL);
    Vector3 out = ColorToHSV(*color);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector3));
}

/**
 * Umka bindings for ColorFromHSV.
 *
 * @see ColorFromHSV()
 */
void umkaColorFromHSV(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    float hue = params[3].real32Val;
    float saturation = params[2].real32Val;
    float value = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Color), NULL);
    Color out = ColorFromHSV(hue, saturation, value);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Color));
}

/**
 * Umka bindings for ColorAlpha.
 *
 * @see ColorAlpha()
 */
void umkaColorAlpha(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Color* color = (Color*)&params[2];
    float alpha = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Color), NULL);
    Color out = ColorAlpha(*color, alpha);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Color));
}

/**
 * Umka bindings for ColorAlphaBlend.
 *
 * @see ColorAlphaBlend()
 */
void umkaColorAlphaBlend(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Color* dst = (Color*)&params[3];
    Color* src = (Color*)&params[2];
    Color* tint = (Color*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Color), NULL);
    Color out = ColorAlphaBlend(*dst, *src, *tint);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Color));
}

/**
 * Umka bindings for GetColor.
 *
 * @see GetColor()
 */
void umkaGetColor(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    unsigned int hexValue = params[1].uintVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Color), NULL);
    Color out = GetColor(hexValue);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Color));
}

/**
 * Umka bindings for GetPixelColor.
 *
 * @see GetPixelColor()
 */
void umkaGetPixelColor(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    void * srcPtr = (void *)params[2].ptrVal;
    int format = params[1].intVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Color), NULL);
    Color out = GetPixelColor(srcPtr, format);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Color));
}

/**
 * Umka bindings for SetPixelColor.
 *
 * @see SetPixelColor()
 */
void umkaSetPixelColor(UmkaStackSlot *params, UmkaStackSlot *result) {
    void * dstPtr = (void *)params[2].ptrVal;
    Color* color = (Color*)&params[1];
    int format = params[0].intVal;
    SetPixelColor(dstPtr, *color, format);
}

/**
 * Umka bindings for GetPixelDataSize.
 *
 * @see GetPixelDataSize()
 */
void umkaGetPixelDataSize(UmkaStackSlot *params, UmkaStackSlot *result) {
    int width = params[2].intVal;
    int height = params[1].intVal;
    int format = params[0].intVal;
    result->intVal = GetPixelDataSize(width, height, format);
}

/**
 * Umka bindings for GetFontDefault.
 *
 * @see GetFontDefault()
 */
void umkaGetFontDefault(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Font), NULL);
    Font out = GetFontDefault();
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Font));
}

/**
 * Umka bindings for LoadFont.
 *
 * @see LoadFont()
 */
void umkaLoadFont(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    const char * fileName = (const char *)params[1].ptrVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Font), NULL);
    Font out = LoadFont(fileName);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Font));
}

/**
 * Umka bindings for LoadFontEx.
 *
 * @see LoadFontEx()
 */
void umkaLoadFontEx(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    const char * fileName = (const char *)params[4].ptrVal;
    int fontSize = params[3].intVal;
    int * fontChars = (int *)params[2].ptrVal;
    int glyphCount = params[1].intVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Font), NULL);
    Font out = LoadFontEx(fileName, fontSize, fontChars, glyphCount);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Font));
}

/**
 * Umka bindings for LoadFontFromImage.
 *
 * @see LoadFontFromImage()
 */
void umkaLoadFontFromImage(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Image* image = (Image*)&params[3];
    Color* key = (Color*)&params[2];
    int firstChar = params[1].intVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Font), NULL);
    Font out = LoadFontFromImage(*image, *key, firstChar);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Font));
}

/**
 * Umka bindings for LoadFontFromMemory.
 *
 * @see LoadFontFromMemory()
 */
void umkaLoadFontFromMemory(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    const char * fileType = (const char *)params[6].ptrVal;
    const unsigned char * fileData = (const unsigned char *)params[5].ptrVal;
    int dataSize = params[4].intVal;
    int fontSize = params[3].intVal;
    int * fontChars = (int *)params[2].ptrVal;
    int glyphCount = params[1].intVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Font), NULL);
    Font out = LoadFontFromMemory(fileType, fileData, dataSize, fontSize, fontChars, glyphCount);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Font));
}

// Function LoadFontData() skipped

/**
 * Umka bindings for GenImageFontAtlas.
 *
 * @see GenImageFontAtlas()
 */
void umkaGenImageFontAtlas(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    const GlyphInfo * chars = (const GlyphInfo *)params[6].ptrVal;
    Rectangle ** recs = (Rectangle **)params[5].ptrVal;
    int glyphCount = params[4].intVal;
    int fontSize = params[3].intVal;
    int padding = params[2].intVal;
    int packMethod = params[1].intVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Image), NULL);
    Image out = GenImageFontAtlas(chars, recs, glyphCount, fontSize, padding, packMethod);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Image));
}

/**
 * Umka bindings for UnloadFontData.
 *
 * @see UnloadFontData()
 */
void umkaUnloadFontData(UmkaStackSlot *params, UmkaStackSlot *result) {
    GlyphInfo * chars = (GlyphInfo *)params[1].ptrVal;
    int glyphCount = params[0].intVal;
    UnloadFontData(chars, glyphCount);
}

/**
 * Umka bindings for UnloadFont.
 *
 * @see UnloadFont()
 */
void umkaUnloadFont(UmkaStackSlot *params, UmkaStackSlot *result) {
    Font* font = (Font*)&params[0];
    UnloadFont(*font);
}

/**
 * Umka bindings for ExportFontAsCode.
 *
 * @see ExportFontAsCode()
 */
void umkaExportFontAsCode(UmkaStackSlot *params, UmkaStackSlot *result) {
    Font* font = (Font*)&params[1];
    const char * fileName = (const char *)params[0].ptrVal;
    result->intVal = (int)ExportFontAsCode(*font, fileName);
}

/**
 * Umka bindings for DrawFPS.
 *
 * @see DrawFPS()
 */
void umkaDrawFPS(UmkaStackSlot *params, UmkaStackSlot *result) {
    int posX = params[1].intVal;
    int posY = params[0].intVal;
    DrawFPS(posX, posY);
}

/**
 * Umka bindings for DrawText.
 *
 * @see DrawText()
 */
void umkaDrawText(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * text = (const char *)params[4].ptrVal;
    int posX = params[3].intVal;
    int posY = params[2].intVal;
    int fontSize = params[1].intVal;
    Color* color = (Color*)&params[0];
    DrawText(text, posX, posY, fontSize, *color);
}

/**
 * Umka bindings for DrawTextEx.
 *
 * @see DrawTextEx()
 */
void umkaDrawTextEx(UmkaStackSlot *params, UmkaStackSlot *result) {
    Font* font = (Font*)&params[5];
    const char * text = (const char *)params[4].ptrVal;
    Vector2* position = (Vector2*)&params[3];
    float fontSize = params[2].real32Val;
    float spacing = params[1].real32Val;
    Color* tint = (Color*)&params[0];
    DrawTextEx(*font, text, *position, fontSize, spacing, *tint);
}

/**
 * Umka bindings for DrawTextPro.
 *
 * @see DrawTextPro()
 */
void umkaDrawTextPro(UmkaStackSlot *params, UmkaStackSlot *result) {
    Font* font = (Font*)&params[7];
    const char * text = (const char *)params[6].ptrVal;
    Vector2* position = (Vector2*)&params[5];
    Vector2* origin = (Vector2*)&params[4];
    float rotation = params[3].real32Val;
    float fontSize = params[2].real32Val;
    float spacing = params[1].real32Val;
    Color* tint = (Color*)&params[0];
    DrawTextPro(*font, text, *position, *origin, rotation, fontSize, spacing, *tint);
}

/**
 * Umka bindings for DrawTextCodepoint.
 *
 * @see DrawTextCodepoint()
 */
void umkaDrawTextCodepoint(UmkaStackSlot *params, UmkaStackSlot *result) {
    Font* font = (Font*)&params[4];
    int codepoint = params[3].intVal;
    Vector2* position = (Vector2*)&params[2];
    float fontSize = params[1].real32Val;
    Color* tint = (Color*)&params[0];
    DrawTextCodepoint(*font, codepoint, *position, fontSize, *tint);
}

/**
 * Umka bindings for DrawTextCodepoints.
 *
 * @see DrawTextCodepoints()
 */
void umkaDrawTextCodepoints(UmkaStackSlot *params, UmkaStackSlot *result) {
    Font* font = (Font*)&params[6];
    const int * codepoints = (const int *)params[5].ptrVal;
    int count = params[4].intVal;
    Vector2* position = (Vector2*)&params[3];
    float fontSize = params[2].real32Val;
    float spacing = params[1].real32Val;
    Color* tint = (Color*)&params[0];
    DrawTextCodepoints(*font, codepoints, count, *position, fontSize, spacing, *tint);
}

/**
 * Umka bindings for MeasureText.
 *
 * @see MeasureText()
 */
void umkaMeasureText(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * text = (const char *)params[1].ptrVal;
    int fontSize = params[0].intVal;
    result->intVal = MeasureText(text, fontSize);
}

/**
 * Umka bindings for MeasureTextEx.
 *
 * @see MeasureTextEx()
 */
void umkaMeasureTextEx(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Font* font = (Font*)&params[4];
    const char * text = (const char *)params[3].ptrVal;
    float fontSize = params[2].real32Val;
    float spacing = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector2), NULL);
    Vector2 out = MeasureTextEx(*font, text, fontSize, spacing);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector2));
}

/**
 * Umka bindings for GetGlyphIndex.
 *
 * @see GetGlyphIndex()
 */
void umkaGetGlyphIndex(UmkaStackSlot *params, UmkaStackSlot *result) {
    Font* font = (Font*)&params[1];
    int codepoint = params[0].intVal;
    result->intVal = GetGlyphIndex(*font, codepoint);
}

/**
 * Umka bindings for GetGlyphInfo.
 *
 * @see GetGlyphInfo()
 */
void umkaGetGlyphInfo(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Font* font = (Font*)&params[2];
    int codepoint = params[1].intVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(GlyphInfo), NULL);
    GlyphInfo out = GetGlyphInfo(*font, codepoint);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(GlyphInfo));
}

/**
 * Umka bindings for GetGlyphAtlasRec.
 *
 * @see GetGlyphAtlasRec()
 */
void umkaGetGlyphAtlasRec(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Font* font = (Font*)&params[2];
    int codepoint = params[1].intVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Rectangle), NULL);
    Rectangle out = GetGlyphAtlasRec(*font, codepoint);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Rectangle));
}

/**
 * Umka bindings for LoadCodepoints.
 *
 * @see LoadCodepoints()
 */
void umkaLoadCodepoints(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * text = (const char *)params[1].ptrVal;
    int * count = (int *)params[0].ptrVal;
    result->ptrVal = (void*)LoadCodepoints(text, count);
}

/**
 * Umka bindings for UnloadCodepoints.
 *
 * @see UnloadCodepoints()
 */
void umkaUnloadCodepoints(UmkaStackSlot *params, UmkaStackSlot *result) {
    int * codepoints = (int *)params[0].ptrVal;
    UnloadCodepoints(codepoints);
}

/**
 * Umka bindings for GetCodepointCount.
 *
 * @see GetCodepointCount()
 */
void umkaGetCodepointCount(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * text = (const char *)params[0].ptrVal;
    result->intVal = GetCodepointCount(text);
}

/**
 * Umka bindings for GetCodepoint.
 *
 * @see GetCodepoint()
 */
void umkaGetCodepoint(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * text = (const char *)params[1].ptrVal;
    int * bytesProcessed = (int *)params[0].ptrVal;
    result->intVal = GetCodepoint(text, bytesProcessed);
}

/**
 * Umka bindings for CodepointToUTF8.
 *
 * @see CodepointToUTF8()
 */
void umkaCodepointToUTF8(UmkaStackSlot *params, UmkaStackSlot *result) {
    int codepoint = params[1].intVal;
    int * byteSize = (int *)params[0].ptrVal;
    result->ptrVal = (void*)CodepointToUTF8(codepoint, byteSize);
}

/**
 * Umka bindings for TextCodepointsToUTF8.
 *
 * @see TextCodepointsToUTF8()
 */
void umkaTextCodepointsToUTF8(UmkaStackSlot *params, UmkaStackSlot *result) {
    const int * codepoints = (const int *)params[1].ptrVal;
    int length = params[0].intVal;
    result->ptrVal = (void*)TextCodepointsToUTF8(codepoints, length);
}

/**
 * Umka bindings for TextCopy.
 *
 * @see TextCopy()
 */
void umkaTextCopy(UmkaStackSlot *params, UmkaStackSlot *result) {
    char * dst = (char *)params[1].ptrVal;
    const char * src = (const char *)params[0].ptrVal;
    result->intVal = TextCopy(dst, src);
}

/**
 * Umka bindings for TextIsEqual.
 *
 * @see TextIsEqual()
 */
void umkaTextIsEqual(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * text1 = (const char *)params[1].ptrVal;
    const char * text2 = (const char *)params[0].ptrVal;
    result->intVal = (int)TextIsEqual(text1, text2);
}

/**
 * Umka bindings for TextLength.
 *
 * @see TextLength()
 */
void umkaTextLength(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * text = (const char *)params[0].ptrVal;
    result->uintVal = TextLength(text);
}

// Function TextFormat() skipped

/**
 * Umka bindings for TextSubtext.
 *
 * @see TextSubtext()
 */
void umkaTextSubtext(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * text = (const char *)params[2].ptrVal;
    int position = params[1].intVal;
    int length = params[0].intVal;
    result->ptrVal = (void*)TextSubtext(text, position, length);
}

/**
 * Umka bindings for TextReplace.
 *
 * @see TextReplace()
 */
void umkaTextReplace(UmkaStackSlot *params, UmkaStackSlot *result) {
    char * text = (char *)params[2].ptrVal;
    const char * replace = (const char *)params[1].ptrVal;
    const char * by = (const char *)params[0].ptrVal;
    result->ptrVal = (void*)TextReplace(text, replace, by);
}

/**
 * Umka bindings for TextInsert.
 *
 * @see TextInsert()
 */
void umkaTextInsert(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * text = (const char *)params[2].ptrVal;
    const char * insert = (const char *)params[1].ptrVal;
    int position = params[0].intVal;
    result->ptrVal = (void*)TextInsert(text, insert, position);
}

/**
 * Umka bindings for TextJoin.
 *
 * @see TextJoin()
 */
void umkaTextJoin(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char ** textList = (const char **)params[2].ptrVal;
    int count = params[1].intVal;
    const char * delimiter = (const char *)params[0].ptrVal;
    result->ptrVal = (void*)TextJoin(textList, count, delimiter);
}

/**
 * Umka bindings for TextSplit.
 *
 * @see TextSplit()
 */
void umkaTextSplit(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * text = (const char *)params[2].ptrVal;
    char delimiter = params[1].uintVal;
    int * count = (int *)params[0].ptrVal;
    result->ptrVal = (void*)TextSplit(text, delimiter, count);
}

/**
 * Umka bindings for TextAppend.
 *
 * @see TextAppend()
 */
void umkaTextAppend(UmkaStackSlot *params, UmkaStackSlot *result) {
    char * text = (char *)params[2].ptrVal;
    const char * append = (const char *)params[1].ptrVal;
    int * position = (int *)params[0].ptrVal;
    TextAppend(text, append, position);
}

/**
 * Umka bindings for TextFindIndex.
 *
 * @see TextFindIndex()
 */
void umkaTextFindIndex(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * text = (const char *)params[1].ptrVal;
    const char * find = (const char *)params[0].ptrVal;
    result->intVal = TextFindIndex(text, find);
}

/**
 * Umka bindings for TextToUpper.
 *
 * @see TextToUpper()
 */
void umkaTextToUpper(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * text = (const char *)params[0].ptrVal;
    result->ptrVal = (void*)TextToUpper(text);
}

/**
 * Umka bindings for TextToLower.
 *
 * @see TextToLower()
 */
void umkaTextToLower(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * text = (const char *)params[0].ptrVal;
    result->ptrVal = (void*)TextToLower(text);
}

/**
 * Umka bindings for TextToPascal.
 *
 * @see TextToPascal()
 */
void umkaTextToPascal(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * text = (const char *)params[0].ptrVal;
    result->ptrVal = (void*)TextToPascal(text);
}

/**
 * Umka bindings for TextToInteger.
 *
 * @see TextToInteger()
 */
void umkaTextToInteger(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * text = (const char *)params[0].ptrVal;
    result->intVal = TextToInteger(text);
}

/**
 * Umka bindings for DrawLine3D.
 *
 * @see DrawLine3D()
 */
void umkaDrawLine3D(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector3* startPos = (Vector3*)&params[2];
    Vector3* endPos = (Vector3*)&params[1];
    Color* color = (Color*)&params[0];
    DrawLine3D(*startPos, *endPos, *color);
}

/**
 * Umka bindings for DrawPoint3D.
 *
 * @see DrawPoint3D()
 */
void umkaDrawPoint3D(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector3* position = (Vector3*)&params[1];
    Color* color = (Color*)&params[0];
    DrawPoint3D(*position, *color);
}

/**
 * Umka bindings for DrawCircle3D.
 *
 * @see DrawCircle3D()
 */
void umkaDrawCircle3D(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector3* center = (Vector3*)&params[4];
    float radius = params[3].real32Val;
    Vector3* rotationAxis = (Vector3*)&params[2];
    float rotationAngle = params[1].real32Val;
    Color* color = (Color*)&params[0];
    DrawCircle3D(*center, radius, *rotationAxis, rotationAngle, *color);
}

/**
 * Umka bindings for DrawTriangle3D.
 *
 * @see DrawTriangle3D()
 */
void umkaDrawTriangle3D(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector3* v1 = (Vector3*)&params[3];
    Vector3* v2 = (Vector3*)&params[2];
    Vector3* v3 = (Vector3*)&params[1];
    Color* color = (Color*)&params[0];
    DrawTriangle3D(*v1, *v2, *v3, *color);
}

/**
 * Umka bindings for DrawTriangleStrip3D.
 *
 * @see DrawTriangleStrip3D()
 */
void umkaDrawTriangleStrip3D(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector3 * points = (Vector3 *)params[2].ptrVal;
    int pointCount = params[1].intVal;
    Color* color = (Color*)&params[0];
    DrawTriangleStrip3D(points, pointCount, *color);
}

/**
 * Umka bindings for DrawCube.
 *
 * @see DrawCube()
 */
void umkaDrawCube(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector3* position = (Vector3*)&params[4];
    float width = params[3].real32Val;
    float height = params[2].real32Val;
    float length = params[1].real32Val;
    Color* color = (Color*)&params[0];
    DrawCube(*position, width, height, length, *color);
}

/**
 * Umka bindings for DrawCubeV.
 *
 * @see DrawCubeV()
 */
void umkaDrawCubeV(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector3* position = (Vector3*)&params[2];
    Vector3* size = (Vector3*)&params[1];
    Color* color = (Color*)&params[0];
    DrawCubeV(*position, *size, *color);
}

/**
 * Umka bindings for DrawCubeWires.
 *
 * @see DrawCubeWires()
 */
void umkaDrawCubeWires(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector3* position = (Vector3*)&params[4];
    float width = params[3].real32Val;
    float height = params[2].real32Val;
    float length = params[1].real32Val;
    Color* color = (Color*)&params[0];
    DrawCubeWires(*position, width, height, length, *color);
}

/**
 * Umka bindings for DrawCubeWiresV.
 *
 * @see DrawCubeWiresV()
 */
void umkaDrawCubeWiresV(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector3* position = (Vector3*)&params[2];
    Vector3* size = (Vector3*)&params[1];
    Color* color = (Color*)&params[0];
    DrawCubeWiresV(*position, *size, *color);
}

/**
 * Umka bindings for DrawCubeTexture.
 *
 * @see DrawCubeTexture()
 */
void umkaDrawCubeTexture(UmkaStackSlot *params, UmkaStackSlot *result) {
    Texture2D* texture = (Texture2D*)&params[5];
    Vector3* position = (Vector3*)&params[4];
    float width = params[3].real32Val;
    float height = params[2].real32Val;
    float length = params[1].real32Val;
    Color* color = (Color*)&params[0];
    DrawCubeTexture(*texture, *position, width, height, length, *color);
}

/**
 * Umka bindings for DrawCubeTextureRec.
 *
 * @see DrawCubeTextureRec()
 */
void umkaDrawCubeTextureRec(UmkaStackSlot *params, UmkaStackSlot *result) {
    Texture2D* texture = (Texture2D*)&params[6];
    Rectangle* source = (Rectangle*)&params[5];
    Vector3* position = (Vector3*)&params[4];
    float width = params[3].real32Val;
    float height = params[2].real32Val;
    float length = params[1].real32Val;
    Color* color = (Color*)&params[0];
    DrawCubeTextureRec(*texture, *source, *position, width, height, length, *color);
}

/**
 * Umka bindings for DrawSphere.
 *
 * @see DrawSphere()
 */
void umkaDrawSphere(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector3* centerPos = (Vector3*)&params[2];
    float radius = params[1].real32Val;
    Color* color = (Color*)&params[0];
    DrawSphere(*centerPos, radius, *color);
}

/**
 * Umka bindings for DrawSphereEx.
 *
 * @see DrawSphereEx()
 */
void umkaDrawSphereEx(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector3* centerPos = (Vector3*)&params[4];
    float radius = params[3].real32Val;
    int rings = params[2].intVal;
    int slices = params[1].intVal;
    Color* color = (Color*)&params[0];
    DrawSphereEx(*centerPos, radius, rings, slices, *color);
}

/**
 * Umka bindings for DrawSphereWires.
 *
 * @see DrawSphereWires()
 */
void umkaDrawSphereWires(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector3* centerPos = (Vector3*)&params[4];
    float radius = params[3].real32Val;
    int rings = params[2].intVal;
    int slices = params[1].intVal;
    Color* color = (Color*)&params[0];
    DrawSphereWires(*centerPos, radius, rings, slices, *color);
}

/**
 * Umka bindings for DrawCylinder.
 *
 * @see DrawCylinder()
 */
void umkaDrawCylinder(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector3* position = (Vector3*)&params[5];
    float radiusTop = params[4].real32Val;
    float radiusBottom = params[3].real32Val;
    float height = params[2].real32Val;
    int slices = params[1].intVal;
    Color* color = (Color*)&params[0];
    DrawCylinder(*position, radiusTop, radiusBottom, height, slices, *color);
}

/**
 * Umka bindings for DrawCylinderEx.
 *
 * @see DrawCylinderEx()
 */
void umkaDrawCylinderEx(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector3* startPos = (Vector3*)&params[5];
    Vector3* endPos = (Vector3*)&params[4];
    float startRadius = params[3].real32Val;
    float endRadius = params[2].real32Val;
    int sides = params[1].intVal;
    Color* color = (Color*)&params[0];
    DrawCylinderEx(*startPos, *endPos, startRadius, endRadius, sides, *color);
}

/**
 * Umka bindings for DrawCylinderWires.
 *
 * @see DrawCylinderWires()
 */
void umkaDrawCylinderWires(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector3* position = (Vector3*)&params[5];
    float radiusTop = params[4].real32Val;
    float radiusBottom = params[3].real32Val;
    float height = params[2].real32Val;
    int slices = params[1].intVal;
    Color* color = (Color*)&params[0];
    DrawCylinderWires(*position, radiusTop, radiusBottom, height, slices, *color);
}

/**
 * Umka bindings for DrawCylinderWiresEx.
 *
 * @see DrawCylinderWiresEx()
 */
void umkaDrawCylinderWiresEx(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector3* startPos = (Vector3*)&params[5];
    Vector3* endPos = (Vector3*)&params[4];
    float startRadius = params[3].real32Val;
    float endRadius = params[2].real32Val;
    int sides = params[1].intVal;
    Color* color = (Color*)&params[0];
    DrawCylinderWiresEx(*startPos, *endPos, startRadius, endRadius, sides, *color);
}

/**
 * Umka bindings for DrawPlane.
 *
 * @see DrawPlane()
 */
void umkaDrawPlane(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector3* centerPos = (Vector3*)&params[2];
    Vector2* size = (Vector2*)&params[1];
    Color* color = (Color*)&params[0];
    DrawPlane(*centerPos, *size, *color);
}

/**
 * Umka bindings for DrawRay.
 *
 * @see DrawRay()
 */
void umkaDrawRay(UmkaStackSlot *params, UmkaStackSlot *result) {
    Ray* ray = (Ray*)&params[1];
    Color* color = (Color*)&params[0];
    DrawRay(*ray, *color);
}

/**
 * Umka bindings for DrawGrid.
 *
 * @see DrawGrid()
 */
void umkaDrawGrid(UmkaStackSlot *params, UmkaStackSlot *result) {
    int slices = params[1].intVal;
    float spacing = params[0].real32Val;
    DrawGrid(slices, spacing);
}

/**
 * Umka bindings for LoadModel.
 *
 * @see LoadModel()
 */
void umkaLoadModel(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    const char * fileName = (const char *)params[1].ptrVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Model), NULL);
    Model out = LoadModel(fileName);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Model));
}

/**
 * Umka bindings for LoadModelFromMesh.
 *
 * @see LoadModelFromMesh()
 */
void umkaLoadModelFromMesh(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Mesh* mesh = (Mesh*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Model), NULL);
    Model out = LoadModelFromMesh(*mesh);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Model));
}

/**
 * Umka bindings for UnloadModel.
 *
 * @see UnloadModel()
 */
void umkaUnloadModel(UmkaStackSlot *params, UmkaStackSlot *result) {
    Model* model = (Model*)&params[0];
    UnloadModel(*model);
}

/**
 * Umka bindings for UnloadModelKeepMeshes.
 *
 * @see UnloadModelKeepMeshes()
 */
void umkaUnloadModelKeepMeshes(UmkaStackSlot *params, UmkaStackSlot *result) {
    Model* model = (Model*)&params[0];
    UnloadModelKeepMeshes(*model);
}

/**
 * Umka bindings for GetModelBoundingBox.
 *
 * @see GetModelBoundingBox()
 */
void umkaGetModelBoundingBox(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Model* model = (Model*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(BoundingBox), NULL);
    BoundingBox out = GetModelBoundingBox(*model);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(BoundingBox));
}

/**
 * Umka bindings for DrawModel.
 *
 * @see DrawModel()
 */
void umkaDrawModel(UmkaStackSlot *params, UmkaStackSlot *result) {
    Model* model = (Model*)&params[3];
    Vector3* position = (Vector3*)&params[2];
    float scale = params[1].real32Val;
    Color* tint = (Color*)&params[0];
    DrawModel(*model, *position, scale, *tint);
}

/**
 * Umka bindings for DrawModelEx.
 *
 * @see DrawModelEx()
 */
void umkaDrawModelEx(UmkaStackSlot *params, UmkaStackSlot *result) {
    Model* model = (Model*)&params[5];
    Vector3* position = (Vector3*)&params[4];
    Vector3* rotationAxis = (Vector3*)&params[3];
    float rotationAngle = params[2].real32Val;
    Vector3* scale = (Vector3*)&params[1];
    Color* tint = (Color*)&params[0];
    DrawModelEx(*model, *position, *rotationAxis, rotationAngle, *scale, *tint);
}

/**
 * Umka bindings for DrawModelWires.
 *
 * @see DrawModelWires()
 */
void umkaDrawModelWires(UmkaStackSlot *params, UmkaStackSlot *result) {
    Model* model = (Model*)&params[3];
    Vector3* position = (Vector3*)&params[2];
    float scale = params[1].real32Val;
    Color* tint = (Color*)&params[0];
    DrawModelWires(*model, *position, scale, *tint);
}

/**
 * Umka bindings for DrawModelWiresEx.
 *
 * @see DrawModelWiresEx()
 */
void umkaDrawModelWiresEx(UmkaStackSlot *params, UmkaStackSlot *result) {
    Model* model = (Model*)&params[5];
    Vector3* position = (Vector3*)&params[4];
    Vector3* rotationAxis = (Vector3*)&params[3];
    float rotationAngle = params[2].real32Val;
    Vector3* scale = (Vector3*)&params[1];
    Color* tint = (Color*)&params[0];
    DrawModelWiresEx(*model, *position, *rotationAxis, rotationAngle, *scale, *tint);
}

/**
 * Umka bindings for DrawBoundingBox.
 *
 * @see DrawBoundingBox()
 */
void umkaDrawBoundingBox(UmkaStackSlot *params, UmkaStackSlot *result) {
    BoundingBox* box = (BoundingBox*)&params[1];
    Color* color = (Color*)&params[0];
    DrawBoundingBox(*box, *color);
}

/**
 * Umka bindings for DrawBillboard.
 *
 * @see DrawBillboard()
 */
void umkaDrawBillboard(UmkaStackSlot *params, UmkaStackSlot *result) {
    Camera* camera = (Camera*)&params[4];
    Texture2D* texture = (Texture2D*)&params[3];
    Vector3* position = (Vector3*)&params[2];
    float size = params[1].real32Val;
    Color* tint = (Color*)&params[0];
    DrawBillboard(*camera, *texture, *position, size, *tint);
}

/**
 * Umka bindings for DrawBillboardRec.
 *
 * @see DrawBillboardRec()
 */
void umkaDrawBillboardRec(UmkaStackSlot *params, UmkaStackSlot *result) {
    Camera* camera = (Camera*)&params[5];
    Texture2D* texture = (Texture2D*)&params[4];
    Rectangle* source = (Rectangle*)&params[3];
    Vector3* position = (Vector3*)&params[2];
    Vector2* size = (Vector2*)&params[1];
    Color* tint = (Color*)&params[0];
    DrawBillboardRec(*camera, *texture, *source, *position, *size, *tint);
}

/**
 * Umka bindings for DrawBillboardPro.
 *
 * @see DrawBillboardPro()
 */
void umkaDrawBillboardPro(UmkaStackSlot *params, UmkaStackSlot *result) {
    Camera* camera = (Camera*)&params[8];
    Texture2D* texture = (Texture2D*)&params[7];
    Rectangle* source = (Rectangle*)&params[6];
    Vector3* position = (Vector3*)&params[5];
    Vector3* up = (Vector3*)&params[4];
    Vector2* size = (Vector2*)&params[3];
    Vector2* origin = (Vector2*)&params[2];
    float rotation = params[1].real32Val;
    Color* tint = (Color*)&params[0];
    DrawBillboardPro(*camera, *texture, *source, *position, *up, *size, *origin, rotation, *tint);
}

/**
 * Umka bindings for UploadMesh.
 *
 * @see UploadMesh()
 */
void umkaUploadMesh(UmkaStackSlot *params, UmkaStackSlot *result) {
    Mesh * mesh = (Mesh *)params[1].ptrVal;
    bool dynamic = (bool)params[0].intVal;
    UploadMesh(mesh, dynamic);
}

/**
 * Umka bindings for UpdateMeshBuffer.
 *
 * @see UpdateMeshBuffer()
 */
void umkaUpdateMeshBuffer(UmkaStackSlot *params, UmkaStackSlot *result) {
    Mesh* mesh = (Mesh*)&params[4];
    int index = params[3].intVal;
    const void * data = (const void *)params[2].ptrVal;
    int dataSize = params[1].intVal;
    int offset = params[0].intVal;
    UpdateMeshBuffer(*mesh, index, data, dataSize, offset);
}

/**
 * Umka bindings for UnloadMesh.
 *
 * @see UnloadMesh()
 */
void umkaUnloadMesh(UmkaStackSlot *params, UmkaStackSlot *result) {
    Mesh* mesh = (Mesh*)&params[0];
    UnloadMesh(*mesh);
}

/**
 * Umka bindings for DrawMesh.
 *
 * @see DrawMesh()
 */
void umkaDrawMesh(UmkaStackSlot *params, UmkaStackSlot *result) {
    Mesh* mesh = (Mesh*)&params[2];
    Material* material = (Material*)&params[1];
    Matrix* transform = (Matrix*)&params[0];
    DrawMesh(*mesh, *material, *transform);
}

/**
 * Umka bindings for DrawMeshInstanced.
 *
 * @see DrawMeshInstanced()
 */
void umkaDrawMeshInstanced(UmkaStackSlot *params, UmkaStackSlot *result) {
    Mesh* mesh = (Mesh*)&params[3];
    Material* material = (Material*)&params[2];
    const Matrix * transforms = (const Matrix *)params[1].ptrVal;
    int instances = params[0].intVal;
    DrawMeshInstanced(*mesh, *material, transforms, instances);
}

/**
 * Umka bindings for ExportMesh.
 *
 * @see ExportMesh()
 */
void umkaExportMesh(UmkaStackSlot *params, UmkaStackSlot *result) {
    Mesh* mesh = (Mesh*)&params[1];
    const char * fileName = (const char *)params[0].ptrVal;
    result->intVal = (int)ExportMesh(*mesh, fileName);
}

/**
 * Umka bindings for GetMeshBoundingBox.
 *
 * @see GetMeshBoundingBox()
 */
void umkaGetMeshBoundingBox(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Mesh* mesh = (Mesh*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(BoundingBox), NULL);
    BoundingBox out = GetMeshBoundingBox(*mesh);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(BoundingBox));
}

/**
 * Umka bindings for GenMeshTangents.
 *
 * @see GenMeshTangents()
 */
void umkaGenMeshTangents(UmkaStackSlot *params, UmkaStackSlot *result) {
    Mesh * mesh = (Mesh *)params[0].ptrVal;
    GenMeshTangents(mesh);
}

/**
 * Umka bindings for GenMeshPoly.
 *
 * @see GenMeshPoly()
 */
void umkaGenMeshPoly(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    int sides = params[2].intVal;
    float radius = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Mesh), NULL);
    Mesh out = GenMeshPoly(sides, radius);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Mesh));
}

/**
 * Umka bindings for GenMeshPlane.
 *
 * @see GenMeshPlane()
 */
void umkaGenMeshPlane(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    float width = params[4].real32Val;
    float length = params[3].real32Val;
    int resX = params[2].intVal;
    int resZ = params[1].intVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Mesh), NULL);
    Mesh out = GenMeshPlane(width, length, resX, resZ);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Mesh));
}

/**
 * Umka bindings for GenMeshCube.
 *
 * @see GenMeshCube()
 */
void umkaGenMeshCube(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    float width = params[3].real32Val;
    float height = params[2].real32Val;
    float length = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Mesh), NULL);
    Mesh out = GenMeshCube(width, height, length);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Mesh));
}

/**
 * Umka bindings for GenMeshSphere.
 *
 * @see GenMeshSphere()
 */
void umkaGenMeshSphere(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    float radius = params[3].real32Val;
    int rings = params[2].intVal;
    int slices = params[1].intVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Mesh), NULL);
    Mesh out = GenMeshSphere(radius, rings, slices);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Mesh));
}

/**
 * Umka bindings for GenMeshHemiSphere.
 *
 * @see GenMeshHemiSphere()
 */
void umkaGenMeshHemiSphere(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    float radius = params[3].real32Val;
    int rings = params[2].intVal;
    int slices = params[1].intVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Mesh), NULL);
    Mesh out = GenMeshHemiSphere(radius, rings, slices);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Mesh));
}

/**
 * Umka bindings for GenMeshCylinder.
 *
 * @see GenMeshCylinder()
 */
void umkaGenMeshCylinder(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    float radius = params[3].real32Val;
    float height = params[2].real32Val;
    int slices = params[1].intVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Mesh), NULL);
    Mesh out = GenMeshCylinder(radius, height, slices);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Mesh));
}

/**
 * Umka bindings for GenMeshCone.
 *
 * @see GenMeshCone()
 */
void umkaGenMeshCone(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    float radius = params[3].real32Val;
    float height = params[2].real32Val;
    int slices = params[1].intVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Mesh), NULL);
    Mesh out = GenMeshCone(radius, height, slices);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Mesh));
}

/**
 * Umka bindings for GenMeshTorus.
 *
 * @see GenMeshTorus()
 */
void umkaGenMeshTorus(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    float radius = params[4].real32Val;
    float size = params[3].real32Val;
    int radSeg = params[2].intVal;
    int sides = params[1].intVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Mesh), NULL);
    Mesh out = GenMeshTorus(radius, size, radSeg, sides);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Mesh));
}

/**
 * Umka bindings for GenMeshKnot.
 *
 * @see GenMeshKnot()
 */
void umkaGenMeshKnot(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    float radius = params[4].real32Val;
    float size = params[3].real32Val;
    int radSeg = params[2].intVal;
    int sides = params[1].intVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Mesh), NULL);
    Mesh out = GenMeshKnot(radius, size, radSeg, sides);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Mesh));
}

/**
 * Umka bindings for GenMeshHeightmap.
 *
 * @see GenMeshHeightmap()
 */
void umkaGenMeshHeightmap(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Image* heightmap = (Image*)&params[2];
    Vector3* size = (Vector3*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Mesh), NULL);
    Mesh out = GenMeshHeightmap(*heightmap, *size);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Mesh));
}

/**
 * Umka bindings for GenMeshCubicmap.
 *
 * @see GenMeshCubicmap()
 */
void umkaGenMeshCubicmap(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Image* cubicmap = (Image*)&params[2];
    Vector3* cubeSize = (Vector3*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Mesh), NULL);
    Mesh out = GenMeshCubicmap(*cubicmap, *cubeSize);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Mesh));
}

/**
 * Umka bindings for LoadMaterials.
 *
 * @see LoadMaterials()
 */
void umkaLoadMaterials(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * fileName = (const char *)params[1].ptrVal;
    int * materialCount = (int *)params[0].ptrVal;
    result->ptrVal = (void*)LoadMaterials(fileName, materialCount);
}

/**
 * Umka bindings for LoadMaterialDefault.
 *
 * @see LoadMaterialDefault()
 */
void umkaLoadMaterialDefault(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Material), NULL);
    Material out = LoadMaterialDefault();
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Material));
}

/**
 * Umka bindings for UnloadMaterial.
 *
 * @see UnloadMaterial()
 */
void umkaUnloadMaterial(UmkaStackSlot *params, UmkaStackSlot *result) {
    Material* material = (Material*)&params[0];
    UnloadMaterial(*material);
}

/**
 * Umka bindings for SetMaterialTexture.
 *
 * @see SetMaterialTexture()
 */
void umkaSetMaterialTexture(UmkaStackSlot *params, UmkaStackSlot *result) {
    Material * material = (Material *)params[2].ptrVal;
    int mapType = params[1].intVal;
    Texture2D* texture = (Texture2D*)&params[0];
    SetMaterialTexture(material, mapType, *texture);
}

/**
 * Umka bindings for SetModelMeshMaterial.
 *
 * @see SetModelMeshMaterial()
 */
void umkaSetModelMeshMaterial(UmkaStackSlot *params, UmkaStackSlot *result) {
    Model * model = (Model *)params[2].ptrVal;
    int meshId = params[1].intVal;
    int materialId = params[0].intVal;
    SetModelMeshMaterial(model, meshId, materialId);
}

/**
 * Umka bindings for LoadModelAnimations.
 *
 * @see LoadModelAnimations()
 */
void umkaLoadModelAnimations(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * fileName = (const char *)params[1].ptrVal;
    unsigned int * animCount = (unsigned int *)params[0].ptrVal;
    result->ptrVal = (void*)LoadModelAnimations(fileName, animCount);
}

/**
 * Umka bindings for UpdateModelAnimation.
 *
 * @see UpdateModelAnimation()
 */
void umkaUpdateModelAnimation(UmkaStackSlot *params, UmkaStackSlot *result) {
    Model* model = (Model*)&params[2];
    ModelAnimation* anim = (ModelAnimation*)&params[1];
    int frame = params[0].intVal;
    UpdateModelAnimation(*model, *anim, frame);
}

/**
 * Umka bindings for UnloadModelAnimation.
 *
 * @see UnloadModelAnimation()
 */
void umkaUnloadModelAnimation(UmkaStackSlot *params, UmkaStackSlot *result) {
    ModelAnimation* anim = (ModelAnimation*)&params[0];
    UnloadModelAnimation(*anim);
}

/**
 * Umka bindings for UnloadModelAnimations.
 *
 * @see UnloadModelAnimations()
 */
void umkaUnloadModelAnimations(UmkaStackSlot *params, UmkaStackSlot *result) {
    ModelAnimation * animations = (ModelAnimation *)params[1].ptrVal;
    unsigned int count = params[0].uintVal;
    UnloadModelAnimations(animations, count);
}

/**
 * Umka bindings for IsModelAnimationValid.
 *
 * @see IsModelAnimationValid()
 */
void umkaIsModelAnimationValid(UmkaStackSlot *params, UmkaStackSlot *result) {
    Model* model = (Model*)&params[1];
    ModelAnimation* anim = (ModelAnimation*)&params[0];
    result->intVal = (int)IsModelAnimationValid(*model, *anim);
}

/**
 * Umka bindings for CheckCollisionSpheres.
 *
 * @see CheckCollisionSpheres()
 */
void umkaCheckCollisionSpheres(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector3* center1 = (Vector3*)&params[3];
    float radius1 = params[2].real32Val;
    Vector3* center2 = (Vector3*)&params[1];
    float radius2 = params[0].real32Val;
    result->intVal = (int)CheckCollisionSpheres(*center1, radius1, *center2, radius2);
}

/**
 * Umka bindings for CheckCollisionBoxes.
 *
 * @see CheckCollisionBoxes()
 */
void umkaCheckCollisionBoxes(UmkaStackSlot *params, UmkaStackSlot *result) {
    BoundingBox* box1 = (BoundingBox*)&params[1];
    BoundingBox* box2 = (BoundingBox*)&params[0];
    result->intVal = (int)CheckCollisionBoxes(*box1, *box2);
}

/**
 * Umka bindings for CheckCollisionBoxSphere.
 *
 * @see CheckCollisionBoxSphere()
 */
void umkaCheckCollisionBoxSphere(UmkaStackSlot *params, UmkaStackSlot *result) {
    BoundingBox* box = (BoundingBox*)&params[2];
    Vector3* center = (Vector3*)&params[1];
    float radius = params[0].real32Val;
    result->intVal = (int)CheckCollisionBoxSphere(*box, *center, radius);
}

/**
 * Umka bindings for GetRayCollisionSphere.
 *
 * @see GetRayCollisionSphere()
 */
void umkaGetRayCollisionSphere(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Ray* ray = (Ray*)&params[3];
    Vector3* center = (Vector3*)&params[2];
    float radius = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(RayCollision), NULL);
    RayCollision out = GetRayCollisionSphere(*ray, *center, radius);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(RayCollision));
}

/**
 * Umka bindings for GetRayCollisionBox.
 *
 * @see GetRayCollisionBox()
 */
void umkaGetRayCollisionBox(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Ray* ray = (Ray*)&params[2];
    BoundingBox* box = (BoundingBox*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(RayCollision), NULL);
    RayCollision out = GetRayCollisionBox(*ray, *box);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(RayCollision));
}

/**
 * Umka bindings for GetRayCollisionMesh.
 *
 * @see GetRayCollisionMesh()
 */
void umkaGetRayCollisionMesh(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Ray* ray = (Ray*)&params[3];
    Mesh* mesh = (Mesh*)&params[2];
    Matrix* transform = (Matrix*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(RayCollision), NULL);
    RayCollision out = GetRayCollisionMesh(*ray, *mesh, *transform);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(RayCollision));
}

/**
 * Umka bindings for GetRayCollisionTriangle.
 *
 * @see GetRayCollisionTriangle()
 */
void umkaGetRayCollisionTriangle(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Ray* ray = (Ray*)&params[4];
    Vector3* p1 = (Vector3*)&params[3];
    Vector3* p2 = (Vector3*)&params[2];
    Vector3* p3 = (Vector3*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(RayCollision), NULL);
    RayCollision out = GetRayCollisionTriangle(*ray, *p1, *p2, *p3);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(RayCollision));
}

/**
 * Umka bindings for GetRayCollisionQuad.
 *
 * @see GetRayCollisionQuad()
 */
void umkaGetRayCollisionQuad(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Ray* ray = (Ray*)&params[5];
    Vector3* p1 = (Vector3*)&params[4];
    Vector3* p2 = (Vector3*)&params[3];
    Vector3* p3 = (Vector3*)&params[2];
    Vector3* p4 = (Vector3*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(RayCollision), NULL);
    RayCollision out = GetRayCollisionQuad(*ray, *p1, *p2, *p3, *p4);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(RayCollision));
}

/**
 * Umka bindings for InitAudioDevice.
 *
 * @see InitAudioDevice()
 */
void umkaInitAudioDevice(UmkaStackSlot *params, UmkaStackSlot *result) {
    InitAudioDevice();
}

/**
 * Umka bindings for CloseAudioDevice.
 *
 * @see CloseAudioDevice()
 */
void umkaCloseAudioDevice(UmkaStackSlot *params, UmkaStackSlot *result) {
    CloseAudioDevice();
}

/**
 * Umka bindings for IsAudioDeviceReady.
 *
 * @see IsAudioDeviceReady()
 */
void umkaIsAudioDeviceReady(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->intVal = (int)IsAudioDeviceReady();
}

/**
 * Umka bindings for SetMasterVolume.
 *
 * @see SetMasterVolume()
 */
void umkaSetMasterVolume(UmkaStackSlot *params, UmkaStackSlot *result) {
    float volume = params[0].real32Val;
    SetMasterVolume(volume);
}

/**
 * Umka bindings for LoadWave.
 *
 * @see LoadWave()
 */
void umkaLoadWave(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    const char * fileName = (const char *)params[1].ptrVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Wave), NULL);
    Wave out = LoadWave(fileName);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Wave));
}

/**
 * Umka bindings for LoadWaveFromMemory.
 *
 * @see LoadWaveFromMemory()
 */
void umkaLoadWaveFromMemory(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    const char * fileType = (const char *)params[3].ptrVal;
    const unsigned char * fileData = (const unsigned char *)params[2].ptrVal;
    int dataSize = params[1].intVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Wave), NULL);
    Wave out = LoadWaveFromMemory(fileType, fileData, dataSize);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Wave));
}

/**
 * Umka bindings for LoadSound.
 *
 * @see LoadSound()
 */
void umkaLoadSound(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    const char * fileName = (const char *)params[1].ptrVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Sound), NULL);
    Sound out = LoadSound(fileName);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Sound));
}

/**
 * Umka bindings for LoadSoundFromWave.
 *
 * @see LoadSoundFromWave()
 */
void umkaLoadSoundFromWave(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Wave* wave = (Wave*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Sound), NULL);
    Sound out = LoadSoundFromWave(*wave);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Sound));
}

/**
 * Umka bindings for UpdateSound.
 *
 * @see UpdateSound()
 */
void umkaUpdateSound(UmkaStackSlot *params, UmkaStackSlot *result) {
    Sound* sound = (Sound*)&params[2];
    const void * data = (const void *)params[1].ptrVal;
    int sampleCount = params[0].intVal;
    UpdateSound(*sound, data, sampleCount);
}

/**
 * Umka bindings for UnloadWave.
 *
 * @see UnloadWave()
 */
void umkaUnloadWave(UmkaStackSlot *params, UmkaStackSlot *result) {
    Wave* wave = (Wave*)&params[0];
    UnloadWave(*wave);
}

/**
 * Umka bindings for UnloadSound.
 *
 * @see UnloadSound()
 */
void umkaUnloadSound(UmkaStackSlot *params, UmkaStackSlot *result) {
    Sound* sound = (Sound*)&params[0];
    UnloadSound(*sound);
}

/**
 * Umka bindings for ExportWave.
 *
 * @see ExportWave()
 */
void umkaExportWave(UmkaStackSlot *params, UmkaStackSlot *result) {
    Wave* wave = (Wave*)&params[1];
    const char * fileName = (const char *)params[0].ptrVal;
    result->intVal = (int)ExportWave(*wave, fileName);
}

/**
 * Umka bindings for ExportWaveAsCode.
 *
 * @see ExportWaveAsCode()
 */
void umkaExportWaveAsCode(UmkaStackSlot *params, UmkaStackSlot *result) {
    Wave* wave = (Wave*)&params[1];
    const char * fileName = (const char *)params[0].ptrVal;
    result->intVal = (int)ExportWaveAsCode(*wave, fileName);
}

/**
 * Umka bindings for PlaySound.
 *
 * @see PlaySound()
 */
void umkaPlaySound(UmkaStackSlot *params, UmkaStackSlot *result) {
    Sound* sound = (Sound*)&params[0];
    PlaySound(*sound);
}

/**
 * Umka bindings for StopSound.
 *
 * @see StopSound()
 */
void umkaStopSound(UmkaStackSlot *params, UmkaStackSlot *result) {
    Sound* sound = (Sound*)&params[0];
    StopSound(*sound);
}

/**
 * Umka bindings for PauseSound.
 *
 * @see PauseSound()
 */
void umkaPauseSound(UmkaStackSlot *params, UmkaStackSlot *result) {
    Sound* sound = (Sound*)&params[0];
    PauseSound(*sound);
}

/**
 * Umka bindings for ResumeSound.
 *
 * @see ResumeSound()
 */
void umkaResumeSound(UmkaStackSlot *params, UmkaStackSlot *result) {
    Sound* sound = (Sound*)&params[0];
    ResumeSound(*sound);
}

/**
 * Umka bindings for PlaySoundMulti.
 *
 * @see PlaySoundMulti()
 */
void umkaPlaySoundMulti(UmkaStackSlot *params, UmkaStackSlot *result) {
    Sound* sound = (Sound*)&params[0];
    PlaySoundMulti(*sound);
}

/**
 * Umka bindings for StopSoundMulti.
 *
 * @see StopSoundMulti()
 */
void umkaStopSoundMulti(UmkaStackSlot *params, UmkaStackSlot *result) {
    StopSoundMulti();
}

/**
 * Umka bindings for GetSoundsPlaying.
 *
 * @see GetSoundsPlaying()
 */
void umkaGetSoundsPlaying(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->intVal = GetSoundsPlaying();
}

/**
 * Umka bindings for IsSoundPlaying.
 *
 * @see IsSoundPlaying()
 */
void umkaIsSoundPlaying(UmkaStackSlot *params, UmkaStackSlot *result) {
    Sound* sound = (Sound*)&params[0];
    result->intVal = (int)IsSoundPlaying(*sound);
}

/**
 * Umka bindings for SetSoundVolume.
 *
 * @see SetSoundVolume()
 */
void umkaSetSoundVolume(UmkaStackSlot *params, UmkaStackSlot *result) {
    Sound* sound = (Sound*)&params[1];
    float volume = params[0].real32Val;
    SetSoundVolume(*sound, volume);
}

/**
 * Umka bindings for SetSoundPitch.
 *
 * @see SetSoundPitch()
 */
void umkaSetSoundPitch(UmkaStackSlot *params, UmkaStackSlot *result) {
    Sound* sound = (Sound*)&params[1];
    float pitch = params[0].real32Val;
    SetSoundPitch(*sound, pitch);
}

/**
 * Umka bindings for SetSoundPan.
 *
 * @see SetSoundPan()
 */
void umkaSetSoundPan(UmkaStackSlot *params, UmkaStackSlot *result) {
    Sound* sound = (Sound*)&params[1];
    float pan = params[0].real32Val;
    SetSoundPan(*sound, pan);
}

/**
 * Umka bindings for WaveCopy.
 *
 * @see WaveCopy()
 */
void umkaWaveCopy(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Wave* wave = (Wave*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Wave), NULL);
    Wave out = WaveCopy(*wave);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Wave));
}

/**
 * Umka bindings for WaveCrop.
 *
 * @see WaveCrop()
 */
void umkaWaveCrop(UmkaStackSlot *params, UmkaStackSlot *result) {
    Wave * wave = (Wave *)params[2].ptrVal;
    int initSample = params[1].intVal;
    int finalSample = params[0].intVal;
    WaveCrop(wave, initSample, finalSample);
}

/**
 * Umka bindings for WaveFormat.
 *
 * @see WaveFormat()
 */
void umkaWaveFormat(UmkaStackSlot *params, UmkaStackSlot *result) {
    Wave * wave = (Wave *)params[3].ptrVal;
    int sampleRate = params[2].intVal;
    int sampleSize = params[1].intVal;
    int channels = params[0].intVal;
    WaveFormat(wave, sampleRate, sampleSize, channels);
}

/**
 * Umka bindings for LoadWaveSamples.
 *
 * @see LoadWaveSamples()
 */
void umkaLoadWaveSamples(UmkaStackSlot *params, UmkaStackSlot *result) {
    Wave* wave = (Wave*)&params[0];
    result->ptrVal = (void*)LoadWaveSamples(*wave);
}

/**
 * Umka bindings for UnloadWaveSamples.
 *
 * @see UnloadWaveSamples()
 */
void umkaUnloadWaveSamples(UmkaStackSlot *params, UmkaStackSlot *result) {
    float * samples = (float *)params[0].ptrVal;
    UnloadWaveSamples(samples);
}

/**
 * Umka bindings for LoadMusicStream.
 *
 * @see LoadMusicStream()
 */
void umkaLoadMusicStream(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    const char * fileName = (const char *)params[1].ptrVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Music), NULL);
    Music out = LoadMusicStream(fileName);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Music));
}

/**
 * Umka bindings for LoadMusicStreamFromMemory.
 *
 * @see LoadMusicStreamFromMemory()
 */
void umkaLoadMusicStreamFromMemory(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    const char * fileType = (const char *)params[3].ptrVal;
    const unsigned char * data = (const unsigned char *)params[2].ptrVal;
    int dataSize = params[1].intVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Music), NULL);
    Music out = LoadMusicStreamFromMemory(fileType, data, dataSize);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Music));
}

/**
 * Umka bindings for UnloadMusicStream.
 *
 * @see UnloadMusicStream()
 */
void umkaUnloadMusicStream(UmkaStackSlot *params, UmkaStackSlot *result) {
    Music* music = (Music*)&params[0];
    UnloadMusicStream(*music);
}

/**
 * Umka bindings for PlayMusicStream.
 *
 * @see PlayMusicStream()
 */
void umkaPlayMusicStream(UmkaStackSlot *params, UmkaStackSlot *result) {
    Music* music = (Music*)&params[0];
    PlayMusicStream(*music);
}

/**
 * Umka bindings for IsMusicStreamPlaying.
 *
 * @see IsMusicStreamPlaying()
 */
void umkaIsMusicStreamPlaying(UmkaStackSlot *params, UmkaStackSlot *result) {
    Music* music = (Music*)&params[0];
    result->intVal = (int)IsMusicStreamPlaying(*music);
}

/**
 * Umka bindings for UpdateMusicStream.
 *
 * @see UpdateMusicStream()
 */
void umkaUpdateMusicStream(UmkaStackSlot *params, UmkaStackSlot *result) {
    Music* music = (Music*)&params[0];
    UpdateMusicStream(*music);
}

/**
 * Umka bindings for StopMusicStream.
 *
 * @see StopMusicStream()
 */
void umkaStopMusicStream(UmkaStackSlot *params, UmkaStackSlot *result) {
    Music* music = (Music*)&params[0];
    StopMusicStream(*music);
}

/**
 * Umka bindings for PauseMusicStream.
 *
 * @see PauseMusicStream()
 */
void umkaPauseMusicStream(UmkaStackSlot *params, UmkaStackSlot *result) {
    Music* music = (Music*)&params[0];
    PauseMusicStream(*music);
}

/**
 * Umka bindings for ResumeMusicStream.
 *
 * @see ResumeMusicStream()
 */
void umkaResumeMusicStream(UmkaStackSlot *params, UmkaStackSlot *result) {
    Music* music = (Music*)&params[0];
    ResumeMusicStream(*music);
}

/**
 * Umka bindings for SeekMusicStream.
 *
 * @see SeekMusicStream()
 */
void umkaSeekMusicStream(UmkaStackSlot *params, UmkaStackSlot *result) {
    Music* music = (Music*)&params[1];
    float position = params[0].real32Val;
    SeekMusicStream(*music, position);
}

/**
 * Umka bindings for SetMusicVolume.
 *
 * @see SetMusicVolume()
 */
void umkaSetMusicVolume(UmkaStackSlot *params, UmkaStackSlot *result) {
    Music* music = (Music*)&params[1];
    float volume = params[0].real32Val;
    SetMusicVolume(*music, volume);
}

/**
 * Umka bindings for SetMusicPitch.
 *
 * @see SetMusicPitch()
 */
void umkaSetMusicPitch(UmkaStackSlot *params, UmkaStackSlot *result) {
    Music* music = (Music*)&params[1];
    float pitch = params[0].real32Val;
    SetMusicPitch(*music, pitch);
}

/**
 * Umka bindings for SetMusicPan.
 *
 * @see SetMusicPan()
 */
void umkaSetMusicPan(UmkaStackSlot *params, UmkaStackSlot *result) {
    Music* music = (Music*)&params[1];
    float pan = params[0].real32Val;
    SetMusicPan(*music, pan);
}

/**
 * Umka bindings for GetMusicTimeLength.
 *
 * @see GetMusicTimeLength()
 */
void umkaGetMusicTimeLength(UmkaStackSlot *params, UmkaStackSlot *result) {
    Music* music = (Music*)&params[0];
    result->real32Val = GetMusicTimeLength(*music);
}

/**
 * Umka bindings for GetMusicTimePlayed.
 *
 * @see GetMusicTimePlayed()
 */
void umkaGetMusicTimePlayed(UmkaStackSlot *params, UmkaStackSlot *result) {
    Music* music = (Music*)&params[0];
    result->real32Val = GetMusicTimePlayed(*music);
}

/**
 * Umka bindings for LoadAudioStream.
 *
 * @see LoadAudioStream()
 */
void umkaLoadAudioStream(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    unsigned int sampleRate = params[3].uintVal;
    unsigned int sampleSize = params[2].uintVal;
    unsigned int channels = params[1].uintVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(AudioStream), NULL);
    AudioStream out = LoadAudioStream(sampleRate, sampleSize, channels);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(AudioStream));
}

/**
 * Umka bindings for UnloadAudioStream.
 *
 * @see UnloadAudioStream()
 */
void umkaUnloadAudioStream(UmkaStackSlot *params, UmkaStackSlot *result) {
    AudioStream* stream = (AudioStream*)&params[0];
    UnloadAudioStream(*stream);
}

/**
 * Umka bindings for UpdateAudioStream.
 *
 * @see UpdateAudioStream()
 */
void umkaUpdateAudioStream(UmkaStackSlot *params, UmkaStackSlot *result) {
    AudioStream* stream = (AudioStream*)&params[2];
    const void * data = (const void *)params[1].ptrVal;
    int frameCount = params[0].intVal;
    UpdateAudioStream(*stream, data, frameCount);
}

/**
 * Umka bindings for IsAudioStreamProcessed.
 *
 * @see IsAudioStreamProcessed()
 */
void umkaIsAudioStreamProcessed(UmkaStackSlot *params, UmkaStackSlot *result) {
    AudioStream* stream = (AudioStream*)&params[0];
    result->intVal = (int)IsAudioStreamProcessed(*stream);
}

/**
 * Umka bindings for PlayAudioStream.
 *
 * @see PlayAudioStream()
 */
void umkaPlayAudioStream(UmkaStackSlot *params, UmkaStackSlot *result) {
    AudioStream* stream = (AudioStream*)&params[0];
    PlayAudioStream(*stream);
}

/**
 * Umka bindings for PauseAudioStream.
 *
 * @see PauseAudioStream()
 */
void umkaPauseAudioStream(UmkaStackSlot *params, UmkaStackSlot *result) {
    AudioStream* stream = (AudioStream*)&params[0];
    PauseAudioStream(*stream);
}

/**
 * Umka bindings for ResumeAudioStream.
 *
 * @see ResumeAudioStream()
 */
void umkaResumeAudioStream(UmkaStackSlot *params, UmkaStackSlot *result) {
    AudioStream* stream = (AudioStream*)&params[0];
    ResumeAudioStream(*stream);
}

/**
 * Umka bindings for IsAudioStreamPlaying.
 *
 * @see IsAudioStreamPlaying()
 */
void umkaIsAudioStreamPlaying(UmkaStackSlot *params, UmkaStackSlot *result) {
    AudioStream* stream = (AudioStream*)&params[0];
    result->intVal = (int)IsAudioStreamPlaying(*stream);
}

/**
 * Umka bindings for StopAudioStream.
 *
 * @see StopAudioStream()
 */
void umkaStopAudioStream(UmkaStackSlot *params, UmkaStackSlot *result) {
    AudioStream* stream = (AudioStream*)&params[0];
    StopAudioStream(*stream);
}

/**
 * Umka bindings for SetAudioStreamVolume.
 *
 * @see SetAudioStreamVolume()
 */
void umkaSetAudioStreamVolume(UmkaStackSlot *params, UmkaStackSlot *result) {
    AudioStream* stream = (AudioStream*)&params[1];
    float volume = params[0].real32Val;
    SetAudioStreamVolume(*stream, volume);
}

/**
 * Umka bindings for SetAudioStreamPitch.
 *
 * @see SetAudioStreamPitch()
 */
void umkaSetAudioStreamPitch(UmkaStackSlot *params, UmkaStackSlot *result) {
    AudioStream* stream = (AudioStream*)&params[1];
    float pitch = params[0].real32Val;
    SetAudioStreamPitch(*stream, pitch);
}

/**
 * Umka bindings for SetAudioStreamPan.
 *
 * @see SetAudioStreamPan()
 */
void umkaSetAudioStreamPan(UmkaStackSlot *params, UmkaStackSlot *result) {
    AudioStream* stream = (AudioStream*)&params[1];
    float pan = params[0].real32Val;
    SetAudioStreamPan(*stream, pan);
}

/**
 * Umka bindings for SetAudioStreamBufferSizeDefault.
 *
 * @see SetAudioStreamBufferSizeDefault()
 */
void umkaSetAudioStreamBufferSizeDefault(UmkaStackSlot *params, UmkaStackSlot *result) {
    int size = params[0].intVal;
    SetAudioStreamBufferSizeDefault(size);
}

// Function SetAudioStreamCallback() skipped

// Function AttachAudioStreamProcessor() skipped

// Function DetachAudioStreamProcessor() skipped

/**
 * Umka bindings for Clamp.
 *
 * @see Clamp()
 */
void umkaClamp(UmkaStackSlot *params, UmkaStackSlot *result) {
    float value = params[2].real32Val;
    float min = params[1].real32Val;
    float max = params[0].real32Val;
    result->real32Val = Clamp(value, min, max);
}

/**
 * Umka bindings for Lerp.
 *
 * @see Lerp()
 */
void umkaLerp(UmkaStackSlot *params, UmkaStackSlot *result) {
    float start = params[2].real32Val;
    float end = params[1].real32Val;
    float amount = params[0].real32Val;
    result->real32Val = Lerp(start, end, amount);
}

/**
 * Umka bindings for Normalize.
 *
 * @see Normalize()
 */
void umkaNormalize(UmkaStackSlot *params, UmkaStackSlot *result) {
    float value = params[2].real32Val;
    float start = params[1].real32Val;
    float end = params[0].real32Val;
    result->real32Val = Normalize(value, start, end);
}

/**
 * Umka bindings for Remap.
 *
 * @see Remap()
 */
void umkaRemap(UmkaStackSlot *params, UmkaStackSlot *result) {
    float value = params[4].real32Val;
    float inputStart = params[3].real32Val;
    float inputEnd = params[2].real32Val;
    float outputStart = params[1].real32Val;
    float outputEnd = params[0].real32Val;
    result->real32Val = Remap(value, inputStart, inputEnd, outputStart, outputEnd);
}

/**
 * Umka bindings for Wrap.
 *
 * @see Wrap()
 */
void umkaWrap(UmkaStackSlot *params, UmkaStackSlot *result) {
    float value = params[2].real32Val;
    float min = params[1].real32Val;
    float max = params[0].real32Val;
    result->real32Val = Wrap(value, min, max);
}

/**
 * Umka bindings for FloatEquals.
 *
 * @see FloatEquals()
 */
void umkaFloatEquals(UmkaStackSlot *params, UmkaStackSlot *result) {
    float x = params[1].real32Val;
    float y = params[0].real32Val;
    result->intVal = FloatEquals(x, y);
}

/**
 * Umka bindings for Vector2Zero.
 *
 * @see Vector2Zero()
 */
void umkaVector2Zero(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector2), NULL);
    Vector2 out = Vector2Zero();
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector2));
}

/**
 * Umka bindings for Vector2One.
 *
 * @see Vector2One()
 */
void umkaVector2One(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector2), NULL);
    Vector2 out = Vector2One();
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector2));
}

/**
 * Umka bindings for Vector2Add.
 *
 * @see Vector2Add()
 */
void umkaVector2Add(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector2* v1 = (Vector2*)&params[2];
    Vector2* v2 = (Vector2*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector2), NULL);
    Vector2 out = Vector2Add(*v1, *v2);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector2));
}

/**
 * Umka bindings for Vector2AddValue.
 *
 * @see Vector2AddValue()
 */
void umkaVector2AddValue(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector2* v = (Vector2*)&params[2];
    float add = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector2), NULL);
    Vector2 out = Vector2AddValue(*v, add);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector2));
}

/**
 * Umka bindings for Vector2Subtract.
 *
 * @see Vector2Subtract()
 */
void umkaVector2Subtract(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector2* v1 = (Vector2*)&params[2];
    Vector2* v2 = (Vector2*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector2), NULL);
    Vector2 out = Vector2Subtract(*v1, *v2);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector2));
}

/**
 * Umka bindings for Vector2SubtractValue.
 *
 * @see Vector2SubtractValue()
 */
void umkaVector2SubtractValue(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector2* v = (Vector2*)&params[2];
    float sub = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector2), NULL);
    Vector2 out = Vector2SubtractValue(*v, sub);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector2));
}

/**
 * Umka bindings for Vector2Length.
 *
 * @see Vector2Length()
 */
void umkaVector2Length(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2* v = (Vector2*)&params[0];
    result->real32Val = Vector2Length(*v);
}

/**
 * Umka bindings for Vector2LengthSqr.
 *
 * @see Vector2LengthSqr()
 */
void umkaVector2LengthSqr(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2* v = (Vector2*)&params[0];
    result->real32Val = Vector2LengthSqr(*v);
}

/**
 * Umka bindings for Vector2DotProduct.
 *
 * @see Vector2DotProduct()
 */
void umkaVector2DotProduct(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2* v1 = (Vector2*)&params[1];
    Vector2* v2 = (Vector2*)&params[0];
    result->real32Val = Vector2DotProduct(*v1, *v2);
}

/**
 * Umka bindings for Vector2Distance.
 *
 * @see Vector2Distance()
 */
void umkaVector2Distance(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2* v1 = (Vector2*)&params[1];
    Vector2* v2 = (Vector2*)&params[0];
    result->real32Val = Vector2Distance(*v1, *v2);
}

/**
 * Umka bindings for Vector2DistanceSqr.
 *
 * @see Vector2DistanceSqr()
 */
void umkaVector2DistanceSqr(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2* v1 = (Vector2*)&params[1];
    Vector2* v2 = (Vector2*)&params[0];
    result->real32Val = Vector2DistanceSqr(*v1, *v2);
}

/**
 * Umka bindings for Vector2Angle.
 *
 * @see Vector2Angle()
 */
void umkaVector2Angle(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2* v1 = (Vector2*)&params[1];
    Vector2* v2 = (Vector2*)&params[0];
    result->real32Val = Vector2Angle(*v1, *v2);
}

/**
 * Umka bindings for Vector2Scale.
 *
 * @see Vector2Scale()
 */
void umkaVector2Scale(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector2* v = (Vector2*)&params[2];
    float scale = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector2), NULL);
    Vector2 out = Vector2Scale(*v, scale);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector2));
}

/**
 * Umka bindings for Vector2Multiply.
 *
 * @see Vector2Multiply()
 */
void umkaVector2Multiply(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector2* v1 = (Vector2*)&params[2];
    Vector2* v2 = (Vector2*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector2), NULL);
    Vector2 out = Vector2Multiply(*v1, *v2);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector2));
}

/**
 * Umka bindings for Vector2Negate.
 *
 * @see Vector2Negate()
 */
void umkaVector2Negate(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector2* v = (Vector2*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector2), NULL);
    Vector2 out = Vector2Negate(*v);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector2));
}

/**
 * Umka bindings for Vector2Divide.
 *
 * @see Vector2Divide()
 */
void umkaVector2Divide(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector2* v1 = (Vector2*)&params[2];
    Vector2* v2 = (Vector2*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector2), NULL);
    Vector2 out = Vector2Divide(*v1, *v2);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector2));
}

/**
 * Umka bindings for Vector2Normalize.
 *
 * @see Vector2Normalize()
 */
void umkaVector2Normalize(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector2* v = (Vector2*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector2), NULL);
    Vector2 out = Vector2Normalize(*v);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector2));
}

/**
 * Umka bindings for Vector2Transform.
 *
 * @see Vector2Transform()
 */
void umkaVector2Transform(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector2* v = (Vector2*)&params[2];
    Matrix* mat = (Matrix*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector2), NULL);
    Vector2 out = Vector2Transform(*v, *mat);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector2));
}

/**
 * Umka bindings for Vector2Lerp.
 *
 * @see Vector2Lerp()
 */
void umkaVector2Lerp(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector2* v1 = (Vector2*)&params[3];
    Vector2* v2 = (Vector2*)&params[2];
    float amount = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector2), NULL);
    Vector2 out = Vector2Lerp(*v1, *v2, amount);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector2));
}

/**
 * Umka bindings for Vector2Reflect.
 *
 * @see Vector2Reflect()
 */
void umkaVector2Reflect(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector2* v = (Vector2*)&params[2];
    Vector2* normal = (Vector2*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector2), NULL);
    Vector2 out = Vector2Reflect(*v, *normal);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector2));
}

/**
 * Umka bindings for Vector2Rotate.
 *
 * @see Vector2Rotate()
 */
void umkaVector2Rotate(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector2* v = (Vector2*)&params[2];
    float angle = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector2), NULL);
    Vector2 out = Vector2Rotate(*v, angle);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector2));
}

/**
 * Umka bindings for Vector2MoveTowards.
 *
 * @see Vector2MoveTowards()
 */
void umkaVector2MoveTowards(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector2* v = (Vector2*)&params[3];
    Vector2* target = (Vector2*)&params[2];
    float maxDistance = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector2), NULL);
    Vector2 out = Vector2MoveTowards(*v, *target, maxDistance);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector2));
}

/**
 * Umka bindings for Vector2Invert.
 *
 * @see Vector2Invert()
 */
void umkaVector2Invert(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector2* v = (Vector2*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector2), NULL);
    Vector2 out = Vector2Invert(*v);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector2));
}

/**
 * Umka bindings for Vector2Clamp.
 *
 * @see Vector2Clamp()
 */
void umkaVector2Clamp(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector2* v = (Vector2*)&params[3];
    Vector2* min = (Vector2*)&params[2];
    Vector2* max = (Vector2*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector2), NULL);
    Vector2 out = Vector2Clamp(*v, *min, *max);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector2));
}

/**
 * Umka bindings for Vector2ClampValue.
 *
 * @see Vector2ClampValue()
 */
void umkaVector2ClampValue(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector2* v = (Vector2*)&params[3];
    float min = params[2].real32Val;
    float max = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector2), NULL);
    Vector2 out = Vector2ClampValue(*v, min, max);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector2));
}

/**
 * Umka bindings for Vector2Equals.
 *
 * @see Vector2Equals()
 */
void umkaVector2Equals(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2* p = (Vector2*)&params[1];
    Vector2* q = (Vector2*)&params[0];
    result->intVal = Vector2Equals(*p, *q);
}

/**
 * Umka bindings for Vector3Zero.
 *
 * @see Vector3Zero()
 */
void umkaVector3Zero(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector3), NULL);
    Vector3 out = Vector3Zero();
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector3));
}

/**
 * Umka bindings for Vector3One.
 *
 * @see Vector3One()
 */
void umkaVector3One(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector3), NULL);
    Vector3 out = Vector3One();
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector3));
}

/**
 * Umka bindings for Vector3Add.
 *
 * @see Vector3Add()
 */
void umkaVector3Add(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector3* v1 = (Vector3*)&params[2];
    Vector3* v2 = (Vector3*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector3), NULL);
    Vector3 out = Vector3Add(*v1, *v2);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector3));
}

/**
 * Umka bindings for Vector3AddValue.
 *
 * @see Vector3AddValue()
 */
void umkaVector3AddValue(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector3* v = (Vector3*)&params[2];
    float add = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector3), NULL);
    Vector3 out = Vector3AddValue(*v, add);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector3));
}

/**
 * Umka bindings for Vector3Subtract.
 *
 * @see Vector3Subtract()
 */
void umkaVector3Subtract(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector3* v1 = (Vector3*)&params[2];
    Vector3* v2 = (Vector3*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector3), NULL);
    Vector3 out = Vector3Subtract(*v1, *v2);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector3));
}

/**
 * Umka bindings for Vector3SubtractValue.
 *
 * @see Vector3SubtractValue()
 */
void umkaVector3SubtractValue(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector3* v = (Vector3*)&params[2];
    float sub = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector3), NULL);
    Vector3 out = Vector3SubtractValue(*v, sub);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector3));
}

/**
 * Umka bindings for Vector3Scale.
 *
 * @see Vector3Scale()
 */
void umkaVector3Scale(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector3* v = (Vector3*)&params[2];
    float scalar = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector3), NULL);
    Vector3 out = Vector3Scale(*v, scalar);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector3));
}

/**
 * Umka bindings for Vector3Multiply.
 *
 * @see Vector3Multiply()
 */
void umkaVector3Multiply(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector3* v1 = (Vector3*)&params[2];
    Vector3* v2 = (Vector3*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector3), NULL);
    Vector3 out = Vector3Multiply(*v1, *v2);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector3));
}

/**
 * Umka bindings for Vector3CrossProduct.
 *
 * @see Vector3CrossProduct()
 */
void umkaVector3CrossProduct(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector3* v1 = (Vector3*)&params[2];
    Vector3* v2 = (Vector3*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector3), NULL);
    Vector3 out = Vector3CrossProduct(*v1, *v2);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector3));
}

/**
 * Umka bindings for Vector3Perpendicular.
 *
 * @see Vector3Perpendicular()
 */
void umkaVector3Perpendicular(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector3* v = (Vector3*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector3), NULL);
    Vector3 out = Vector3Perpendicular(*v);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector3));
}

/**
 * Umka bindings for Vector3Length.
 *
 * @see Vector3Length()
 */
void umkaVector3Length(UmkaStackSlot *params, UmkaStackSlot *result) {
    const Vector3* v = (const Vector3*)&params[0];
    result->real32Val = Vector3Length(*v);
}

/**
 * Umka bindings for Vector3LengthSqr.
 *
 * @see Vector3LengthSqr()
 */
void umkaVector3LengthSqr(UmkaStackSlot *params, UmkaStackSlot *result) {
    const Vector3* v = (const Vector3*)&params[0];
    result->real32Val = Vector3LengthSqr(*v);
}

/**
 * Umka bindings for Vector3DotProduct.
 *
 * @see Vector3DotProduct()
 */
void umkaVector3DotProduct(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector3* v1 = (Vector3*)&params[1];
    Vector3* v2 = (Vector3*)&params[0];
    result->real32Val = Vector3DotProduct(*v1, *v2);
}

/**
 * Umka bindings for Vector3Distance.
 *
 * @see Vector3Distance()
 */
void umkaVector3Distance(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector3* v1 = (Vector3*)&params[1];
    Vector3* v2 = (Vector3*)&params[0];
    result->real32Val = Vector3Distance(*v1, *v2);
}

/**
 * Umka bindings for Vector3DistanceSqr.
 *
 * @see Vector3DistanceSqr()
 */
void umkaVector3DistanceSqr(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector3* v1 = (Vector3*)&params[1];
    Vector3* v2 = (Vector3*)&params[0];
    result->real32Val = Vector3DistanceSqr(*v1, *v2);
}

/**
 * Umka bindings for Vector3Angle.
 *
 * @see Vector3Angle()
 */
void umkaVector3Angle(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector3* v1 = (Vector3*)&params[1];
    Vector3* v2 = (Vector3*)&params[0];
    result->real32Val = Vector3Angle(*v1, *v2);
}

/**
 * Umka bindings for Vector3Negate.
 *
 * @see Vector3Negate()
 */
void umkaVector3Negate(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector3* v = (Vector3*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector3), NULL);
    Vector3 out = Vector3Negate(*v);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector3));
}

/**
 * Umka bindings for Vector3Divide.
 *
 * @see Vector3Divide()
 */
void umkaVector3Divide(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector3* v1 = (Vector3*)&params[2];
    Vector3* v2 = (Vector3*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector3), NULL);
    Vector3 out = Vector3Divide(*v1, *v2);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector3));
}

/**
 * Umka bindings for Vector3Normalize.
 *
 * @see Vector3Normalize()
 */
void umkaVector3Normalize(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector3* v = (Vector3*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector3), NULL);
    Vector3 out = Vector3Normalize(*v);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector3));
}

/**
 * Umka bindings for Vector3OrthoNormalize.
 *
 * @see Vector3OrthoNormalize()
 */
void umkaVector3OrthoNormalize(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector3 * v1 = (Vector3 *)params[1].ptrVal;
    Vector3 * v2 = (Vector3 *)params[0].ptrVal;
    Vector3OrthoNormalize(v1, v2);
}

/**
 * Umka bindings for Vector3Transform.
 *
 * @see Vector3Transform()
 */
void umkaVector3Transform(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector3* v = (Vector3*)&params[2];
    Matrix* mat = (Matrix*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector3), NULL);
    Vector3 out = Vector3Transform(*v, *mat);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector3));
}

/**
 * Umka bindings for Vector3RotateByQuaternion.
 *
 * @see Vector3RotateByQuaternion()
 */
void umkaVector3RotateByQuaternion(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector3* v = (Vector3*)&params[2];
    Quaternion* q = (Quaternion*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector3), NULL);
    Vector3 out = Vector3RotateByQuaternion(*v, *q);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector3));
}

/**
 * Umka bindings for Vector3RotateByAxisAngle.
 *
 * @see Vector3RotateByAxisAngle()
 */
void umkaVector3RotateByAxisAngle(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector3* v = (Vector3*)&params[3];
    Vector3* axis = (Vector3*)&params[2];
    float angle = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector3), NULL);
    Vector3 out = Vector3RotateByAxisAngle(*v, *axis, angle);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector3));
}

/**
 * Umka bindings for Vector3Lerp.
 *
 * @see Vector3Lerp()
 */
void umkaVector3Lerp(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector3* v1 = (Vector3*)&params[3];
    Vector3* v2 = (Vector3*)&params[2];
    float amount = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector3), NULL);
    Vector3 out = Vector3Lerp(*v1, *v2, amount);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector3));
}

/**
 * Umka bindings for Vector3Reflect.
 *
 * @see Vector3Reflect()
 */
void umkaVector3Reflect(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector3* v = (Vector3*)&params[2];
    Vector3* normal = (Vector3*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector3), NULL);
    Vector3 out = Vector3Reflect(*v, *normal);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector3));
}

/**
 * Umka bindings for Vector3Min.
 *
 * @see Vector3Min()
 */
void umkaVector3Min(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector3* v1 = (Vector3*)&params[2];
    Vector3* v2 = (Vector3*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector3), NULL);
    Vector3 out = Vector3Min(*v1, *v2);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector3));
}

/**
 * Umka bindings for Vector3Max.
 *
 * @see Vector3Max()
 */
void umkaVector3Max(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector3* v1 = (Vector3*)&params[2];
    Vector3* v2 = (Vector3*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector3), NULL);
    Vector3 out = Vector3Max(*v1, *v2);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector3));
}

/**
 * Umka bindings for Vector3Barycenter.
 *
 * @see Vector3Barycenter()
 */
void umkaVector3Barycenter(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector3* p = (Vector3*)&params[4];
    Vector3* a = (Vector3*)&params[3];
    Vector3* b = (Vector3*)&params[2];
    Vector3* c = (Vector3*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector3), NULL);
    Vector3 out = Vector3Barycenter(*p, *a, *b, *c);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector3));
}

/**
 * Umka bindings for Vector3Unproject.
 *
 * @see Vector3Unproject()
 */
void umkaVector3Unproject(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector3* source = (Vector3*)&params[3];
    Matrix* projection = (Matrix*)&params[2];
    Matrix* view = (Matrix*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector3), NULL);
    Vector3 out = Vector3Unproject(*source, *projection, *view);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector3));
}

/**
 * Umka bindings for Vector3ToFloatV.
 *
 * @see Vector3ToFloatV()
 */
void umkaVector3ToFloatV(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector3* v = (Vector3*)&params[0];
    /* TODO: Unknown type float3 */Vector3ToFloatV(*v);
}

/**
 * Umka bindings for Vector3Invert.
 *
 * @see Vector3Invert()
 */
void umkaVector3Invert(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector3* v = (Vector3*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector3), NULL);
    Vector3 out = Vector3Invert(*v);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector3));
}

/**
 * Umka bindings for Vector3Clamp.
 *
 * @see Vector3Clamp()
 */
void umkaVector3Clamp(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector3* v = (Vector3*)&params[3];
    Vector3* min = (Vector3*)&params[2];
    Vector3* max = (Vector3*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector3), NULL);
    Vector3 out = Vector3Clamp(*v, *min, *max);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector3));
}

/**
 * Umka bindings for Vector3ClampValue.
 *
 * @see Vector3ClampValue()
 */
void umkaVector3ClampValue(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector3* v = (Vector3*)&params[3];
    float min = params[2].real32Val;
    float max = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector3), NULL);
    Vector3 out = Vector3ClampValue(*v, min, max);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector3));
}

/**
 * Umka bindings for Vector3Equals.
 *
 * @see Vector3Equals()
 */
void umkaVector3Equals(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector3* p = (Vector3*)&params[1];
    Vector3* q = (Vector3*)&params[0];
    result->intVal = Vector3Equals(*p, *q);
}

/**
 * Umka bindings for Vector3Refract.
 *
 * @see Vector3Refract()
 */
void umkaVector3Refract(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector3* v = (Vector3*)&params[3];
    Vector3* n = (Vector3*)&params[2];
    float r = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector3), NULL);
    Vector3 out = Vector3Refract(*v, *n, r);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector3));
}

/**
 * Umka bindings for MatrixDeterminant.
 *
 * @see MatrixDeterminant()
 */
void umkaMatrixDeterminant(UmkaStackSlot *params, UmkaStackSlot *result) {
    Matrix* mat = (Matrix*)&params[0];
    result->real32Val = MatrixDeterminant(*mat);
}

/**
 * Umka bindings for MatrixTrace.
 *
 * @see MatrixTrace()
 */
void umkaMatrixTrace(UmkaStackSlot *params, UmkaStackSlot *result) {
    Matrix* mat = (Matrix*)&params[0];
    result->real32Val = MatrixTrace(*mat);
}

/**
 * Umka bindings for MatrixTranspose.
 *
 * @see MatrixTranspose()
 */
void umkaMatrixTranspose(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Matrix* mat = (Matrix*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Matrix), NULL);
    Matrix out = MatrixTranspose(*mat);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Matrix));
}

/**
 * Umka bindings for MatrixInvert.
 *
 * @see MatrixInvert()
 */
void umkaMatrixInvert(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Matrix* mat = (Matrix*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Matrix), NULL);
    Matrix out = MatrixInvert(*mat);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Matrix));
}

/**
 * Umka bindings for MatrixIdentity.
 *
 * @see MatrixIdentity()
 */
void umkaMatrixIdentity(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Matrix), NULL);
    Matrix out = MatrixIdentity();
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Matrix));
}

/**
 * Umka bindings for MatrixAdd.
 *
 * @see MatrixAdd()
 */
void umkaMatrixAdd(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Matrix* left = (Matrix*)&params[2];
    Matrix* right = (Matrix*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Matrix), NULL);
    Matrix out = MatrixAdd(*left, *right);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Matrix));
}

/**
 * Umka bindings for MatrixSubtract.
 *
 * @see MatrixSubtract()
 */
void umkaMatrixSubtract(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Matrix* left = (Matrix*)&params[2];
    Matrix* right = (Matrix*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Matrix), NULL);
    Matrix out = MatrixSubtract(*left, *right);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Matrix));
}

/**
 * Umka bindings for MatrixMultiply.
 *
 * @see MatrixMultiply()
 */
void umkaMatrixMultiply(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Matrix* left = (Matrix*)&params[2];
    Matrix* right = (Matrix*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Matrix), NULL);
    Matrix out = MatrixMultiply(*left, *right);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Matrix));
}

/**
 * Umka bindings for MatrixTranslate.
 *
 * @see MatrixTranslate()
 */
void umkaMatrixTranslate(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    float x = params[3].real32Val;
    float y = params[2].real32Val;
    float z = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Matrix), NULL);
    Matrix out = MatrixTranslate(x, y, z);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Matrix));
}

/**
 * Umka bindings for MatrixRotate.
 *
 * @see MatrixRotate()
 */
void umkaMatrixRotate(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector3* axis = (Vector3*)&params[2];
    float angle = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Matrix), NULL);
    Matrix out = MatrixRotate(*axis, angle);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Matrix));
}

/**
 * Umka bindings for MatrixRotateX.
 *
 * @see MatrixRotateX()
 */
void umkaMatrixRotateX(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    float angle = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Matrix), NULL);
    Matrix out = MatrixRotateX(angle);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Matrix));
}

/**
 * Umka bindings for MatrixRotateY.
 *
 * @see MatrixRotateY()
 */
void umkaMatrixRotateY(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    float angle = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Matrix), NULL);
    Matrix out = MatrixRotateY(angle);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Matrix));
}

/**
 * Umka bindings for MatrixRotateZ.
 *
 * @see MatrixRotateZ()
 */
void umkaMatrixRotateZ(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    float angle = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Matrix), NULL);
    Matrix out = MatrixRotateZ(angle);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Matrix));
}

/**
 * Umka bindings for MatrixRotateXYZ.
 *
 * @see MatrixRotateXYZ()
 */
void umkaMatrixRotateXYZ(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector3* angle = (Vector3*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Matrix), NULL);
    Matrix out = MatrixRotateXYZ(*angle);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Matrix));
}

/**
 * Umka bindings for MatrixRotateZYX.
 *
 * @see MatrixRotateZYX()
 */
void umkaMatrixRotateZYX(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector3* angle = (Vector3*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Matrix), NULL);
    Matrix out = MatrixRotateZYX(*angle);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Matrix));
}

/**
 * Umka bindings for MatrixScale.
 *
 * @see MatrixScale()
 */
void umkaMatrixScale(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    float x = params[3].real32Val;
    float y = params[2].real32Val;
    float z = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Matrix), NULL);
    Matrix out = MatrixScale(x, y, z);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Matrix));
}

/**
 * Umka bindings for MatrixFrustum.
 *
 * @see MatrixFrustum()
 */
void umkaMatrixFrustum(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    double left = params[6].realVal;
    double right = params[5].realVal;
    double bottom = params[4].realVal;
    double top = params[3].realVal;
    double near = params[2].realVal;
    double far = params[1].realVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Matrix), NULL);
    Matrix out = MatrixFrustum(left, right, bottom, top, near, far);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Matrix));
}

/**
 * Umka bindings for MatrixPerspective.
 *
 * @see MatrixPerspective()
 */
void umkaMatrixPerspective(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    double fovy = params[4].realVal;
    double aspect = params[3].realVal;
    double near = params[2].realVal;
    double far = params[1].realVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Matrix), NULL);
    Matrix out = MatrixPerspective(fovy, aspect, near, far);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Matrix));
}

/**
 * Umka bindings for MatrixOrtho.
 *
 * @see MatrixOrtho()
 */
void umkaMatrixOrtho(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    double left = params[6].realVal;
    double right = params[5].realVal;
    double bottom = params[4].realVal;
    double top = params[3].realVal;
    double near = params[2].realVal;
    double far = params[1].realVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Matrix), NULL);
    Matrix out = MatrixOrtho(left, right, bottom, top, near, far);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Matrix));
}

/**
 * Umka bindings for MatrixLookAt.
 *
 * @see MatrixLookAt()
 */
void umkaMatrixLookAt(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector3* eye = (Vector3*)&params[3];
    Vector3* target = (Vector3*)&params[2];
    Vector3* up = (Vector3*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Matrix), NULL);
    Matrix out = MatrixLookAt(*eye, *target, *up);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Matrix));
}

/**
 * Umka bindings for MatrixToFloatV.
 *
 * @see MatrixToFloatV()
 */
void umkaMatrixToFloatV(UmkaStackSlot *params, UmkaStackSlot *result) {
    Matrix* mat = (Matrix*)&params[0];
    /* TODO: Unknown type float16 */MatrixToFloatV(*mat);
}

/**
 * Umka bindings for QuaternionAdd.
 *
 * @see QuaternionAdd()
 */
void umkaQuaternionAdd(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Quaternion* q1 = (Quaternion*)&params[2];
    Quaternion* q2 = (Quaternion*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Quaternion), NULL);
    Quaternion out = QuaternionAdd(*q1, *q2);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Quaternion));
}

/**
 * Umka bindings for QuaternionAddValue.
 *
 * @see QuaternionAddValue()
 */
void umkaQuaternionAddValue(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Quaternion* q = (Quaternion*)&params[2];
    float add = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Quaternion), NULL);
    Quaternion out = QuaternionAddValue(*q, add);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Quaternion));
}

/**
 * Umka bindings for QuaternionSubtract.
 *
 * @see QuaternionSubtract()
 */
void umkaQuaternionSubtract(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Quaternion* q1 = (Quaternion*)&params[2];
    Quaternion* q2 = (Quaternion*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Quaternion), NULL);
    Quaternion out = QuaternionSubtract(*q1, *q2);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Quaternion));
}

/**
 * Umka bindings for QuaternionSubtractValue.
 *
 * @see QuaternionSubtractValue()
 */
void umkaQuaternionSubtractValue(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Quaternion* q = (Quaternion*)&params[2];
    float sub = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Quaternion), NULL);
    Quaternion out = QuaternionSubtractValue(*q, sub);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Quaternion));
}

/**
 * Umka bindings for QuaternionIdentity.
 *
 * @see QuaternionIdentity()
 */
void umkaQuaternionIdentity(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Quaternion), NULL);
    Quaternion out = QuaternionIdentity();
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Quaternion));
}

/**
 * Umka bindings for QuaternionLength.
 *
 * @see QuaternionLength()
 */
void umkaQuaternionLength(UmkaStackSlot *params, UmkaStackSlot *result) {
    Quaternion* q = (Quaternion*)&params[0];
    result->real32Val = QuaternionLength(*q);
}

/**
 * Umka bindings for QuaternionNormalize.
 *
 * @see QuaternionNormalize()
 */
void umkaQuaternionNormalize(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Quaternion* q = (Quaternion*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Quaternion), NULL);
    Quaternion out = QuaternionNormalize(*q);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Quaternion));
}

/**
 * Umka bindings for QuaternionInvert.
 *
 * @see QuaternionInvert()
 */
void umkaQuaternionInvert(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Quaternion* q = (Quaternion*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Quaternion), NULL);
    Quaternion out = QuaternionInvert(*q);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Quaternion));
}

/**
 * Umka bindings for QuaternionMultiply.
 *
 * @see QuaternionMultiply()
 */
void umkaQuaternionMultiply(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Quaternion* q1 = (Quaternion*)&params[2];
    Quaternion* q2 = (Quaternion*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Quaternion), NULL);
    Quaternion out = QuaternionMultiply(*q1, *q2);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Quaternion));
}

/**
 * Umka bindings for QuaternionScale.
 *
 * @see QuaternionScale()
 */
void umkaQuaternionScale(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Quaternion* q = (Quaternion*)&params[2];
    float mul = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Quaternion), NULL);
    Quaternion out = QuaternionScale(*q, mul);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Quaternion));
}

/**
 * Umka bindings for QuaternionDivide.
 *
 * @see QuaternionDivide()
 */
void umkaQuaternionDivide(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Quaternion* q1 = (Quaternion*)&params[2];
    Quaternion* q2 = (Quaternion*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Quaternion), NULL);
    Quaternion out = QuaternionDivide(*q1, *q2);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Quaternion));
}

/**
 * Umka bindings for QuaternionLerp.
 *
 * @see QuaternionLerp()
 */
void umkaQuaternionLerp(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Quaternion* q1 = (Quaternion*)&params[3];
    Quaternion* q2 = (Quaternion*)&params[2];
    float amount = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Quaternion), NULL);
    Quaternion out = QuaternionLerp(*q1, *q2, amount);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Quaternion));
}

/**
 * Umka bindings for QuaternionNlerp.
 *
 * @see QuaternionNlerp()
 */
void umkaQuaternionNlerp(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Quaternion* q1 = (Quaternion*)&params[3];
    Quaternion* q2 = (Quaternion*)&params[2];
    float amount = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Quaternion), NULL);
    Quaternion out = QuaternionNlerp(*q1, *q2, amount);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Quaternion));
}

/**
 * Umka bindings for QuaternionSlerp.
 *
 * @see QuaternionSlerp()
 */
void umkaQuaternionSlerp(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Quaternion* q1 = (Quaternion*)&params[3];
    Quaternion* q2 = (Quaternion*)&params[2];
    float amount = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Quaternion), NULL);
    Quaternion out = QuaternionSlerp(*q1, *q2, amount);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Quaternion));
}

/**
 * Umka bindings for QuaternionFromVector3ToVector3.
 *
 * @see QuaternionFromVector3ToVector3()
 */
void umkaQuaternionFromVector3ToVector3(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector3* from = (Vector3*)&params[2];
    Vector3* to = (Vector3*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Quaternion), NULL);
    Quaternion out = QuaternionFromVector3ToVector3(*from, *to);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Quaternion));
}

/**
 * Umka bindings for QuaternionFromMatrix.
 *
 * @see QuaternionFromMatrix()
 */
void umkaQuaternionFromMatrix(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Matrix* mat = (Matrix*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Quaternion), NULL);
    Quaternion out = QuaternionFromMatrix(*mat);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Quaternion));
}

/**
 * Umka bindings for QuaternionToMatrix.
 *
 * @see QuaternionToMatrix()
 */
void umkaQuaternionToMatrix(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Quaternion* q = (Quaternion*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Matrix), NULL);
    Matrix out = QuaternionToMatrix(*q);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Matrix));
}

/**
 * Umka bindings for QuaternionFromAxisAngle.
 *
 * @see QuaternionFromAxisAngle()
 */
void umkaQuaternionFromAxisAngle(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector3* axis = (Vector3*)&params[2];
    float angle = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Quaternion), NULL);
    Quaternion out = QuaternionFromAxisAngle(*axis, angle);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Quaternion));
}

/**
 * Umka bindings for QuaternionToAxisAngle.
 *
 * @see QuaternionToAxisAngle()
 */
void umkaQuaternionToAxisAngle(UmkaStackSlot *params, UmkaStackSlot *result) {
    Quaternion* q = (Quaternion*)&params[2];
    Vector3 * outAxis = (Vector3 *)params[1].ptrVal;
    float * outAngle = (float *)params[0].ptrVal;
    QuaternionToAxisAngle(*q, outAxis, outAngle);
}

/**
 * Umka bindings for QuaternionFromEuler.
 *
 * @see QuaternionFromEuler()
 */
void umkaQuaternionFromEuler(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    float pitch = params[3].real32Val;
    float yaw = params[2].real32Val;
    float roll = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Quaternion), NULL);
    Quaternion out = QuaternionFromEuler(pitch, yaw, roll);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Quaternion));
}

/**
 * Umka bindings for QuaternionToEuler.
 *
 * @see QuaternionToEuler()
 */
void umkaQuaternionToEuler(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Quaternion* q = (Quaternion*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector3), NULL);
    Vector3 out = QuaternionToEuler(*q);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector3));
}

/**
 * Umka bindings for QuaternionTransform.
 *
 * @see QuaternionTransform()
 */
void umkaQuaternionTransform(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Quaternion* q = (Quaternion*)&params[2];
    Matrix* mat = (Matrix*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Quaternion), NULL);
    Quaternion out = QuaternionTransform(*q, *mat);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Quaternion));
}

/**
 * Umka bindings for QuaternionEquals.
 *
 * @see QuaternionEquals()
 */
void umkaQuaternionEquals(UmkaStackSlot *params, UmkaStackSlot *result) {
    Quaternion* p = (Quaternion*)&params[1];
    Quaternion* q = (Quaternion*)&params[0];
    result->intVal = QuaternionEquals(*p, *q);
}


/**
 * Umka implementation for TraceLog(). This is manually implemented.
 *
 * @see TraceLog()
 */
void umkaTraceLog(UmkaStackSlot *params, UmkaStackSlot *result) {
    int logType = params[1].intVal;
    const char* message = (const char*)params[0].ptrVal;
    TraceLog(logType, "%s", message);
}

/**
 * Adds the raylib module to the given Umka instance.
 *
 * @param umka The Umka environment to add the raylib module to.
 *
 * @return TRUE when the raylib module is successfully added, FALSE otherwise.
 */
bool umkaAddRaylib(void *umka) {
    // TraceLog() -- Manually implemented.
    if (!umkaAddFunc(umka, "TraceLog", &umkaTraceLog)) {
        return false;
    }

    // InitWindow()
    if (!umkaAddFunc(umka, "InitWindow", &umkaInitWindow)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function InitWindow()");
        return false;
    }
    // WindowShouldClose()
    if (!umkaAddFunc(umka, "WindowShouldClose", &umkaWindowShouldClose)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function WindowShouldClose()");
        return false;
    }
    // CloseWindow()
    if (!umkaAddFunc(umka, "CloseWindow", &umkaCloseWindow)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function CloseWindow()");
        return false;
    }
    // IsWindowReady()
    if (!umkaAddFunc(umka, "IsWindowReady", &umkaIsWindowReady)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function IsWindowReady()");
        return false;
    }
    // IsWindowFullscreen()
    if (!umkaAddFunc(umka, "IsWindowFullscreen", &umkaIsWindowFullscreen)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function IsWindowFullscreen()");
        return false;
    }
    // IsWindowHidden()
    if (!umkaAddFunc(umka, "IsWindowHidden", &umkaIsWindowHidden)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function IsWindowHidden()");
        return false;
    }
    // IsWindowMinimized()
    if (!umkaAddFunc(umka, "IsWindowMinimized", &umkaIsWindowMinimized)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function IsWindowMinimized()");
        return false;
    }
    // IsWindowMaximized()
    if (!umkaAddFunc(umka, "IsWindowMaximized", &umkaIsWindowMaximized)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function IsWindowMaximized()");
        return false;
    }
    // IsWindowFocused()
    if (!umkaAddFunc(umka, "IsWindowFocused", &umkaIsWindowFocused)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function IsWindowFocused()");
        return false;
    }
    // IsWindowResized()
    if (!umkaAddFunc(umka, "IsWindowResized", &umkaIsWindowResized)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function IsWindowResized()");
        return false;
    }
    // IsWindowState()
    if (!umkaAddFunc(umka, "IsWindowState", &umkaIsWindowState)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function IsWindowState()");
        return false;
    }
    // SetWindowState()
    if (!umkaAddFunc(umka, "SetWindowState", &umkaSetWindowState)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetWindowState()");
        return false;
    }
    // ClearWindowState()
    if (!umkaAddFunc(umka, "ClearWindowState", &umkaClearWindowState)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ClearWindowState()");
        return false;
    }
    // ToggleFullscreen()
    if (!umkaAddFunc(umka, "ToggleFullscreen", &umkaToggleFullscreen)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ToggleFullscreen()");
        return false;
    }
    // MaximizeWindow()
    if (!umkaAddFunc(umka, "MaximizeWindow", &umkaMaximizeWindow)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function MaximizeWindow()");
        return false;
    }
    // MinimizeWindow()
    if (!umkaAddFunc(umka, "MinimizeWindow", &umkaMinimizeWindow)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function MinimizeWindow()");
        return false;
    }
    // RestoreWindow()
    if (!umkaAddFunc(umka, "RestoreWindow", &umkaRestoreWindow)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function RestoreWindow()");
        return false;
    }
    // SetWindowIcon()
    if (!umkaAddFunc(umka, "SetWindowIcon", &umkaSetWindowIcon)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetWindowIcon()");
        return false;
    }
    // SetWindowTitle()
    if (!umkaAddFunc(umka, "SetWindowTitle", &umkaSetWindowTitle)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetWindowTitle()");
        return false;
    }
    // SetWindowPosition()
    if (!umkaAddFunc(umka, "SetWindowPosition", &umkaSetWindowPosition)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetWindowPosition()");
        return false;
    }
    // SetWindowMonitor()
    if (!umkaAddFunc(umka, "SetWindowMonitor", &umkaSetWindowMonitor)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetWindowMonitor()");
        return false;
    }
    // SetWindowMinSize()
    if (!umkaAddFunc(umka, "SetWindowMinSize", &umkaSetWindowMinSize)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetWindowMinSize()");
        return false;
    }
    // SetWindowSize()
    if (!umkaAddFunc(umka, "SetWindowSize", &umkaSetWindowSize)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetWindowSize()");
        return false;
    }
    // SetWindowOpacity()
    if (!umkaAddFunc(umka, "SetWindowOpacity", &umkaSetWindowOpacity)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetWindowOpacity()");
        return false;
    }
    // GetWindowHandle()
    if (!umkaAddFunc(umka, "GetWindowHandle", &umkaGetWindowHandle)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetWindowHandle()");
        return false;
    }
    // GetScreenWidth()
    if (!umkaAddFunc(umka, "GetScreenWidth", &umkaGetScreenWidth)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetScreenWidth()");
        return false;
    }
    // GetScreenHeight()
    if (!umkaAddFunc(umka, "GetScreenHeight", &umkaGetScreenHeight)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetScreenHeight()");
        return false;
    }
    // GetRenderWidth()
    if (!umkaAddFunc(umka, "GetRenderWidth", &umkaGetRenderWidth)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetRenderWidth()");
        return false;
    }
    // GetRenderHeight()
    if (!umkaAddFunc(umka, "GetRenderHeight", &umkaGetRenderHeight)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetRenderHeight()");
        return false;
    }
    // GetMonitorCount()
    if (!umkaAddFunc(umka, "GetMonitorCount", &umkaGetMonitorCount)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetMonitorCount()");
        return false;
    }
    // GetCurrentMonitor()
    if (!umkaAddFunc(umka, "GetCurrentMonitor", &umkaGetCurrentMonitor)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetCurrentMonitor()");
        return false;
    }
    // GetMonitorPosition()
    if (!umkaAddFunc(umka, "GetMonitorPosition", &umkaGetMonitorPosition)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetMonitorPosition()");
        return false;
    }
    // GetMonitorWidth()
    if (!umkaAddFunc(umka, "GetMonitorWidth", &umkaGetMonitorWidth)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetMonitorWidth()");
        return false;
    }
    // GetMonitorHeight()
    if (!umkaAddFunc(umka, "GetMonitorHeight", &umkaGetMonitorHeight)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetMonitorHeight()");
        return false;
    }
    // GetMonitorPhysicalWidth()
    if (!umkaAddFunc(umka, "GetMonitorPhysicalWidth", &umkaGetMonitorPhysicalWidth)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetMonitorPhysicalWidth()");
        return false;
    }
    // GetMonitorPhysicalHeight()
    if (!umkaAddFunc(umka, "GetMonitorPhysicalHeight", &umkaGetMonitorPhysicalHeight)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetMonitorPhysicalHeight()");
        return false;
    }
    // GetMonitorRefreshRate()
    if (!umkaAddFunc(umka, "GetMonitorRefreshRate", &umkaGetMonitorRefreshRate)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetMonitorRefreshRate()");
        return false;
    }
    // GetWindowPosition()
    if (!umkaAddFunc(umka, "GetWindowPosition", &umkaGetWindowPosition)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetWindowPosition()");
        return false;
    }
    // GetWindowScaleDPI()
    if (!umkaAddFunc(umka, "GetWindowScaleDPI", &umkaGetWindowScaleDPI)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetWindowScaleDPI()");
        return false;
    }
    // GetMonitorName()
    if (!umkaAddFunc(umka, "GetMonitorName", &umkaGetMonitorName)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetMonitorName()");
        return false;
    }
    // SetClipboardText()
    if (!umkaAddFunc(umka, "SetClipboardText", &umkaSetClipboardText)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetClipboardText()");
        return false;
    }
    // GetClipboardText()
    if (!umkaAddFunc(umka, "GetClipboardText", &umkaGetClipboardText)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetClipboardText()");
        return false;
    }
    // EnableEventWaiting()
    if (!umkaAddFunc(umka, "EnableEventWaiting", &umkaEnableEventWaiting)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function EnableEventWaiting()");
        return false;
    }
    // DisableEventWaiting()
    if (!umkaAddFunc(umka, "DisableEventWaiting", &umkaDisableEventWaiting)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DisableEventWaiting()");
        return false;
    }
    // SwapScreenBuffer()
    if (!umkaAddFunc(umka, "SwapScreenBuffer", &umkaSwapScreenBuffer)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SwapScreenBuffer()");
        return false;
    }
    // PollInputEvents()
    if (!umkaAddFunc(umka, "PollInputEvents", &umkaPollInputEvents)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function PollInputEvents()");
        return false;
    }
    // WaitTime()
    if (!umkaAddFunc(umka, "WaitTime", &umkaWaitTime)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function WaitTime()");
        return false;
    }
    // ShowCursor()
    if (!umkaAddFunc(umka, "ShowCursor", &umkaShowCursor)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ShowCursor()");
        return false;
    }
    // HideCursor()
    if (!umkaAddFunc(umka, "HideCursor", &umkaHideCursor)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function HideCursor()");
        return false;
    }
    // IsCursorHidden()
    if (!umkaAddFunc(umka, "IsCursorHidden", &umkaIsCursorHidden)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function IsCursorHidden()");
        return false;
    }
    // EnableCursor()
    if (!umkaAddFunc(umka, "EnableCursor", &umkaEnableCursor)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function EnableCursor()");
        return false;
    }
    // DisableCursor()
    if (!umkaAddFunc(umka, "DisableCursor", &umkaDisableCursor)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DisableCursor()");
        return false;
    }
    // IsCursorOnScreen()
    if (!umkaAddFunc(umka, "IsCursorOnScreen", &umkaIsCursorOnScreen)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function IsCursorOnScreen()");
        return false;
    }
    // ClearBackground()
    if (!umkaAddFunc(umka, "ClearBackground", &umkaClearBackground)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ClearBackground()");
        return false;
    }
    // BeginDrawing()
    if (!umkaAddFunc(umka, "BeginDrawing", &umkaBeginDrawing)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function BeginDrawing()");
        return false;
    }
    // EndDrawing()
    if (!umkaAddFunc(umka, "EndDrawing", &umkaEndDrawing)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function EndDrawing()");
        return false;
    }
    // BeginMode2D()
    if (!umkaAddFunc(umka, "BeginMode2D", &umkaBeginMode2D)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function BeginMode2D()");
        return false;
    }
    // EndMode2D()
    if (!umkaAddFunc(umka, "EndMode2D", &umkaEndMode2D)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function EndMode2D()");
        return false;
    }
    // BeginMode3D()
    if (!umkaAddFunc(umka, "BeginMode3D", &umkaBeginMode3D)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function BeginMode3D()");
        return false;
    }
    // EndMode3D()
    if (!umkaAddFunc(umka, "EndMode3D", &umkaEndMode3D)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function EndMode3D()");
        return false;
    }
    // BeginTextureMode()
    if (!umkaAddFunc(umka, "BeginTextureMode", &umkaBeginTextureMode)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function BeginTextureMode()");
        return false;
    }
    // EndTextureMode()
    if (!umkaAddFunc(umka, "EndTextureMode", &umkaEndTextureMode)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function EndTextureMode()");
        return false;
    }
    // BeginShaderMode()
    if (!umkaAddFunc(umka, "BeginShaderMode", &umkaBeginShaderMode)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function BeginShaderMode()");
        return false;
    }
    // EndShaderMode()
    if (!umkaAddFunc(umka, "EndShaderMode", &umkaEndShaderMode)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function EndShaderMode()");
        return false;
    }
    // BeginBlendMode()
    if (!umkaAddFunc(umka, "BeginBlendMode", &umkaBeginBlendMode)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function BeginBlendMode()");
        return false;
    }
    // EndBlendMode()
    if (!umkaAddFunc(umka, "EndBlendMode", &umkaEndBlendMode)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function EndBlendMode()");
        return false;
    }
    // BeginScissorMode()
    if (!umkaAddFunc(umka, "BeginScissorMode", &umkaBeginScissorMode)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function BeginScissorMode()");
        return false;
    }
    // EndScissorMode()
    if (!umkaAddFunc(umka, "EndScissorMode", &umkaEndScissorMode)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function EndScissorMode()");
        return false;
    }
    // BeginVrStereoMode()
    if (!umkaAddFunc(umka, "BeginVrStereoMode", &umkaBeginVrStereoMode)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function BeginVrStereoMode()");
        return false;
    }
    // EndVrStereoMode()
    if (!umkaAddFunc(umka, "EndVrStereoMode", &umkaEndVrStereoMode)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function EndVrStereoMode()");
        return false;
    }
    // LoadVrStereoConfig()
    if (!umkaAddFunc(umka, "LoadVrStereoConfig", &umkaLoadVrStereoConfig)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadVrStereoConfig()");
        return false;
    }
    // UnloadVrStereoConfig()
    if (!umkaAddFunc(umka, "UnloadVrStereoConfig", &umkaUnloadVrStereoConfig)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UnloadVrStereoConfig()");
        return false;
    }
    // LoadShader()
    if (!umkaAddFunc(umka, "LoadShader", &umkaLoadShader)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadShader()");
        return false;
    }
    // LoadShaderFromMemory()
    if (!umkaAddFunc(umka, "LoadShaderFromMemory", &umkaLoadShaderFromMemory)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadShaderFromMemory()");
        return false;
    }
    // GetShaderLocation()
    if (!umkaAddFunc(umka, "GetShaderLocation", &umkaGetShaderLocation)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetShaderLocation()");
        return false;
    }
    // GetShaderLocationAttrib()
    if (!umkaAddFunc(umka, "GetShaderLocationAttrib", &umkaGetShaderLocationAttrib)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetShaderLocationAttrib()");
        return false;
    }
    // SetShaderValue()
    if (!umkaAddFunc(umka, "SetShaderValue", &umkaSetShaderValue)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetShaderValue()");
        return false;
    }
    // SetShaderValueV()
    if (!umkaAddFunc(umka, "SetShaderValueV", &umkaSetShaderValueV)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetShaderValueV()");
        return false;
    }
    // SetShaderValueMatrix()
    if (!umkaAddFunc(umka, "SetShaderValueMatrix", &umkaSetShaderValueMatrix)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetShaderValueMatrix()");
        return false;
    }
    // SetShaderValueTexture()
    if (!umkaAddFunc(umka, "SetShaderValueTexture", &umkaSetShaderValueTexture)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetShaderValueTexture()");
        return false;
    }
    // UnloadShader()
    if (!umkaAddFunc(umka, "UnloadShader", &umkaUnloadShader)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UnloadShader()");
        return false;
    }
    // GetMouseRay()
    if (!umkaAddFunc(umka, "GetMouseRay", &umkaGetMouseRay)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetMouseRay()");
        return false;
    }
    // GetCameraMatrix()
    if (!umkaAddFunc(umka, "GetCameraMatrix", &umkaGetCameraMatrix)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetCameraMatrix()");
        return false;
    }
    // GetCameraMatrix2D()
    if (!umkaAddFunc(umka, "GetCameraMatrix2D", &umkaGetCameraMatrix2D)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetCameraMatrix2D()");
        return false;
    }
    // GetWorldToScreen()
    if (!umkaAddFunc(umka, "GetWorldToScreen", &umkaGetWorldToScreen)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetWorldToScreen()");
        return false;
    }
    // GetScreenToWorld2D()
    if (!umkaAddFunc(umka, "GetScreenToWorld2D", &umkaGetScreenToWorld2D)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetScreenToWorld2D()");
        return false;
    }
    // GetWorldToScreenEx()
    if (!umkaAddFunc(umka, "GetWorldToScreenEx", &umkaGetWorldToScreenEx)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetWorldToScreenEx()");
        return false;
    }
    // GetWorldToScreen2D()
    if (!umkaAddFunc(umka, "GetWorldToScreen2D", &umkaGetWorldToScreen2D)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetWorldToScreen2D()");
        return false;
    }
    // SetTargetFPS()
    if (!umkaAddFunc(umka, "SetTargetFPS", &umkaSetTargetFPS)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetTargetFPS()");
        return false;
    }
    // GetFPS()
    if (!umkaAddFunc(umka, "GetFPS", &umkaGetFPS)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetFPS()");
        return false;
    }
    // GetFrameTime()
    if (!umkaAddFunc(umka, "GetFrameTime", &umkaGetFrameTime)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetFrameTime()");
        return false;
    }
    // GetTime()
    if (!umkaAddFunc(umka, "GetTime", &umkaGetTime)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetTime()");
        return false;
    }
    // GetRandomValue()
    if (!umkaAddFunc(umka, "GetRandomValue", &umkaGetRandomValue)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetRandomValue()");
        return false;
    }
    // SetRandomSeed()
    if (!umkaAddFunc(umka, "SetRandomSeed", &umkaSetRandomSeed)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetRandomSeed()");
        return false;
    }
    // TakeScreenshot()
    if (!umkaAddFunc(umka, "TakeScreenshot", &umkaTakeScreenshot)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function TakeScreenshot()");
        return false;
    }
    // SetConfigFlags()
    if (!umkaAddFunc(umka, "SetConfigFlags", &umkaSetConfigFlags)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetConfigFlags()");
        return false;
    }
    // Skipping TraceLog
    // SetTraceLogLevel()
    if (!umkaAddFunc(umka, "SetTraceLogLevel", &umkaSetTraceLogLevel)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetTraceLogLevel()");
        return false;
    }
    // MemAlloc()
    if (!umkaAddFunc(umka, "MemAlloc", &umkaMemAlloc)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function MemAlloc()");
        return false;
    }
    // MemRealloc()
    if (!umkaAddFunc(umka, "MemRealloc", &umkaMemRealloc)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function MemRealloc()");
        return false;
    }
    // MemFree()
    if (!umkaAddFunc(umka, "MemFree", &umkaMemFree)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function MemFree()");
        return false;
    }
    // OpenURL()
    if (!umkaAddFunc(umka, "OpenURL", &umkaOpenURL)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function OpenURL()");
        return false;
    }
    // Skipping SetTraceLogCallback
    // Skipping SetLoadFileDataCallback
    // Skipping SetSaveFileDataCallback
    // Skipping SetLoadFileTextCallback
    // Skipping SetSaveFileTextCallback
    // LoadFileData()
    if (!umkaAddFunc(umka, "LoadFileData", &umkaLoadFileData)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadFileData()");
        return false;
    }
    // UnloadFileData()
    if (!umkaAddFunc(umka, "UnloadFileData", &umkaUnloadFileData)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UnloadFileData()");
        return false;
    }
    // SaveFileData()
    if (!umkaAddFunc(umka, "SaveFileData", &umkaSaveFileData)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SaveFileData()");
        return false;
    }
    // ExportDataAsCode()
    if (!umkaAddFunc(umka, "ExportDataAsCode", &umkaExportDataAsCode)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ExportDataAsCode()");
        return false;
    }
    // LoadFileText()
    if (!umkaAddFunc(umka, "LoadFileText", &umkaLoadFileText)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadFileText()");
        return false;
    }
    // UnloadFileText()
    if (!umkaAddFunc(umka, "UnloadFileText", &umkaUnloadFileText)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UnloadFileText()");
        return false;
    }
    // SaveFileText()
    if (!umkaAddFunc(umka, "SaveFileText", &umkaSaveFileText)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SaveFileText()");
        return false;
    }
    // FileExists()
    if (!umkaAddFunc(umka, "FileExists", &umkaFileExists)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function FileExists()");
        return false;
    }
    // DirectoryExists()
    if (!umkaAddFunc(umka, "DirectoryExists", &umkaDirectoryExists)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DirectoryExists()");
        return false;
    }
    // IsFileExtension()
    if (!umkaAddFunc(umka, "IsFileExtension", &umkaIsFileExtension)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function IsFileExtension()");
        return false;
    }
    // GetFileLength()
    if (!umkaAddFunc(umka, "GetFileLength", &umkaGetFileLength)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetFileLength()");
        return false;
    }
    // GetFileExtension()
    if (!umkaAddFunc(umka, "GetFileExtension", &umkaGetFileExtension)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetFileExtension()");
        return false;
    }
    // GetFileName()
    if (!umkaAddFunc(umka, "GetFileName", &umkaGetFileName)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetFileName()");
        return false;
    }
    // GetFileNameWithoutExt()
    if (!umkaAddFunc(umka, "GetFileNameWithoutExt", &umkaGetFileNameWithoutExt)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetFileNameWithoutExt()");
        return false;
    }
    // GetDirectoryPath()
    if (!umkaAddFunc(umka, "GetDirectoryPath", &umkaGetDirectoryPath)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetDirectoryPath()");
        return false;
    }
    // GetPrevDirectoryPath()
    if (!umkaAddFunc(umka, "GetPrevDirectoryPath", &umkaGetPrevDirectoryPath)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetPrevDirectoryPath()");
        return false;
    }
    // GetWorkingDirectory()
    if (!umkaAddFunc(umka, "GetWorkingDirectory", &umkaGetWorkingDirectory)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetWorkingDirectory()");
        return false;
    }
    // GetApplicationDirectory()
    if (!umkaAddFunc(umka, "GetApplicationDirectory", &umkaGetApplicationDirectory)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetApplicationDirectory()");
        return false;
    }
    // ChangeDirectory()
    if (!umkaAddFunc(umka, "ChangeDirectory", &umkaChangeDirectory)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ChangeDirectory()");
        return false;
    }
    // IsPathFile()
    if (!umkaAddFunc(umka, "IsPathFile", &umkaIsPathFile)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function IsPathFile()");
        return false;
    }
    // LoadDirectoryFiles()
    if (!umkaAddFunc(umka, "LoadDirectoryFiles", &umkaLoadDirectoryFiles)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadDirectoryFiles()");
        return false;
    }
    // LoadDirectoryFilesEx()
    if (!umkaAddFunc(umka, "LoadDirectoryFilesEx", &umkaLoadDirectoryFilesEx)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadDirectoryFilesEx()");
        return false;
    }
    // UnloadDirectoryFiles()
    if (!umkaAddFunc(umka, "UnloadDirectoryFiles", &umkaUnloadDirectoryFiles)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UnloadDirectoryFiles()");
        return false;
    }
    // IsFileDropped()
    if (!umkaAddFunc(umka, "IsFileDropped", &umkaIsFileDropped)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function IsFileDropped()");
        return false;
    }
    // LoadDroppedFiles()
    if (!umkaAddFunc(umka, "LoadDroppedFiles", &umkaLoadDroppedFiles)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadDroppedFiles()");
        return false;
    }
    // UnloadDroppedFiles()
    if (!umkaAddFunc(umka, "UnloadDroppedFiles", &umkaUnloadDroppedFiles)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UnloadDroppedFiles()");
        return false;
    }
    // GetFileModTime()
    if (!umkaAddFunc(umka, "GetFileModTime", &umkaGetFileModTime)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetFileModTime()");
        return false;
    }
    // CompressData()
    if (!umkaAddFunc(umka, "CompressData", &umkaCompressData)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function CompressData()");
        return false;
    }
    // DecompressData()
    if (!umkaAddFunc(umka, "DecompressData", &umkaDecompressData)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DecompressData()");
        return false;
    }
    // EncodeDataBase64()
    if (!umkaAddFunc(umka, "EncodeDataBase64", &umkaEncodeDataBase64)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function EncodeDataBase64()");
        return false;
    }
    // DecodeDataBase64()
    if (!umkaAddFunc(umka, "DecodeDataBase64", &umkaDecodeDataBase64)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DecodeDataBase64()");
        return false;
    }
    // IsKeyPressed()
    if (!umkaAddFunc(umka, "IsKeyPressed", &umkaIsKeyPressed)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function IsKeyPressed()");
        return false;
    }
    // IsKeyDown()
    if (!umkaAddFunc(umka, "IsKeyDown", &umkaIsKeyDown)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function IsKeyDown()");
        return false;
    }
    // IsKeyReleased()
    if (!umkaAddFunc(umka, "IsKeyReleased", &umkaIsKeyReleased)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function IsKeyReleased()");
        return false;
    }
    // IsKeyUp()
    if (!umkaAddFunc(umka, "IsKeyUp", &umkaIsKeyUp)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function IsKeyUp()");
        return false;
    }
    // SetExitKey()
    if (!umkaAddFunc(umka, "SetExitKey", &umkaSetExitKey)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetExitKey()");
        return false;
    }
    // GetKeyPressed()
    if (!umkaAddFunc(umka, "GetKeyPressed", &umkaGetKeyPressed)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetKeyPressed()");
        return false;
    }
    // GetCharPressed()
    if (!umkaAddFunc(umka, "GetCharPressed", &umkaGetCharPressed)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetCharPressed()");
        return false;
    }
    // IsGamepadAvailable()
    if (!umkaAddFunc(umka, "IsGamepadAvailable", &umkaIsGamepadAvailable)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function IsGamepadAvailable()");
        return false;
    }
    // GetGamepadName()
    if (!umkaAddFunc(umka, "GetGamepadName", &umkaGetGamepadName)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetGamepadName()");
        return false;
    }
    // IsGamepadButtonPressed()
    if (!umkaAddFunc(umka, "IsGamepadButtonPressed", &umkaIsGamepadButtonPressed)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function IsGamepadButtonPressed()");
        return false;
    }
    // IsGamepadButtonDown()
    if (!umkaAddFunc(umka, "IsGamepadButtonDown", &umkaIsGamepadButtonDown)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function IsGamepadButtonDown()");
        return false;
    }
    // IsGamepadButtonReleased()
    if (!umkaAddFunc(umka, "IsGamepadButtonReleased", &umkaIsGamepadButtonReleased)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function IsGamepadButtonReleased()");
        return false;
    }
    // IsGamepadButtonUp()
    if (!umkaAddFunc(umka, "IsGamepadButtonUp", &umkaIsGamepadButtonUp)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function IsGamepadButtonUp()");
        return false;
    }
    // GetGamepadButtonPressed()
    if (!umkaAddFunc(umka, "GetGamepadButtonPressed", &umkaGetGamepadButtonPressed)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetGamepadButtonPressed()");
        return false;
    }
    // GetGamepadAxisCount()
    if (!umkaAddFunc(umka, "GetGamepadAxisCount", &umkaGetGamepadAxisCount)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetGamepadAxisCount()");
        return false;
    }
    // GetGamepadAxisMovement()
    if (!umkaAddFunc(umka, "GetGamepadAxisMovement", &umkaGetGamepadAxisMovement)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetGamepadAxisMovement()");
        return false;
    }
    // SetGamepadMappings()
    if (!umkaAddFunc(umka, "SetGamepadMappings", &umkaSetGamepadMappings)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetGamepadMappings()");
        return false;
    }
    // IsMouseButtonPressed()
    if (!umkaAddFunc(umka, "IsMouseButtonPressed", &umkaIsMouseButtonPressed)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function IsMouseButtonPressed()");
        return false;
    }
    // IsMouseButtonDown()
    if (!umkaAddFunc(umka, "IsMouseButtonDown", &umkaIsMouseButtonDown)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function IsMouseButtonDown()");
        return false;
    }
    // IsMouseButtonReleased()
    if (!umkaAddFunc(umka, "IsMouseButtonReleased", &umkaIsMouseButtonReleased)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function IsMouseButtonReleased()");
        return false;
    }
    // IsMouseButtonUp()
    if (!umkaAddFunc(umka, "IsMouseButtonUp", &umkaIsMouseButtonUp)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function IsMouseButtonUp()");
        return false;
    }
    // GetMouseX()
    if (!umkaAddFunc(umka, "GetMouseX", &umkaGetMouseX)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetMouseX()");
        return false;
    }
    // GetMouseY()
    if (!umkaAddFunc(umka, "GetMouseY", &umkaGetMouseY)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetMouseY()");
        return false;
    }
    // GetMousePosition()
    if (!umkaAddFunc(umka, "GetMousePosition", &umkaGetMousePosition)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetMousePosition()");
        return false;
    }
    // GetMouseDelta()
    if (!umkaAddFunc(umka, "GetMouseDelta", &umkaGetMouseDelta)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetMouseDelta()");
        return false;
    }
    // SetMousePosition()
    if (!umkaAddFunc(umka, "SetMousePosition", &umkaSetMousePosition)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetMousePosition()");
        return false;
    }
    // SetMouseOffset()
    if (!umkaAddFunc(umka, "SetMouseOffset", &umkaSetMouseOffset)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetMouseOffset()");
        return false;
    }
    // SetMouseScale()
    if (!umkaAddFunc(umka, "SetMouseScale", &umkaSetMouseScale)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetMouseScale()");
        return false;
    }
    // GetMouseWheelMove()
    if (!umkaAddFunc(umka, "GetMouseWheelMove", &umkaGetMouseWheelMove)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetMouseWheelMove()");
        return false;
    }
    // GetMouseWheelMoveV()
    if (!umkaAddFunc(umka, "GetMouseWheelMoveV", &umkaGetMouseWheelMoveV)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetMouseWheelMoveV()");
        return false;
    }
    // SetMouseCursor()
    if (!umkaAddFunc(umka, "SetMouseCursor", &umkaSetMouseCursor)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetMouseCursor()");
        return false;
    }
    // GetTouchX()
    if (!umkaAddFunc(umka, "GetTouchX", &umkaGetTouchX)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetTouchX()");
        return false;
    }
    // GetTouchY()
    if (!umkaAddFunc(umka, "GetTouchY", &umkaGetTouchY)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetTouchY()");
        return false;
    }
    // GetTouchPosition()
    if (!umkaAddFunc(umka, "GetTouchPosition", &umkaGetTouchPosition)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetTouchPosition()");
        return false;
    }
    // GetTouchPointId()
    if (!umkaAddFunc(umka, "GetTouchPointId", &umkaGetTouchPointId)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetTouchPointId()");
        return false;
    }
    // GetTouchPointCount()
    if (!umkaAddFunc(umka, "GetTouchPointCount", &umkaGetTouchPointCount)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetTouchPointCount()");
        return false;
    }
    // SetGesturesEnabled()
    if (!umkaAddFunc(umka, "SetGesturesEnabled", &umkaSetGesturesEnabled)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetGesturesEnabled()");
        return false;
    }
    // IsGestureDetected()
    if (!umkaAddFunc(umka, "IsGestureDetected", &umkaIsGestureDetected)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function IsGestureDetected()");
        return false;
    }
    // GetGestureDetected()
    if (!umkaAddFunc(umka, "GetGestureDetected", &umkaGetGestureDetected)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetGestureDetected()");
        return false;
    }
    // GetGestureHoldDuration()
    if (!umkaAddFunc(umka, "GetGestureHoldDuration", &umkaGetGestureHoldDuration)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetGestureHoldDuration()");
        return false;
    }
    // GetGestureDragVector()
    if (!umkaAddFunc(umka, "GetGestureDragVector", &umkaGetGestureDragVector)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetGestureDragVector()");
        return false;
    }
    // GetGestureDragAngle()
    if (!umkaAddFunc(umka, "GetGestureDragAngle", &umkaGetGestureDragAngle)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetGestureDragAngle()");
        return false;
    }
    // GetGesturePinchVector()
    if (!umkaAddFunc(umka, "GetGesturePinchVector", &umkaGetGesturePinchVector)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetGesturePinchVector()");
        return false;
    }
    // GetGesturePinchAngle()
    if (!umkaAddFunc(umka, "GetGesturePinchAngle", &umkaGetGesturePinchAngle)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetGesturePinchAngle()");
        return false;
    }
    // SetCameraMode()
    if (!umkaAddFunc(umka, "SetCameraMode", &umkaSetCameraMode)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetCameraMode()");
        return false;
    }
    // UpdateCamera()
    if (!umkaAddFunc(umka, "UpdateCamera", &umkaUpdateCamera)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UpdateCamera()");
        return false;
    }
    // SetCameraPanControl()
    if (!umkaAddFunc(umka, "SetCameraPanControl", &umkaSetCameraPanControl)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetCameraPanControl()");
        return false;
    }
    // SetCameraAltControl()
    if (!umkaAddFunc(umka, "SetCameraAltControl", &umkaSetCameraAltControl)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetCameraAltControl()");
        return false;
    }
    // SetCameraSmoothZoomControl()
    if (!umkaAddFunc(umka, "SetCameraSmoothZoomControl", &umkaSetCameraSmoothZoomControl)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetCameraSmoothZoomControl()");
        return false;
    }
    // SetCameraMoveControls()
    if (!umkaAddFunc(umka, "SetCameraMoveControls", &umkaSetCameraMoveControls)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetCameraMoveControls()");
        return false;
    }
    // SetShapesTexture()
    if (!umkaAddFunc(umka, "SetShapesTexture", &umkaSetShapesTexture)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetShapesTexture()");
        return false;
    }
    // DrawPixel()
    if (!umkaAddFunc(umka, "DrawPixel", &umkaDrawPixel)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawPixel()");
        return false;
    }
    // DrawPixelV()
    if (!umkaAddFunc(umka, "DrawPixelV", &umkaDrawPixelV)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawPixelV()");
        return false;
    }
    // DrawLine()
    if (!umkaAddFunc(umka, "DrawLine", &umkaDrawLine)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawLine()");
        return false;
    }
    // DrawLineV()
    if (!umkaAddFunc(umka, "DrawLineV", &umkaDrawLineV)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawLineV()");
        return false;
    }
    // DrawLineEx()
    if (!umkaAddFunc(umka, "DrawLineEx", &umkaDrawLineEx)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawLineEx()");
        return false;
    }
    // DrawLineBezier()
    if (!umkaAddFunc(umka, "DrawLineBezier", &umkaDrawLineBezier)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawLineBezier()");
        return false;
    }
    // DrawLineBezierQuad()
    if (!umkaAddFunc(umka, "DrawLineBezierQuad", &umkaDrawLineBezierQuad)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawLineBezierQuad()");
        return false;
    }
    // DrawLineBezierCubic()
    if (!umkaAddFunc(umka, "DrawLineBezierCubic", &umkaDrawLineBezierCubic)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawLineBezierCubic()");
        return false;
    }
    // DrawLineStrip()
    if (!umkaAddFunc(umka, "DrawLineStrip", &umkaDrawLineStrip)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawLineStrip()");
        return false;
    }
    // DrawCircle()
    if (!umkaAddFunc(umka, "DrawCircle", &umkaDrawCircle)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawCircle()");
        return false;
    }
    // DrawCircleSector()
    if (!umkaAddFunc(umka, "DrawCircleSector", &umkaDrawCircleSector)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawCircleSector()");
        return false;
    }
    // DrawCircleSectorLines()
    if (!umkaAddFunc(umka, "DrawCircleSectorLines", &umkaDrawCircleSectorLines)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawCircleSectorLines()");
        return false;
    }
    // DrawCircleGradient()
    if (!umkaAddFunc(umka, "DrawCircleGradient", &umkaDrawCircleGradient)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawCircleGradient()");
        return false;
    }
    // DrawCircleV()
    if (!umkaAddFunc(umka, "DrawCircleV", &umkaDrawCircleV)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawCircleV()");
        return false;
    }
    // DrawCircleLines()
    if (!umkaAddFunc(umka, "DrawCircleLines", &umkaDrawCircleLines)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawCircleLines()");
        return false;
    }
    // DrawEllipse()
    if (!umkaAddFunc(umka, "DrawEllipse", &umkaDrawEllipse)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawEllipse()");
        return false;
    }
    // DrawEllipseLines()
    if (!umkaAddFunc(umka, "DrawEllipseLines", &umkaDrawEllipseLines)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawEllipseLines()");
        return false;
    }
    // DrawRing()
    if (!umkaAddFunc(umka, "DrawRing", &umkaDrawRing)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawRing()");
        return false;
    }
    // DrawRingLines()
    if (!umkaAddFunc(umka, "DrawRingLines", &umkaDrawRingLines)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawRingLines()");
        return false;
    }
    // DrawRectangle()
    if (!umkaAddFunc(umka, "DrawRectangle", &umkaDrawRectangle)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawRectangle()");
        return false;
    }
    // DrawRectangleV()
    if (!umkaAddFunc(umka, "DrawRectangleV", &umkaDrawRectangleV)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawRectangleV()");
        return false;
    }
    // DrawRectangleRec()
    if (!umkaAddFunc(umka, "DrawRectangleRec", &umkaDrawRectangleRec)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawRectangleRec()");
        return false;
    }
    // DrawRectanglePro()
    if (!umkaAddFunc(umka, "DrawRectanglePro", &umkaDrawRectanglePro)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawRectanglePro()");
        return false;
    }
    // DrawRectangleGradientV()
    if (!umkaAddFunc(umka, "DrawRectangleGradientV", &umkaDrawRectangleGradientV)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawRectangleGradientV()");
        return false;
    }
    // DrawRectangleGradientH()
    if (!umkaAddFunc(umka, "DrawRectangleGradientH", &umkaDrawRectangleGradientH)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawRectangleGradientH()");
        return false;
    }
    // DrawRectangleGradientEx()
    if (!umkaAddFunc(umka, "DrawRectangleGradientEx", &umkaDrawRectangleGradientEx)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawRectangleGradientEx()");
        return false;
    }
    // DrawRectangleLines()
    if (!umkaAddFunc(umka, "DrawRectangleLines", &umkaDrawRectangleLines)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawRectangleLines()");
        return false;
    }
    // DrawRectangleLinesEx()
    if (!umkaAddFunc(umka, "DrawRectangleLinesEx", &umkaDrawRectangleLinesEx)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawRectangleLinesEx()");
        return false;
    }
    // DrawRectangleRounded()
    if (!umkaAddFunc(umka, "DrawRectangleRounded", &umkaDrawRectangleRounded)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawRectangleRounded()");
        return false;
    }
    // DrawRectangleRoundedLines()
    if (!umkaAddFunc(umka, "DrawRectangleRoundedLines", &umkaDrawRectangleRoundedLines)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawRectangleRoundedLines()");
        return false;
    }
    // DrawTriangle()
    if (!umkaAddFunc(umka, "DrawTriangle", &umkaDrawTriangle)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawTriangle()");
        return false;
    }
    // DrawTriangleLines()
    if (!umkaAddFunc(umka, "DrawTriangleLines", &umkaDrawTriangleLines)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawTriangleLines()");
        return false;
    }
    // DrawTriangleFan()
    if (!umkaAddFunc(umka, "DrawTriangleFan", &umkaDrawTriangleFan)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawTriangleFan()");
        return false;
    }
    // DrawTriangleStrip()
    if (!umkaAddFunc(umka, "DrawTriangleStrip", &umkaDrawTriangleStrip)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawTriangleStrip()");
        return false;
    }
    // DrawPoly()
    if (!umkaAddFunc(umka, "DrawPoly", &umkaDrawPoly)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawPoly()");
        return false;
    }
    // DrawPolyLines()
    if (!umkaAddFunc(umka, "DrawPolyLines", &umkaDrawPolyLines)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawPolyLines()");
        return false;
    }
    // DrawPolyLinesEx()
    if (!umkaAddFunc(umka, "DrawPolyLinesEx", &umkaDrawPolyLinesEx)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawPolyLinesEx()");
        return false;
    }
    // CheckCollisionRecs()
    if (!umkaAddFunc(umka, "CheckCollisionRecs", &umkaCheckCollisionRecs)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function CheckCollisionRecs()");
        return false;
    }
    // CheckCollisionCircles()
    if (!umkaAddFunc(umka, "CheckCollisionCircles", &umkaCheckCollisionCircles)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function CheckCollisionCircles()");
        return false;
    }
    // CheckCollisionCircleRec()
    if (!umkaAddFunc(umka, "CheckCollisionCircleRec", &umkaCheckCollisionCircleRec)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function CheckCollisionCircleRec()");
        return false;
    }
    // CheckCollisionPointRec()
    if (!umkaAddFunc(umka, "CheckCollisionPointRec", &umkaCheckCollisionPointRec)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function CheckCollisionPointRec()");
        return false;
    }
    // CheckCollisionPointCircle()
    if (!umkaAddFunc(umka, "CheckCollisionPointCircle", &umkaCheckCollisionPointCircle)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function CheckCollisionPointCircle()");
        return false;
    }
    // CheckCollisionPointTriangle()
    if (!umkaAddFunc(umka, "CheckCollisionPointTriangle", &umkaCheckCollisionPointTriangle)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function CheckCollisionPointTriangle()");
        return false;
    }
    // CheckCollisionLines()
    if (!umkaAddFunc(umka, "CheckCollisionLines", &umkaCheckCollisionLines)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function CheckCollisionLines()");
        return false;
    }
    // CheckCollisionPointLine()
    if (!umkaAddFunc(umka, "CheckCollisionPointLine", &umkaCheckCollisionPointLine)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function CheckCollisionPointLine()");
        return false;
    }
    // GetCollisionRec()
    if (!umkaAddFunc(umka, "GetCollisionRec", &umkaGetCollisionRec)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetCollisionRec()");
        return false;
    }
    // LoadImage()
    if (!umkaAddFunc(umka, "LoadImage", &umkaLoadImage)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadImage()");
        return false;
    }
    // LoadImageRaw()
    if (!umkaAddFunc(umka, "LoadImageRaw", &umkaLoadImageRaw)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadImageRaw()");
        return false;
    }
    // LoadImageAnim()
    if (!umkaAddFunc(umka, "LoadImageAnim", &umkaLoadImageAnim)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadImageAnim()");
        return false;
    }
    // LoadImageFromMemory()
    if (!umkaAddFunc(umka, "LoadImageFromMemory", &umkaLoadImageFromMemory)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadImageFromMemory()");
        return false;
    }
    // LoadImageFromTexture()
    if (!umkaAddFunc(umka, "LoadImageFromTexture", &umkaLoadImageFromTexture)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadImageFromTexture()");
        return false;
    }
    // LoadImageFromScreen()
    if (!umkaAddFunc(umka, "LoadImageFromScreen", &umkaLoadImageFromScreen)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadImageFromScreen()");
        return false;
    }
    // UnloadImage()
    if (!umkaAddFunc(umka, "UnloadImage", &umkaUnloadImage)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UnloadImage()");
        return false;
    }
    // ExportImage()
    if (!umkaAddFunc(umka, "ExportImage", &umkaExportImage)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ExportImage()");
        return false;
    }
    // ExportImageAsCode()
    if (!umkaAddFunc(umka, "ExportImageAsCode", &umkaExportImageAsCode)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ExportImageAsCode()");
        return false;
    }
    // GenImageColor()
    if (!umkaAddFunc(umka, "GenImageColor", &umkaGenImageColor)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GenImageColor()");
        return false;
    }
    // GenImageGradientV()
    if (!umkaAddFunc(umka, "GenImageGradientV", &umkaGenImageGradientV)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GenImageGradientV()");
        return false;
    }
    // GenImageGradientH()
    if (!umkaAddFunc(umka, "GenImageGradientH", &umkaGenImageGradientH)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GenImageGradientH()");
        return false;
    }
    // GenImageGradientRadial()
    if (!umkaAddFunc(umka, "GenImageGradientRadial", &umkaGenImageGradientRadial)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GenImageGradientRadial()");
        return false;
    }
    // GenImageChecked()
    if (!umkaAddFunc(umka, "GenImageChecked", &umkaGenImageChecked)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GenImageChecked()");
        return false;
    }
    // GenImageWhiteNoise()
    if (!umkaAddFunc(umka, "GenImageWhiteNoise", &umkaGenImageWhiteNoise)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GenImageWhiteNoise()");
        return false;
    }
    // GenImageCellular()
    if (!umkaAddFunc(umka, "GenImageCellular", &umkaGenImageCellular)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GenImageCellular()");
        return false;
    }
    // ImageCopy()
    if (!umkaAddFunc(umka, "ImageCopy", &umkaImageCopy)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageCopy()");
        return false;
    }
    // ImageFromImage()
    if (!umkaAddFunc(umka, "ImageFromImage", &umkaImageFromImage)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageFromImage()");
        return false;
    }
    // ImageText()
    if (!umkaAddFunc(umka, "ImageText", &umkaImageText)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageText()");
        return false;
    }
    // ImageTextEx()
    if (!umkaAddFunc(umka, "ImageTextEx", &umkaImageTextEx)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageTextEx()");
        return false;
    }
    // ImageFormat()
    if (!umkaAddFunc(umka, "ImageFormat", &umkaImageFormat)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageFormat()");
        return false;
    }
    // ImageToPOT()
    if (!umkaAddFunc(umka, "ImageToPOT", &umkaImageToPOT)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageToPOT()");
        return false;
    }
    // ImageCrop()
    if (!umkaAddFunc(umka, "ImageCrop", &umkaImageCrop)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageCrop()");
        return false;
    }
    // ImageAlphaCrop()
    if (!umkaAddFunc(umka, "ImageAlphaCrop", &umkaImageAlphaCrop)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageAlphaCrop()");
        return false;
    }
    // ImageAlphaClear()
    if (!umkaAddFunc(umka, "ImageAlphaClear", &umkaImageAlphaClear)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageAlphaClear()");
        return false;
    }
    // ImageAlphaMask()
    if (!umkaAddFunc(umka, "ImageAlphaMask", &umkaImageAlphaMask)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageAlphaMask()");
        return false;
    }
    // ImageAlphaPremultiply()
    if (!umkaAddFunc(umka, "ImageAlphaPremultiply", &umkaImageAlphaPremultiply)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageAlphaPremultiply()");
        return false;
    }
    // ImageResize()
    if (!umkaAddFunc(umka, "ImageResize", &umkaImageResize)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageResize()");
        return false;
    }
    // ImageResizeNN()
    if (!umkaAddFunc(umka, "ImageResizeNN", &umkaImageResizeNN)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageResizeNN()");
        return false;
    }
    // ImageResizeCanvas()
    if (!umkaAddFunc(umka, "ImageResizeCanvas", &umkaImageResizeCanvas)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageResizeCanvas()");
        return false;
    }
    // ImageMipmaps()
    if (!umkaAddFunc(umka, "ImageMipmaps", &umkaImageMipmaps)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageMipmaps()");
        return false;
    }
    // ImageDither()
    if (!umkaAddFunc(umka, "ImageDither", &umkaImageDither)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageDither()");
        return false;
    }
    // ImageFlipVertical()
    if (!umkaAddFunc(umka, "ImageFlipVertical", &umkaImageFlipVertical)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageFlipVertical()");
        return false;
    }
    // ImageFlipHorizontal()
    if (!umkaAddFunc(umka, "ImageFlipHorizontal", &umkaImageFlipHorizontal)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageFlipHorizontal()");
        return false;
    }
    // ImageRotateCW()
    if (!umkaAddFunc(umka, "ImageRotateCW", &umkaImageRotateCW)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageRotateCW()");
        return false;
    }
    // ImageRotateCCW()
    if (!umkaAddFunc(umka, "ImageRotateCCW", &umkaImageRotateCCW)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageRotateCCW()");
        return false;
    }
    // ImageColorTint()
    if (!umkaAddFunc(umka, "ImageColorTint", &umkaImageColorTint)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageColorTint()");
        return false;
    }
    // ImageColorInvert()
    if (!umkaAddFunc(umka, "ImageColorInvert", &umkaImageColorInvert)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageColorInvert()");
        return false;
    }
    // ImageColorGrayscale()
    if (!umkaAddFunc(umka, "ImageColorGrayscale", &umkaImageColorGrayscale)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageColorGrayscale()");
        return false;
    }
    // ImageColorContrast()
    if (!umkaAddFunc(umka, "ImageColorContrast", &umkaImageColorContrast)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageColorContrast()");
        return false;
    }
    // ImageColorBrightness()
    if (!umkaAddFunc(umka, "ImageColorBrightness", &umkaImageColorBrightness)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageColorBrightness()");
        return false;
    }
    // ImageColorReplace()
    if (!umkaAddFunc(umka, "ImageColorReplace", &umkaImageColorReplace)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageColorReplace()");
        return false;
    }
    // LoadImageColors()
    if (!umkaAddFunc(umka, "LoadImageColors", &umkaLoadImageColors)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadImageColors()");
        return false;
    }
    // LoadImagePalette()
    if (!umkaAddFunc(umka, "LoadImagePalette", &umkaLoadImagePalette)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadImagePalette()");
        return false;
    }
    // UnloadImageColors()
    if (!umkaAddFunc(umka, "UnloadImageColors", &umkaUnloadImageColors)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UnloadImageColors()");
        return false;
    }
    // UnloadImagePalette()
    if (!umkaAddFunc(umka, "UnloadImagePalette", &umkaUnloadImagePalette)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UnloadImagePalette()");
        return false;
    }
    // GetImageAlphaBorder()
    if (!umkaAddFunc(umka, "GetImageAlphaBorder", &umkaGetImageAlphaBorder)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetImageAlphaBorder()");
        return false;
    }
    // GetImageColor()
    if (!umkaAddFunc(umka, "GetImageColor", &umkaGetImageColor)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetImageColor()");
        return false;
    }
    // ImageClearBackground()
    if (!umkaAddFunc(umka, "ImageClearBackground", &umkaImageClearBackground)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageClearBackground()");
        return false;
    }
    // ImageDrawPixel()
    if (!umkaAddFunc(umka, "ImageDrawPixel", &umkaImageDrawPixel)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageDrawPixel()");
        return false;
    }
    // ImageDrawPixelV()
    if (!umkaAddFunc(umka, "ImageDrawPixelV", &umkaImageDrawPixelV)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageDrawPixelV()");
        return false;
    }
    // ImageDrawLine()
    if (!umkaAddFunc(umka, "ImageDrawLine", &umkaImageDrawLine)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageDrawLine()");
        return false;
    }
    // ImageDrawLineV()
    if (!umkaAddFunc(umka, "ImageDrawLineV", &umkaImageDrawLineV)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageDrawLineV()");
        return false;
    }
    // ImageDrawCircle()
    if (!umkaAddFunc(umka, "ImageDrawCircle", &umkaImageDrawCircle)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageDrawCircle()");
        return false;
    }
    // ImageDrawCircleV()
    if (!umkaAddFunc(umka, "ImageDrawCircleV", &umkaImageDrawCircleV)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageDrawCircleV()");
        return false;
    }
    // ImageDrawRectangle()
    if (!umkaAddFunc(umka, "ImageDrawRectangle", &umkaImageDrawRectangle)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageDrawRectangle()");
        return false;
    }
    // ImageDrawRectangleV()
    if (!umkaAddFunc(umka, "ImageDrawRectangleV", &umkaImageDrawRectangleV)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageDrawRectangleV()");
        return false;
    }
    // ImageDrawRectangleRec()
    if (!umkaAddFunc(umka, "ImageDrawRectangleRec", &umkaImageDrawRectangleRec)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageDrawRectangleRec()");
        return false;
    }
    // ImageDrawRectangleLines()
    if (!umkaAddFunc(umka, "ImageDrawRectangleLines", &umkaImageDrawRectangleLines)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageDrawRectangleLines()");
        return false;
    }
    // ImageDraw()
    if (!umkaAddFunc(umka, "ImageDraw", &umkaImageDraw)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageDraw()");
        return false;
    }
    // ImageDrawText()
    if (!umkaAddFunc(umka, "ImageDrawText", &umkaImageDrawText)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageDrawText()");
        return false;
    }
    // ImageDrawTextEx()
    if (!umkaAddFunc(umka, "ImageDrawTextEx", &umkaImageDrawTextEx)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageDrawTextEx()");
        return false;
    }
    // LoadTexture()
    if (!umkaAddFunc(umka, "LoadTexture", &umkaLoadTexture)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadTexture()");
        return false;
    }
    // LoadTextureFromImage()
    if (!umkaAddFunc(umka, "LoadTextureFromImage", &umkaLoadTextureFromImage)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadTextureFromImage()");
        return false;
    }
    // LoadTextureCubemap()
    if (!umkaAddFunc(umka, "LoadTextureCubemap", &umkaLoadTextureCubemap)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadTextureCubemap()");
        return false;
    }
    // LoadRenderTexture()
    if (!umkaAddFunc(umka, "LoadRenderTexture", &umkaLoadRenderTexture)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadRenderTexture()");
        return false;
    }
    // UnloadTexture()
    if (!umkaAddFunc(umka, "UnloadTexture", &umkaUnloadTexture)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UnloadTexture()");
        return false;
    }
    // UnloadRenderTexture()
    if (!umkaAddFunc(umka, "UnloadRenderTexture", &umkaUnloadRenderTexture)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UnloadRenderTexture()");
        return false;
    }
    // UpdateTexture()
    if (!umkaAddFunc(umka, "UpdateTexture", &umkaUpdateTexture)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UpdateTexture()");
        return false;
    }
    // UpdateTextureRec()
    if (!umkaAddFunc(umka, "UpdateTextureRec", &umkaUpdateTextureRec)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UpdateTextureRec()");
        return false;
    }
    // GenTextureMipmaps()
    if (!umkaAddFunc(umka, "GenTextureMipmaps", &umkaGenTextureMipmaps)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GenTextureMipmaps()");
        return false;
    }
    // SetTextureFilter()
    if (!umkaAddFunc(umka, "SetTextureFilter", &umkaSetTextureFilter)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetTextureFilter()");
        return false;
    }
    // SetTextureWrap()
    if (!umkaAddFunc(umka, "SetTextureWrap", &umkaSetTextureWrap)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetTextureWrap()");
        return false;
    }
    // DrawTexture()
    if (!umkaAddFunc(umka, "DrawTexture", &umkaDrawTexture)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawTexture()");
        return false;
    }
    // DrawTextureV()
    if (!umkaAddFunc(umka, "DrawTextureV", &umkaDrawTextureV)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawTextureV()");
        return false;
    }
    // DrawTextureEx()
    if (!umkaAddFunc(umka, "DrawTextureEx", &umkaDrawTextureEx)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawTextureEx()");
        return false;
    }
    // DrawTextureRec()
    if (!umkaAddFunc(umka, "DrawTextureRec", &umkaDrawTextureRec)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawTextureRec()");
        return false;
    }
    // DrawTextureQuad()
    if (!umkaAddFunc(umka, "DrawTextureQuad", &umkaDrawTextureQuad)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawTextureQuad()");
        return false;
    }
    // DrawTextureTiled()
    if (!umkaAddFunc(umka, "DrawTextureTiled", &umkaDrawTextureTiled)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawTextureTiled()");
        return false;
    }
    // DrawTexturePro()
    if (!umkaAddFunc(umka, "DrawTexturePro", &umkaDrawTexturePro)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawTexturePro()");
        return false;
    }
    // DrawTextureNPatch()
    if (!umkaAddFunc(umka, "DrawTextureNPatch", &umkaDrawTextureNPatch)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawTextureNPatch()");
        return false;
    }
    // DrawTexturePoly()
    if (!umkaAddFunc(umka, "DrawTexturePoly", &umkaDrawTexturePoly)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawTexturePoly()");
        return false;
    }
    // Fade()
    if (!umkaAddFunc(umka, "Fade", &umkaFade)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Fade()");
        return false;
    }
    // ColorToInt()
    if (!umkaAddFunc(umka, "ColorToInt", &umkaColorToInt)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ColorToInt()");
        return false;
    }
    // ColorNormalize()
    if (!umkaAddFunc(umka, "ColorNormalize", &umkaColorNormalize)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ColorNormalize()");
        return false;
    }
    // ColorFromNormalized()
    if (!umkaAddFunc(umka, "ColorFromNormalized", &umkaColorFromNormalized)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ColorFromNormalized()");
        return false;
    }
    // ColorToHSV()
    if (!umkaAddFunc(umka, "ColorToHSV", &umkaColorToHSV)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ColorToHSV()");
        return false;
    }
    // ColorFromHSV()
    if (!umkaAddFunc(umka, "ColorFromHSV", &umkaColorFromHSV)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ColorFromHSV()");
        return false;
    }
    // ColorAlpha()
    if (!umkaAddFunc(umka, "ColorAlpha", &umkaColorAlpha)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ColorAlpha()");
        return false;
    }
    // ColorAlphaBlend()
    if (!umkaAddFunc(umka, "ColorAlphaBlend", &umkaColorAlphaBlend)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ColorAlphaBlend()");
        return false;
    }
    // GetColor()
    if (!umkaAddFunc(umka, "GetColor", &umkaGetColor)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetColor()");
        return false;
    }
    // GetPixelColor()
    if (!umkaAddFunc(umka, "GetPixelColor", &umkaGetPixelColor)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetPixelColor()");
        return false;
    }
    // SetPixelColor()
    if (!umkaAddFunc(umka, "SetPixelColor", &umkaSetPixelColor)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetPixelColor()");
        return false;
    }
    // GetPixelDataSize()
    if (!umkaAddFunc(umka, "GetPixelDataSize", &umkaGetPixelDataSize)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetPixelDataSize()");
        return false;
    }
    // GetFontDefault()
    if (!umkaAddFunc(umka, "GetFontDefault", &umkaGetFontDefault)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetFontDefault()");
        return false;
    }
    // LoadFont()
    if (!umkaAddFunc(umka, "LoadFont", &umkaLoadFont)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadFont()");
        return false;
    }
    // LoadFontEx()
    if (!umkaAddFunc(umka, "LoadFontEx", &umkaLoadFontEx)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadFontEx()");
        return false;
    }
    // LoadFontFromImage()
    if (!umkaAddFunc(umka, "LoadFontFromImage", &umkaLoadFontFromImage)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadFontFromImage()");
        return false;
    }
    // LoadFontFromMemory()
    if (!umkaAddFunc(umka, "LoadFontFromMemory", &umkaLoadFontFromMemory)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadFontFromMemory()");
        return false;
    }
    // Skipping LoadFontData
    // GenImageFontAtlas()
    if (!umkaAddFunc(umka, "GenImageFontAtlas", &umkaGenImageFontAtlas)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GenImageFontAtlas()");
        return false;
    }
    // UnloadFontData()
    if (!umkaAddFunc(umka, "UnloadFontData", &umkaUnloadFontData)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UnloadFontData()");
        return false;
    }
    // UnloadFont()
    if (!umkaAddFunc(umka, "UnloadFont", &umkaUnloadFont)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UnloadFont()");
        return false;
    }
    // ExportFontAsCode()
    if (!umkaAddFunc(umka, "ExportFontAsCode", &umkaExportFontAsCode)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ExportFontAsCode()");
        return false;
    }
    // DrawFPS()
    if (!umkaAddFunc(umka, "DrawFPS", &umkaDrawFPS)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawFPS()");
        return false;
    }
    // DrawText()
    if (!umkaAddFunc(umka, "DrawText", &umkaDrawText)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawText()");
        return false;
    }
    // DrawTextEx()
    if (!umkaAddFunc(umka, "DrawTextEx", &umkaDrawTextEx)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawTextEx()");
        return false;
    }
    // DrawTextPro()
    if (!umkaAddFunc(umka, "DrawTextPro", &umkaDrawTextPro)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawTextPro()");
        return false;
    }
    // DrawTextCodepoint()
    if (!umkaAddFunc(umka, "DrawTextCodepoint", &umkaDrawTextCodepoint)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawTextCodepoint()");
        return false;
    }
    // DrawTextCodepoints()
    if (!umkaAddFunc(umka, "DrawTextCodepoints", &umkaDrawTextCodepoints)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawTextCodepoints()");
        return false;
    }
    // MeasureText()
    if (!umkaAddFunc(umka, "MeasureText", &umkaMeasureText)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function MeasureText()");
        return false;
    }
    // MeasureTextEx()
    if (!umkaAddFunc(umka, "MeasureTextEx", &umkaMeasureTextEx)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function MeasureTextEx()");
        return false;
    }
    // GetGlyphIndex()
    if (!umkaAddFunc(umka, "GetGlyphIndex", &umkaGetGlyphIndex)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetGlyphIndex()");
        return false;
    }
    // GetGlyphInfo()
    if (!umkaAddFunc(umka, "GetGlyphInfo", &umkaGetGlyphInfo)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetGlyphInfo()");
        return false;
    }
    // GetGlyphAtlasRec()
    if (!umkaAddFunc(umka, "GetGlyphAtlasRec", &umkaGetGlyphAtlasRec)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetGlyphAtlasRec()");
        return false;
    }
    // LoadCodepoints()
    if (!umkaAddFunc(umka, "LoadCodepoints", &umkaLoadCodepoints)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadCodepoints()");
        return false;
    }
    // UnloadCodepoints()
    if (!umkaAddFunc(umka, "UnloadCodepoints", &umkaUnloadCodepoints)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UnloadCodepoints()");
        return false;
    }
    // GetCodepointCount()
    if (!umkaAddFunc(umka, "GetCodepointCount", &umkaGetCodepointCount)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetCodepointCount()");
        return false;
    }
    // GetCodepoint()
    if (!umkaAddFunc(umka, "GetCodepoint", &umkaGetCodepoint)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetCodepoint()");
        return false;
    }
    // CodepointToUTF8()
    if (!umkaAddFunc(umka, "CodepointToUTF8", &umkaCodepointToUTF8)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function CodepointToUTF8()");
        return false;
    }
    // TextCodepointsToUTF8()
    if (!umkaAddFunc(umka, "TextCodepointsToUTF8", &umkaTextCodepointsToUTF8)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function TextCodepointsToUTF8()");
        return false;
    }
    // TextCopy()
    if (!umkaAddFunc(umka, "TextCopy", &umkaTextCopy)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function TextCopy()");
        return false;
    }
    // TextIsEqual()
    if (!umkaAddFunc(umka, "TextIsEqual", &umkaTextIsEqual)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function TextIsEqual()");
        return false;
    }
    // TextLength()
    if (!umkaAddFunc(umka, "TextLength", &umkaTextLength)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function TextLength()");
        return false;
    }
    // Skipping TextFormat
    // TextSubtext()
    if (!umkaAddFunc(umka, "TextSubtext", &umkaTextSubtext)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function TextSubtext()");
        return false;
    }
    // TextReplace()
    if (!umkaAddFunc(umka, "TextReplace", &umkaTextReplace)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function TextReplace()");
        return false;
    }
    // TextInsert()
    if (!umkaAddFunc(umka, "TextInsert", &umkaTextInsert)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function TextInsert()");
        return false;
    }
    // TextJoin()
    if (!umkaAddFunc(umka, "TextJoin", &umkaTextJoin)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function TextJoin()");
        return false;
    }
    // TextSplit()
    if (!umkaAddFunc(umka, "TextSplit", &umkaTextSplit)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function TextSplit()");
        return false;
    }
    // TextAppend()
    if (!umkaAddFunc(umka, "TextAppend", &umkaTextAppend)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function TextAppend()");
        return false;
    }
    // TextFindIndex()
    if (!umkaAddFunc(umka, "TextFindIndex", &umkaTextFindIndex)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function TextFindIndex()");
        return false;
    }
    // TextToUpper()
    if (!umkaAddFunc(umka, "TextToUpper", &umkaTextToUpper)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function TextToUpper()");
        return false;
    }
    // TextToLower()
    if (!umkaAddFunc(umka, "TextToLower", &umkaTextToLower)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function TextToLower()");
        return false;
    }
    // TextToPascal()
    if (!umkaAddFunc(umka, "TextToPascal", &umkaTextToPascal)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function TextToPascal()");
        return false;
    }
    // TextToInteger()
    if (!umkaAddFunc(umka, "TextToInteger", &umkaTextToInteger)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function TextToInteger()");
        return false;
    }
    // DrawLine3D()
    if (!umkaAddFunc(umka, "DrawLine3D", &umkaDrawLine3D)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawLine3D()");
        return false;
    }
    // DrawPoint3D()
    if (!umkaAddFunc(umka, "DrawPoint3D", &umkaDrawPoint3D)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawPoint3D()");
        return false;
    }
    // DrawCircle3D()
    if (!umkaAddFunc(umka, "DrawCircle3D", &umkaDrawCircle3D)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawCircle3D()");
        return false;
    }
    // DrawTriangle3D()
    if (!umkaAddFunc(umka, "DrawTriangle3D", &umkaDrawTriangle3D)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawTriangle3D()");
        return false;
    }
    // DrawTriangleStrip3D()
    if (!umkaAddFunc(umka, "DrawTriangleStrip3D", &umkaDrawTriangleStrip3D)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawTriangleStrip3D()");
        return false;
    }
    // DrawCube()
    if (!umkaAddFunc(umka, "DrawCube", &umkaDrawCube)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawCube()");
        return false;
    }
    // DrawCubeV()
    if (!umkaAddFunc(umka, "DrawCubeV", &umkaDrawCubeV)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawCubeV()");
        return false;
    }
    // DrawCubeWires()
    if (!umkaAddFunc(umka, "DrawCubeWires", &umkaDrawCubeWires)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawCubeWires()");
        return false;
    }
    // DrawCubeWiresV()
    if (!umkaAddFunc(umka, "DrawCubeWiresV", &umkaDrawCubeWiresV)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawCubeWiresV()");
        return false;
    }
    // DrawCubeTexture()
    if (!umkaAddFunc(umka, "DrawCubeTexture", &umkaDrawCubeTexture)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawCubeTexture()");
        return false;
    }
    // DrawCubeTextureRec()
    if (!umkaAddFunc(umka, "DrawCubeTextureRec", &umkaDrawCubeTextureRec)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawCubeTextureRec()");
        return false;
    }
    // DrawSphere()
    if (!umkaAddFunc(umka, "DrawSphere", &umkaDrawSphere)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawSphere()");
        return false;
    }
    // DrawSphereEx()
    if (!umkaAddFunc(umka, "DrawSphereEx", &umkaDrawSphereEx)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawSphereEx()");
        return false;
    }
    // DrawSphereWires()
    if (!umkaAddFunc(umka, "DrawSphereWires", &umkaDrawSphereWires)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawSphereWires()");
        return false;
    }
    // DrawCylinder()
    if (!umkaAddFunc(umka, "DrawCylinder", &umkaDrawCylinder)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawCylinder()");
        return false;
    }
    // DrawCylinderEx()
    if (!umkaAddFunc(umka, "DrawCylinderEx", &umkaDrawCylinderEx)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawCylinderEx()");
        return false;
    }
    // DrawCylinderWires()
    if (!umkaAddFunc(umka, "DrawCylinderWires", &umkaDrawCylinderWires)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawCylinderWires()");
        return false;
    }
    // DrawCylinderWiresEx()
    if (!umkaAddFunc(umka, "DrawCylinderWiresEx", &umkaDrawCylinderWiresEx)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawCylinderWiresEx()");
        return false;
    }
    // DrawPlane()
    if (!umkaAddFunc(umka, "DrawPlane", &umkaDrawPlane)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawPlane()");
        return false;
    }
    // DrawRay()
    if (!umkaAddFunc(umka, "DrawRay", &umkaDrawRay)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawRay()");
        return false;
    }
    // DrawGrid()
    if (!umkaAddFunc(umka, "DrawGrid", &umkaDrawGrid)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawGrid()");
        return false;
    }
    // LoadModel()
    if (!umkaAddFunc(umka, "LoadModel", &umkaLoadModel)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadModel()");
        return false;
    }
    // LoadModelFromMesh()
    if (!umkaAddFunc(umka, "LoadModelFromMesh", &umkaLoadModelFromMesh)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadModelFromMesh()");
        return false;
    }
    // UnloadModel()
    if (!umkaAddFunc(umka, "UnloadModel", &umkaUnloadModel)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UnloadModel()");
        return false;
    }
    // UnloadModelKeepMeshes()
    if (!umkaAddFunc(umka, "UnloadModelKeepMeshes", &umkaUnloadModelKeepMeshes)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UnloadModelKeepMeshes()");
        return false;
    }
    // GetModelBoundingBox()
    if (!umkaAddFunc(umka, "GetModelBoundingBox", &umkaGetModelBoundingBox)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetModelBoundingBox()");
        return false;
    }
    // DrawModel()
    if (!umkaAddFunc(umka, "DrawModel", &umkaDrawModel)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawModel()");
        return false;
    }
    // DrawModelEx()
    if (!umkaAddFunc(umka, "DrawModelEx", &umkaDrawModelEx)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawModelEx()");
        return false;
    }
    // DrawModelWires()
    if (!umkaAddFunc(umka, "DrawModelWires", &umkaDrawModelWires)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawModelWires()");
        return false;
    }
    // DrawModelWiresEx()
    if (!umkaAddFunc(umka, "DrawModelWiresEx", &umkaDrawModelWiresEx)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawModelWiresEx()");
        return false;
    }
    // DrawBoundingBox()
    if (!umkaAddFunc(umka, "DrawBoundingBox", &umkaDrawBoundingBox)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawBoundingBox()");
        return false;
    }
    // DrawBillboard()
    if (!umkaAddFunc(umka, "DrawBillboard", &umkaDrawBillboard)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawBillboard()");
        return false;
    }
    // DrawBillboardRec()
    if (!umkaAddFunc(umka, "DrawBillboardRec", &umkaDrawBillboardRec)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawBillboardRec()");
        return false;
    }
    // DrawBillboardPro()
    if (!umkaAddFunc(umka, "DrawBillboardPro", &umkaDrawBillboardPro)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawBillboardPro()");
        return false;
    }
    // UploadMesh()
    if (!umkaAddFunc(umka, "UploadMesh", &umkaUploadMesh)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UploadMesh()");
        return false;
    }
    // UpdateMeshBuffer()
    if (!umkaAddFunc(umka, "UpdateMeshBuffer", &umkaUpdateMeshBuffer)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UpdateMeshBuffer()");
        return false;
    }
    // UnloadMesh()
    if (!umkaAddFunc(umka, "UnloadMesh", &umkaUnloadMesh)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UnloadMesh()");
        return false;
    }
    // DrawMesh()
    if (!umkaAddFunc(umka, "DrawMesh", &umkaDrawMesh)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawMesh()");
        return false;
    }
    // DrawMeshInstanced()
    if (!umkaAddFunc(umka, "DrawMeshInstanced", &umkaDrawMeshInstanced)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawMeshInstanced()");
        return false;
    }
    // ExportMesh()
    if (!umkaAddFunc(umka, "ExportMesh", &umkaExportMesh)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ExportMesh()");
        return false;
    }
    // GetMeshBoundingBox()
    if (!umkaAddFunc(umka, "GetMeshBoundingBox", &umkaGetMeshBoundingBox)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetMeshBoundingBox()");
        return false;
    }
    // GenMeshTangents()
    if (!umkaAddFunc(umka, "GenMeshTangents", &umkaGenMeshTangents)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GenMeshTangents()");
        return false;
    }
    // GenMeshPoly()
    if (!umkaAddFunc(umka, "GenMeshPoly", &umkaGenMeshPoly)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GenMeshPoly()");
        return false;
    }
    // GenMeshPlane()
    if (!umkaAddFunc(umka, "GenMeshPlane", &umkaGenMeshPlane)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GenMeshPlane()");
        return false;
    }
    // GenMeshCube()
    if (!umkaAddFunc(umka, "GenMeshCube", &umkaGenMeshCube)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GenMeshCube()");
        return false;
    }
    // GenMeshSphere()
    if (!umkaAddFunc(umka, "GenMeshSphere", &umkaGenMeshSphere)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GenMeshSphere()");
        return false;
    }
    // GenMeshHemiSphere()
    if (!umkaAddFunc(umka, "GenMeshHemiSphere", &umkaGenMeshHemiSphere)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GenMeshHemiSphere()");
        return false;
    }
    // GenMeshCylinder()
    if (!umkaAddFunc(umka, "GenMeshCylinder", &umkaGenMeshCylinder)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GenMeshCylinder()");
        return false;
    }
    // GenMeshCone()
    if (!umkaAddFunc(umka, "GenMeshCone", &umkaGenMeshCone)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GenMeshCone()");
        return false;
    }
    // GenMeshTorus()
    if (!umkaAddFunc(umka, "GenMeshTorus", &umkaGenMeshTorus)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GenMeshTorus()");
        return false;
    }
    // GenMeshKnot()
    if (!umkaAddFunc(umka, "GenMeshKnot", &umkaGenMeshKnot)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GenMeshKnot()");
        return false;
    }
    // GenMeshHeightmap()
    if (!umkaAddFunc(umka, "GenMeshHeightmap", &umkaGenMeshHeightmap)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GenMeshHeightmap()");
        return false;
    }
    // GenMeshCubicmap()
    if (!umkaAddFunc(umka, "GenMeshCubicmap", &umkaGenMeshCubicmap)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GenMeshCubicmap()");
        return false;
    }
    // LoadMaterials()
    if (!umkaAddFunc(umka, "LoadMaterials", &umkaLoadMaterials)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadMaterials()");
        return false;
    }
    // LoadMaterialDefault()
    if (!umkaAddFunc(umka, "LoadMaterialDefault", &umkaLoadMaterialDefault)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadMaterialDefault()");
        return false;
    }
    // UnloadMaterial()
    if (!umkaAddFunc(umka, "UnloadMaterial", &umkaUnloadMaterial)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UnloadMaterial()");
        return false;
    }
    // SetMaterialTexture()
    if (!umkaAddFunc(umka, "SetMaterialTexture", &umkaSetMaterialTexture)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetMaterialTexture()");
        return false;
    }
    // SetModelMeshMaterial()
    if (!umkaAddFunc(umka, "SetModelMeshMaterial", &umkaSetModelMeshMaterial)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetModelMeshMaterial()");
        return false;
    }
    // LoadModelAnimations()
    if (!umkaAddFunc(umka, "LoadModelAnimations", &umkaLoadModelAnimations)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadModelAnimations()");
        return false;
    }
    // UpdateModelAnimation()
    if (!umkaAddFunc(umka, "UpdateModelAnimation", &umkaUpdateModelAnimation)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UpdateModelAnimation()");
        return false;
    }
    // UnloadModelAnimation()
    if (!umkaAddFunc(umka, "UnloadModelAnimation", &umkaUnloadModelAnimation)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UnloadModelAnimation()");
        return false;
    }
    // UnloadModelAnimations()
    if (!umkaAddFunc(umka, "UnloadModelAnimations", &umkaUnloadModelAnimations)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UnloadModelAnimations()");
        return false;
    }
    // IsModelAnimationValid()
    if (!umkaAddFunc(umka, "IsModelAnimationValid", &umkaIsModelAnimationValid)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function IsModelAnimationValid()");
        return false;
    }
    // CheckCollisionSpheres()
    if (!umkaAddFunc(umka, "CheckCollisionSpheres", &umkaCheckCollisionSpheres)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function CheckCollisionSpheres()");
        return false;
    }
    // CheckCollisionBoxes()
    if (!umkaAddFunc(umka, "CheckCollisionBoxes", &umkaCheckCollisionBoxes)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function CheckCollisionBoxes()");
        return false;
    }
    // CheckCollisionBoxSphere()
    if (!umkaAddFunc(umka, "CheckCollisionBoxSphere", &umkaCheckCollisionBoxSphere)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function CheckCollisionBoxSphere()");
        return false;
    }
    // GetRayCollisionSphere()
    if (!umkaAddFunc(umka, "GetRayCollisionSphere", &umkaGetRayCollisionSphere)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetRayCollisionSphere()");
        return false;
    }
    // GetRayCollisionBox()
    if (!umkaAddFunc(umka, "GetRayCollisionBox", &umkaGetRayCollisionBox)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetRayCollisionBox()");
        return false;
    }
    // GetRayCollisionMesh()
    if (!umkaAddFunc(umka, "GetRayCollisionMesh", &umkaGetRayCollisionMesh)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetRayCollisionMesh()");
        return false;
    }
    // GetRayCollisionTriangle()
    if (!umkaAddFunc(umka, "GetRayCollisionTriangle", &umkaGetRayCollisionTriangle)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetRayCollisionTriangle()");
        return false;
    }
    // GetRayCollisionQuad()
    if (!umkaAddFunc(umka, "GetRayCollisionQuad", &umkaGetRayCollisionQuad)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetRayCollisionQuad()");
        return false;
    }
    // InitAudioDevice()
    if (!umkaAddFunc(umka, "InitAudioDevice", &umkaInitAudioDevice)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function InitAudioDevice()");
        return false;
    }
    // CloseAudioDevice()
    if (!umkaAddFunc(umka, "CloseAudioDevice", &umkaCloseAudioDevice)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function CloseAudioDevice()");
        return false;
    }
    // IsAudioDeviceReady()
    if (!umkaAddFunc(umka, "IsAudioDeviceReady", &umkaIsAudioDeviceReady)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function IsAudioDeviceReady()");
        return false;
    }
    // SetMasterVolume()
    if (!umkaAddFunc(umka, "SetMasterVolume", &umkaSetMasterVolume)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetMasterVolume()");
        return false;
    }
    // LoadWave()
    if (!umkaAddFunc(umka, "LoadWave", &umkaLoadWave)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadWave()");
        return false;
    }
    // LoadWaveFromMemory()
    if (!umkaAddFunc(umka, "LoadWaveFromMemory", &umkaLoadWaveFromMemory)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadWaveFromMemory()");
        return false;
    }
    // LoadSound()
    if (!umkaAddFunc(umka, "LoadSound", &umkaLoadSound)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadSound()");
        return false;
    }
    // LoadSoundFromWave()
    if (!umkaAddFunc(umka, "LoadSoundFromWave", &umkaLoadSoundFromWave)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadSoundFromWave()");
        return false;
    }
    // UpdateSound()
    if (!umkaAddFunc(umka, "UpdateSound", &umkaUpdateSound)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UpdateSound()");
        return false;
    }
    // UnloadWave()
    if (!umkaAddFunc(umka, "UnloadWave", &umkaUnloadWave)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UnloadWave()");
        return false;
    }
    // UnloadSound()
    if (!umkaAddFunc(umka, "UnloadSound", &umkaUnloadSound)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UnloadSound()");
        return false;
    }
    // ExportWave()
    if (!umkaAddFunc(umka, "ExportWave", &umkaExportWave)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ExportWave()");
        return false;
    }
    // ExportWaveAsCode()
    if (!umkaAddFunc(umka, "ExportWaveAsCode", &umkaExportWaveAsCode)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ExportWaveAsCode()");
        return false;
    }
    // PlaySound()
    if (!umkaAddFunc(umka, "PlaySound", &umkaPlaySound)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function PlaySound()");
        return false;
    }
    // StopSound()
    if (!umkaAddFunc(umka, "StopSound", &umkaStopSound)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function StopSound()");
        return false;
    }
    // PauseSound()
    if (!umkaAddFunc(umka, "PauseSound", &umkaPauseSound)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function PauseSound()");
        return false;
    }
    // ResumeSound()
    if (!umkaAddFunc(umka, "ResumeSound", &umkaResumeSound)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ResumeSound()");
        return false;
    }
    // PlaySoundMulti()
    if (!umkaAddFunc(umka, "PlaySoundMulti", &umkaPlaySoundMulti)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function PlaySoundMulti()");
        return false;
    }
    // StopSoundMulti()
    if (!umkaAddFunc(umka, "StopSoundMulti", &umkaStopSoundMulti)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function StopSoundMulti()");
        return false;
    }
    // GetSoundsPlaying()
    if (!umkaAddFunc(umka, "GetSoundsPlaying", &umkaGetSoundsPlaying)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetSoundsPlaying()");
        return false;
    }
    // IsSoundPlaying()
    if (!umkaAddFunc(umka, "IsSoundPlaying", &umkaIsSoundPlaying)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function IsSoundPlaying()");
        return false;
    }
    // SetSoundVolume()
    if (!umkaAddFunc(umka, "SetSoundVolume", &umkaSetSoundVolume)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetSoundVolume()");
        return false;
    }
    // SetSoundPitch()
    if (!umkaAddFunc(umka, "SetSoundPitch", &umkaSetSoundPitch)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetSoundPitch()");
        return false;
    }
    // SetSoundPan()
    if (!umkaAddFunc(umka, "SetSoundPan", &umkaSetSoundPan)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetSoundPan()");
        return false;
    }
    // WaveCopy()
    if (!umkaAddFunc(umka, "WaveCopy", &umkaWaveCopy)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function WaveCopy()");
        return false;
    }
    // WaveCrop()
    if (!umkaAddFunc(umka, "WaveCrop", &umkaWaveCrop)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function WaveCrop()");
        return false;
    }
    // WaveFormat()
    if (!umkaAddFunc(umka, "WaveFormat", &umkaWaveFormat)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function WaveFormat()");
        return false;
    }
    // LoadWaveSamples()
    if (!umkaAddFunc(umka, "LoadWaveSamples", &umkaLoadWaveSamples)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadWaveSamples()");
        return false;
    }
    // UnloadWaveSamples()
    if (!umkaAddFunc(umka, "UnloadWaveSamples", &umkaUnloadWaveSamples)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UnloadWaveSamples()");
        return false;
    }
    // LoadMusicStream()
    if (!umkaAddFunc(umka, "LoadMusicStream", &umkaLoadMusicStream)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadMusicStream()");
        return false;
    }
    // LoadMusicStreamFromMemory()
    if (!umkaAddFunc(umka, "LoadMusicStreamFromMemory", &umkaLoadMusicStreamFromMemory)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadMusicStreamFromMemory()");
        return false;
    }
    // UnloadMusicStream()
    if (!umkaAddFunc(umka, "UnloadMusicStream", &umkaUnloadMusicStream)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UnloadMusicStream()");
        return false;
    }
    // PlayMusicStream()
    if (!umkaAddFunc(umka, "PlayMusicStream", &umkaPlayMusicStream)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function PlayMusicStream()");
        return false;
    }
    // IsMusicStreamPlaying()
    if (!umkaAddFunc(umka, "IsMusicStreamPlaying", &umkaIsMusicStreamPlaying)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function IsMusicStreamPlaying()");
        return false;
    }
    // UpdateMusicStream()
    if (!umkaAddFunc(umka, "UpdateMusicStream", &umkaUpdateMusicStream)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UpdateMusicStream()");
        return false;
    }
    // StopMusicStream()
    if (!umkaAddFunc(umka, "StopMusicStream", &umkaStopMusicStream)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function StopMusicStream()");
        return false;
    }
    // PauseMusicStream()
    if (!umkaAddFunc(umka, "PauseMusicStream", &umkaPauseMusicStream)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function PauseMusicStream()");
        return false;
    }
    // ResumeMusicStream()
    if (!umkaAddFunc(umka, "ResumeMusicStream", &umkaResumeMusicStream)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ResumeMusicStream()");
        return false;
    }
    // SeekMusicStream()
    if (!umkaAddFunc(umka, "SeekMusicStream", &umkaSeekMusicStream)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SeekMusicStream()");
        return false;
    }
    // SetMusicVolume()
    if (!umkaAddFunc(umka, "SetMusicVolume", &umkaSetMusicVolume)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetMusicVolume()");
        return false;
    }
    // SetMusicPitch()
    if (!umkaAddFunc(umka, "SetMusicPitch", &umkaSetMusicPitch)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetMusicPitch()");
        return false;
    }
    // SetMusicPan()
    if (!umkaAddFunc(umka, "SetMusicPan", &umkaSetMusicPan)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetMusicPan()");
        return false;
    }
    // GetMusicTimeLength()
    if (!umkaAddFunc(umka, "GetMusicTimeLength", &umkaGetMusicTimeLength)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetMusicTimeLength()");
        return false;
    }
    // GetMusicTimePlayed()
    if (!umkaAddFunc(umka, "GetMusicTimePlayed", &umkaGetMusicTimePlayed)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetMusicTimePlayed()");
        return false;
    }
    // LoadAudioStream()
    if (!umkaAddFunc(umka, "LoadAudioStream", &umkaLoadAudioStream)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadAudioStream()");
        return false;
    }
    // UnloadAudioStream()
    if (!umkaAddFunc(umka, "UnloadAudioStream", &umkaUnloadAudioStream)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UnloadAudioStream()");
        return false;
    }
    // UpdateAudioStream()
    if (!umkaAddFunc(umka, "UpdateAudioStream", &umkaUpdateAudioStream)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UpdateAudioStream()");
        return false;
    }
    // IsAudioStreamProcessed()
    if (!umkaAddFunc(umka, "IsAudioStreamProcessed", &umkaIsAudioStreamProcessed)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function IsAudioStreamProcessed()");
        return false;
    }
    // PlayAudioStream()
    if (!umkaAddFunc(umka, "PlayAudioStream", &umkaPlayAudioStream)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function PlayAudioStream()");
        return false;
    }
    // PauseAudioStream()
    if (!umkaAddFunc(umka, "PauseAudioStream", &umkaPauseAudioStream)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function PauseAudioStream()");
        return false;
    }
    // ResumeAudioStream()
    if (!umkaAddFunc(umka, "ResumeAudioStream", &umkaResumeAudioStream)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ResumeAudioStream()");
        return false;
    }
    // IsAudioStreamPlaying()
    if (!umkaAddFunc(umka, "IsAudioStreamPlaying", &umkaIsAudioStreamPlaying)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function IsAudioStreamPlaying()");
        return false;
    }
    // StopAudioStream()
    if (!umkaAddFunc(umka, "StopAudioStream", &umkaStopAudioStream)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function StopAudioStream()");
        return false;
    }
    // SetAudioStreamVolume()
    if (!umkaAddFunc(umka, "SetAudioStreamVolume", &umkaSetAudioStreamVolume)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetAudioStreamVolume()");
        return false;
    }
    // SetAudioStreamPitch()
    if (!umkaAddFunc(umka, "SetAudioStreamPitch", &umkaSetAudioStreamPitch)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetAudioStreamPitch()");
        return false;
    }
    // SetAudioStreamPan()
    if (!umkaAddFunc(umka, "SetAudioStreamPan", &umkaSetAudioStreamPan)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetAudioStreamPan()");
        return false;
    }
    // SetAudioStreamBufferSizeDefault()
    if (!umkaAddFunc(umka, "SetAudioStreamBufferSizeDefault", &umkaSetAudioStreamBufferSizeDefault)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetAudioStreamBufferSizeDefault()");
        return false;
    }
    // Skipping SetAudioStreamCallback
    // Skipping AttachAudioStreamProcessor
    // Skipping DetachAudioStreamProcessor
    // Clamp()
    if (!umkaAddFunc(umka, "Clamp", &umkaClamp)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Clamp()");
        return false;
    }
    // Lerp()
    if (!umkaAddFunc(umka, "Lerp", &umkaLerp)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Lerp()");
        return false;
    }
    // Normalize()
    if (!umkaAddFunc(umka, "Normalize", &umkaNormalize)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Normalize()");
        return false;
    }
    // Remap()
    if (!umkaAddFunc(umka, "Remap", &umkaRemap)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Remap()");
        return false;
    }
    // Wrap()
    if (!umkaAddFunc(umka, "Wrap", &umkaWrap)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Wrap()");
        return false;
    }
    // FloatEquals()
    if (!umkaAddFunc(umka, "FloatEquals", &umkaFloatEquals)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function FloatEquals()");
        return false;
    }
    // Vector2Zero()
    if (!umkaAddFunc(umka, "Vector2Zero", &umkaVector2Zero)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector2Zero()");
        return false;
    }
    // Vector2One()
    if (!umkaAddFunc(umka, "Vector2One", &umkaVector2One)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector2One()");
        return false;
    }
    // Vector2Add()
    if (!umkaAddFunc(umka, "Vector2Add", &umkaVector2Add)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector2Add()");
        return false;
    }
    // Vector2AddValue()
    if (!umkaAddFunc(umka, "Vector2AddValue", &umkaVector2AddValue)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector2AddValue()");
        return false;
    }
    // Vector2Subtract()
    if (!umkaAddFunc(umka, "Vector2Subtract", &umkaVector2Subtract)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector2Subtract()");
        return false;
    }
    // Vector2SubtractValue()
    if (!umkaAddFunc(umka, "Vector2SubtractValue", &umkaVector2SubtractValue)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector2SubtractValue()");
        return false;
    }
    // Vector2Length()
    if (!umkaAddFunc(umka, "Vector2Length", &umkaVector2Length)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector2Length()");
        return false;
    }
    // Vector2LengthSqr()
    if (!umkaAddFunc(umka, "Vector2LengthSqr", &umkaVector2LengthSqr)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector2LengthSqr()");
        return false;
    }
    // Vector2DotProduct()
    if (!umkaAddFunc(umka, "Vector2DotProduct", &umkaVector2DotProduct)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector2DotProduct()");
        return false;
    }
    // Vector2Distance()
    if (!umkaAddFunc(umka, "Vector2Distance", &umkaVector2Distance)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector2Distance()");
        return false;
    }
    // Vector2DistanceSqr()
    if (!umkaAddFunc(umka, "Vector2DistanceSqr", &umkaVector2DistanceSqr)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector2DistanceSqr()");
        return false;
    }
    // Vector2Angle()
    if (!umkaAddFunc(umka, "Vector2Angle", &umkaVector2Angle)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector2Angle()");
        return false;
    }
    // Vector2Scale()
    if (!umkaAddFunc(umka, "Vector2Scale", &umkaVector2Scale)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector2Scale()");
        return false;
    }
    // Vector2Multiply()
    if (!umkaAddFunc(umka, "Vector2Multiply", &umkaVector2Multiply)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector2Multiply()");
        return false;
    }
    // Vector2Negate()
    if (!umkaAddFunc(umka, "Vector2Negate", &umkaVector2Negate)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector2Negate()");
        return false;
    }
    // Vector2Divide()
    if (!umkaAddFunc(umka, "Vector2Divide", &umkaVector2Divide)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector2Divide()");
        return false;
    }
    // Vector2Normalize()
    if (!umkaAddFunc(umka, "Vector2Normalize", &umkaVector2Normalize)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector2Normalize()");
        return false;
    }
    // Vector2Transform()
    if (!umkaAddFunc(umka, "Vector2Transform", &umkaVector2Transform)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector2Transform()");
        return false;
    }
    // Vector2Lerp()
    if (!umkaAddFunc(umka, "Vector2Lerp", &umkaVector2Lerp)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector2Lerp()");
        return false;
    }
    // Vector2Reflect()
    if (!umkaAddFunc(umka, "Vector2Reflect", &umkaVector2Reflect)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector2Reflect()");
        return false;
    }
    // Vector2Rotate()
    if (!umkaAddFunc(umka, "Vector2Rotate", &umkaVector2Rotate)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector2Rotate()");
        return false;
    }
    // Vector2MoveTowards()
    if (!umkaAddFunc(umka, "Vector2MoveTowards", &umkaVector2MoveTowards)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector2MoveTowards()");
        return false;
    }
    // Vector2Invert()
    if (!umkaAddFunc(umka, "Vector2Invert", &umkaVector2Invert)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector2Invert()");
        return false;
    }
    // Vector2Clamp()
    if (!umkaAddFunc(umka, "Vector2Clamp", &umkaVector2Clamp)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector2Clamp()");
        return false;
    }
    // Vector2ClampValue()
    if (!umkaAddFunc(umka, "Vector2ClampValue", &umkaVector2ClampValue)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector2ClampValue()");
        return false;
    }
    // Vector2Equals()
    if (!umkaAddFunc(umka, "Vector2Equals", &umkaVector2Equals)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector2Equals()");
        return false;
    }
    // Vector3Zero()
    if (!umkaAddFunc(umka, "Vector3Zero", &umkaVector3Zero)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3Zero()");
        return false;
    }
    // Vector3One()
    if (!umkaAddFunc(umka, "Vector3One", &umkaVector3One)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3One()");
        return false;
    }
    // Vector3Add()
    if (!umkaAddFunc(umka, "Vector3Add", &umkaVector3Add)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3Add()");
        return false;
    }
    // Vector3AddValue()
    if (!umkaAddFunc(umka, "Vector3AddValue", &umkaVector3AddValue)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3AddValue()");
        return false;
    }
    // Vector3Subtract()
    if (!umkaAddFunc(umka, "Vector3Subtract", &umkaVector3Subtract)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3Subtract()");
        return false;
    }
    // Vector3SubtractValue()
    if (!umkaAddFunc(umka, "Vector3SubtractValue", &umkaVector3SubtractValue)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3SubtractValue()");
        return false;
    }
    // Vector3Scale()
    if (!umkaAddFunc(umka, "Vector3Scale", &umkaVector3Scale)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3Scale()");
        return false;
    }
    // Vector3Multiply()
    if (!umkaAddFunc(umka, "Vector3Multiply", &umkaVector3Multiply)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3Multiply()");
        return false;
    }
    // Vector3CrossProduct()
    if (!umkaAddFunc(umka, "Vector3CrossProduct", &umkaVector3CrossProduct)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3CrossProduct()");
        return false;
    }
    // Vector3Perpendicular()
    if (!umkaAddFunc(umka, "Vector3Perpendicular", &umkaVector3Perpendicular)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3Perpendicular()");
        return false;
    }
    // Vector3Length()
    if (!umkaAddFunc(umka, "Vector3Length", &umkaVector3Length)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3Length()");
        return false;
    }
    // Vector3LengthSqr()
    if (!umkaAddFunc(umka, "Vector3LengthSqr", &umkaVector3LengthSqr)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3LengthSqr()");
        return false;
    }
    // Vector3DotProduct()
    if (!umkaAddFunc(umka, "Vector3DotProduct", &umkaVector3DotProduct)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3DotProduct()");
        return false;
    }
    // Vector3Distance()
    if (!umkaAddFunc(umka, "Vector3Distance", &umkaVector3Distance)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3Distance()");
        return false;
    }
    // Vector3DistanceSqr()
    if (!umkaAddFunc(umka, "Vector3DistanceSqr", &umkaVector3DistanceSqr)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3DistanceSqr()");
        return false;
    }
    // Vector3Angle()
    if (!umkaAddFunc(umka, "Vector3Angle", &umkaVector3Angle)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3Angle()");
        return false;
    }
    // Vector3Negate()
    if (!umkaAddFunc(umka, "Vector3Negate", &umkaVector3Negate)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3Negate()");
        return false;
    }
    // Vector3Divide()
    if (!umkaAddFunc(umka, "Vector3Divide", &umkaVector3Divide)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3Divide()");
        return false;
    }
    // Vector3Normalize()
    if (!umkaAddFunc(umka, "Vector3Normalize", &umkaVector3Normalize)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3Normalize()");
        return false;
    }
    // Vector3OrthoNormalize()
    if (!umkaAddFunc(umka, "Vector3OrthoNormalize", &umkaVector3OrthoNormalize)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3OrthoNormalize()");
        return false;
    }
    // Vector3Transform()
    if (!umkaAddFunc(umka, "Vector3Transform", &umkaVector3Transform)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3Transform()");
        return false;
    }
    // Vector3RotateByQuaternion()
    if (!umkaAddFunc(umka, "Vector3RotateByQuaternion", &umkaVector3RotateByQuaternion)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3RotateByQuaternion()");
        return false;
    }
    // Vector3RotateByAxisAngle()
    if (!umkaAddFunc(umka, "Vector3RotateByAxisAngle", &umkaVector3RotateByAxisAngle)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3RotateByAxisAngle()");
        return false;
    }
    // Vector3Lerp()
    if (!umkaAddFunc(umka, "Vector3Lerp", &umkaVector3Lerp)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3Lerp()");
        return false;
    }
    // Vector3Reflect()
    if (!umkaAddFunc(umka, "Vector3Reflect", &umkaVector3Reflect)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3Reflect()");
        return false;
    }
    // Vector3Min()
    if (!umkaAddFunc(umka, "Vector3Min", &umkaVector3Min)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3Min()");
        return false;
    }
    // Vector3Max()
    if (!umkaAddFunc(umka, "Vector3Max", &umkaVector3Max)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3Max()");
        return false;
    }
    // Vector3Barycenter()
    if (!umkaAddFunc(umka, "Vector3Barycenter", &umkaVector3Barycenter)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3Barycenter()");
        return false;
    }
    // Vector3Unproject()
    if (!umkaAddFunc(umka, "Vector3Unproject", &umkaVector3Unproject)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3Unproject()");
        return false;
    }
    // Vector3ToFloatV()
    if (!umkaAddFunc(umka, "Vector3ToFloatV", &umkaVector3ToFloatV)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3ToFloatV()");
        return false;
    }
    // Vector3Invert()
    if (!umkaAddFunc(umka, "Vector3Invert", &umkaVector3Invert)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3Invert()");
        return false;
    }
    // Vector3Clamp()
    if (!umkaAddFunc(umka, "Vector3Clamp", &umkaVector3Clamp)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3Clamp()");
        return false;
    }
    // Vector3ClampValue()
    if (!umkaAddFunc(umka, "Vector3ClampValue", &umkaVector3ClampValue)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3ClampValue()");
        return false;
    }
    // Vector3Equals()
    if (!umkaAddFunc(umka, "Vector3Equals", &umkaVector3Equals)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3Equals()");
        return false;
    }
    // Vector3Refract()
    if (!umkaAddFunc(umka, "Vector3Refract", &umkaVector3Refract)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3Refract()");
        return false;
    }
    // MatrixDeterminant()
    if (!umkaAddFunc(umka, "MatrixDeterminant", &umkaMatrixDeterminant)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function MatrixDeterminant()");
        return false;
    }
    // MatrixTrace()
    if (!umkaAddFunc(umka, "MatrixTrace", &umkaMatrixTrace)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function MatrixTrace()");
        return false;
    }
    // MatrixTranspose()
    if (!umkaAddFunc(umka, "MatrixTranspose", &umkaMatrixTranspose)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function MatrixTranspose()");
        return false;
    }
    // MatrixInvert()
    if (!umkaAddFunc(umka, "MatrixInvert", &umkaMatrixInvert)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function MatrixInvert()");
        return false;
    }
    // MatrixIdentity()
    if (!umkaAddFunc(umka, "MatrixIdentity", &umkaMatrixIdentity)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function MatrixIdentity()");
        return false;
    }
    // MatrixAdd()
    if (!umkaAddFunc(umka, "MatrixAdd", &umkaMatrixAdd)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function MatrixAdd()");
        return false;
    }
    // MatrixSubtract()
    if (!umkaAddFunc(umka, "MatrixSubtract", &umkaMatrixSubtract)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function MatrixSubtract()");
        return false;
    }
    // MatrixMultiply()
    if (!umkaAddFunc(umka, "MatrixMultiply", &umkaMatrixMultiply)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function MatrixMultiply()");
        return false;
    }
    // MatrixTranslate()
    if (!umkaAddFunc(umka, "MatrixTranslate", &umkaMatrixTranslate)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function MatrixTranslate()");
        return false;
    }
    // MatrixRotate()
    if (!umkaAddFunc(umka, "MatrixRotate", &umkaMatrixRotate)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function MatrixRotate()");
        return false;
    }
    // MatrixRotateX()
    if (!umkaAddFunc(umka, "MatrixRotateX", &umkaMatrixRotateX)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function MatrixRotateX()");
        return false;
    }
    // MatrixRotateY()
    if (!umkaAddFunc(umka, "MatrixRotateY", &umkaMatrixRotateY)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function MatrixRotateY()");
        return false;
    }
    // MatrixRotateZ()
    if (!umkaAddFunc(umka, "MatrixRotateZ", &umkaMatrixRotateZ)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function MatrixRotateZ()");
        return false;
    }
    // MatrixRotateXYZ()
    if (!umkaAddFunc(umka, "MatrixRotateXYZ", &umkaMatrixRotateXYZ)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function MatrixRotateXYZ()");
        return false;
    }
    // MatrixRotateZYX()
    if (!umkaAddFunc(umka, "MatrixRotateZYX", &umkaMatrixRotateZYX)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function MatrixRotateZYX()");
        return false;
    }
    // MatrixScale()
    if (!umkaAddFunc(umka, "MatrixScale", &umkaMatrixScale)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function MatrixScale()");
        return false;
    }
    // MatrixFrustum()
    if (!umkaAddFunc(umka, "MatrixFrustum", &umkaMatrixFrustum)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function MatrixFrustum()");
        return false;
    }
    // MatrixPerspective()
    if (!umkaAddFunc(umka, "MatrixPerspective", &umkaMatrixPerspective)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function MatrixPerspective()");
        return false;
    }
    // MatrixOrtho()
    if (!umkaAddFunc(umka, "MatrixOrtho", &umkaMatrixOrtho)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function MatrixOrtho()");
        return false;
    }
    // MatrixLookAt()
    if (!umkaAddFunc(umka, "MatrixLookAt", &umkaMatrixLookAt)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function MatrixLookAt()");
        return false;
    }
    // MatrixToFloatV()
    if (!umkaAddFunc(umka, "MatrixToFloatV", &umkaMatrixToFloatV)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function MatrixToFloatV()");
        return false;
    }
    // QuaternionAdd()
    if (!umkaAddFunc(umka, "QuaternionAdd", &umkaQuaternionAdd)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function QuaternionAdd()");
        return false;
    }
    // QuaternionAddValue()
    if (!umkaAddFunc(umka, "QuaternionAddValue", &umkaQuaternionAddValue)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function QuaternionAddValue()");
        return false;
    }
    // QuaternionSubtract()
    if (!umkaAddFunc(umka, "QuaternionSubtract", &umkaQuaternionSubtract)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function QuaternionSubtract()");
        return false;
    }
    // QuaternionSubtractValue()
    if (!umkaAddFunc(umka, "QuaternionSubtractValue", &umkaQuaternionSubtractValue)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function QuaternionSubtractValue()");
        return false;
    }
    // QuaternionIdentity()
    if (!umkaAddFunc(umka, "QuaternionIdentity", &umkaQuaternionIdentity)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function QuaternionIdentity()");
        return false;
    }
    // QuaternionLength()
    if (!umkaAddFunc(umka, "QuaternionLength", &umkaQuaternionLength)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function QuaternionLength()");
        return false;
    }
    // QuaternionNormalize()
    if (!umkaAddFunc(umka, "QuaternionNormalize", &umkaQuaternionNormalize)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function QuaternionNormalize()");
        return false;
    }
    // QuaternionInvert()
    if (!umkaAddFunc(umka, "QuaternionInvert", &umkaQuaternionInvert)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function QuaternionInvert()");
        return false;
    }
    // QuaternionMultiply()
    if (!umkaAddFunc(umka, "QuaternionMultiply", &umkaQuaternionMultiply)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function QuaternionMultiply()");
        return false;
    }
    // QuaternionScale()
    if (!umkaAddFunc(umka, "QuaternionScale", &umkaQuaternionScale)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function QuaternionScale()");
        return false;
    }
    // QuaternionDivide()
    if (!umkaAddFunc(umka, "QuaternionDivide", &umkaQuaternionDivide)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function QuaternionDivide()");
        return false;
    }
    // QuaternionLerp()
    if (!umkaAddFunc(umka, "QuaternionLerp", &umkaQuaternionLerp)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function QuaternionLerp()");
        return false;
    }
    // QuaternionNlerp()
    if (!umkaAddFunc(umka, "QuaternionNlerp", &umkaQuaternionNlerp)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function QuaternionNlerp()");
        return false;
    }
    // QuaternionSlerp()
    if (!umkaAddFunc(umka, "QuaternionSlerp", &umkaQuaternionSlerp)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function QuaternionSlerp()");
        return false;
    }
    // QuaternionFromVector3ToVector3()
    if (!umkaAddFunc(umka, "QuaternionFromVector3ToVector3", &umkaQuaternionFromVector3ToVector3)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function QuaternionFromVector3ToVector3()");
        return false;
    }
    // QuaternionFromMatrix()
    if (!umkaAddFunc(umka, "QuaternionFromMatrix", &umkaQuaternionFromMatrix)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function QuaternionFromMatrix()");
        return false;
    }
    // QuaternionToMatrix()
    if (!umkaAddFunc(umka, "QuaternionToMatrix", &umkaQuaternionToMatrix)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function QuaternionToMatrix()");
        return false;
    }
    // QuaternionFromAxisAngle()
    if (!umkaAddFunc(umka, "QuaternionFromAxisAngle", &umkaQuaternionFromAxisAngle)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function QuaternionFromAxisAngle()");
        return false;
    }
    // QuaternionToAxisAngle()
    if (!umkaAddFunc(umka, "QuaternionToAxisAngle", &umkaQuaternionToAxisAngle)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function QuaternionToAxisAngle()");
        return false;
    }
    // QuaternionFromEuler()
    if (!umkaAddFunc(umka, "QuaternionFromEuler", &umkaQuaternionFromEuler)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function QuaternionFromEuler()");
        return false;
    }
    // QuaternionToEuler()
    if (!umkaAddFunc(umka, "QuaternionToEuler", &umkaQuaternionToEuler)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function QuaternionToEuler()");
        return false;
    }
    // QuaternionTransform()
    if (!umkaAddFunc(umka, "QuaternionTransform", &umkaQuaternionTransform)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function QuaternionTransform()");
        return false;
    }
    // QuaternionEquals()
    if (!umkaAddFunc(umka, "QuaternionEquals", &umkaQuaternionEquals)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function QuaternionEquals()");
        return false;
    }

    /**
     * The code for the raylib umka module.
     */
    const char* moduleCode =
        // Structures
        /* 0001 */ "type (\n"
        /* 0002 */ "  Vector2* = struct {\n"
        /* 0003 */ "    x: real32\n"
        /* 0004 */ "    y: real32\n"
        /* 0005 */ "  }\n"
        /* 0006 */ "  Vector3* = struct {\n"
        /* 0007 */ "    x: real32\n"
        /* 0008 */ "    y: real32\n"
        /* 0009 */ "    z: real32\n"
        /* 0010 */ "  }\n"
        /* 0011 */ "  Vector4* = struct {\n"
        /* 0012 */ "    x: real32\n"
        /* 0013 */ "    y: real32\n"
        /* 0014 */ "    z: real32\n"
        /* 0015 */ "    w: real32\n"
        /* 0016 */ "  }\n"
        /* 0017 */ "  Matrix* = struct {\n"
        /* 0018 */ "    m0: real32\n"
        /* 0019 */ "    m4: real32\n"
        /* 0020 */ "    m8: real32\n"
        /* 0021 */ "    m12: real32\n"
        /* 0022 */ "    m1: real32\n"
        /* 0023 */ "    m5: real32\n"
        /* 0024 */ "    m9: real32\n"
        /* 0025 */ "    m13: real32\n"
        /* 0026 */ "    m2: real32\n"
        /* 0027 */ "    m6: real32\n"
        /* 0028 */ "    m10: real32\n"
        /* 0029 */ "    m14: real32\n"
        /* 0030 */ "    m3: real32\n"
        /* 0031 */ "    m7: real32\n"
        /* 0032 */ "    m11: real32\n"
        /* 0033 */ "    m15: real32\n"
        /* 0034 */ "  }\n"
        /* 0035 */ "  Color* = struct {\n"
        /* 0036 */ "    r: uint8\n"
        /* 0037 */ "    g: uint8\n"
        /* 0038 */ "    b: uint8\n"
        /* 0039 */ "    a: uint8\n"
        /* 0040 */ "  }\n"
        /* 0041 */ "  Rectangle* = struct {\n"
        /* 0042 */ "    x: real32\n"
        /* 0043 */ "    y: real32\n"
        /* 0044 */ "    width: real32\n"
        /* 0045 */ "    height: real32\n"
        /* 0046 */ "  }\n"
        /* 0047 */ "  Image* = struct {\n"
        /* 0048 */ "    data: ^void\n"
        /* 0049 */ "    width: int32\n"
        /* 0050 */ "    height: int32\n"
        /* 0051 */ "    mipmaps: int32\n"
        /* 0052 */ "    format: int32\n"
        /* 0053 */ "  }\n"
        /* 0054 */ "  Texture* = struct {\n"
        /* 0055 */ "    id: uint32\n"
        /* 0056 */ "    width: int32\n"
        /* 0057 */ "    height: int32\n"
        /* 0058 */ "    mipmaps: int32\n"
        /* 0059 */ "    format: int32\n"
        /* 0060 */ "  }\n"
        /* 0061 */ "  RenderTexture* = struct {\n"
        /* 0062 */ "    id: uint32\n"
        /* 0063 */ "    texture: Texture\n"
        /* 0064 */ "    depth: Texture\n"
        /* 0065 */ "  }\n"
        /* 0066 */ "  NPatchInfo* = struct {\n"
        /* 0067 */ "    source: Rectangle\n"
        /* 0068 */ "    left: int32\n"
        /* 0069 */ "    top: int32\n"
        /* 0070 */ "    right: int32\n"
        /* 0071 */ "    bottom: int32\n"
        /* 0072 */ "    layout: int32\n"
        /* 0073 */ "  }\n"
        /* 0074 */ "  GlyphInfo* = struct {\n"
        /* 0075 */ "    value: int32\n"
        /* 0076 */ "    offsetX: int32\n"
        /* 0077 */ "    offsetY: int32\n"
        /* 0078 */ "    advanceX: int32\n"
        /* 0079 */ "    image: Image\n"
        /* 0080 */ "  }\n"
        /* 0081 */ "  Font* = struct {\n"
        /* 0082 */ "    baseSize: int32\n"
        /* 0083 */ "    glyphCount: int32\n"
        /* 0084 */ "    glyphPadding: int32\n"
        /* 0085 */ "    texture: Texture\n"
        /* 0086 */ "    recs: ^Rectangle\n"
        /* 0087 */ "    glyphs: ^GlyphInfo\n"
        /* 0088 */ "  }\n"
        /* 0089 */ "  Camera3D* = struct {\n"
        /* 0090 */ "    position: Vector3\n"
        /* 0091 */ "    target: Vector3\n"
        /* 0092 */ "    up: Vector3\n"
        /* 0093 */ "    fovy: real32\n"
        /* 0094 */ "    projection: int32\n"
        /* 0095 */ "  }\n"
        /* 0096 */ "  Camera2D* = struct {\n"
        /* 0097 */ "    offset: Vector2\n"
        /* 0098 */ "    target: Vector2\n"
        /* 0099 */ "    rotation: real32\n"
        /* 0100 */ "    zoom: real32\n"
        /* 0101 */ "  }\n"
        /* 0102 */ "  Mesh* = struct {\n"
        /* 0103 */ "    vertexCount: int32\n"
        /* 0104 */ "    triangleCount: int32\n"
        /* 0105 */ "    vertices: ^real32\n"
        /* 0106 */ "    texcoords: ^real32\n"
        /* 0107 */ "    texcoords2: ^real32\n"
        /* 0108 */ "    normals: ^real32\n"
        /* 0109 */ "    tangents: ^real32\n"
        /* 0110 */ "    colors: ^uint8\n"
        /* 0111 */ "    indices: ^uint16\n"
        /* 0112 */ "    animVertices: ^real32\n"
        /* 0113 */ "    animNormals: ^real32\n"
        /* 0114 */ "    boneIds: ^uint8\n"
        /* 0115 */ "    boneWeights: ^real32\n"
        /* 0116 */ "    vaoId: uint32\n"
        /* 0117 */ "    vboId: ^uint32\n"
        /* 0118 */ "  }\n"
        /* 0119 */ "  Shader* = struct {\n"
        /* 0120 */ "    id: uint32\n"
        /* 0121 */ "    locs: ^int32\n"
        /* 0122 */ "  }\n"
        /* 0123 */ "  MaterialMap* = struct {\n"
        /* 0124 */ "    texture: Texture\n"
        /* 0125 */ "    color: Color\n"
        /* 0126 */ "    value: real32\n"
        /* 0127 */ "  }\n"
        /* 0128 */ "  Material* = struct {\n"
        /* 0129 */ "    shader: Shader\n"
        /* 0130 */ "    maps: ^MaterialMap\n"
        /* 0131 */ "    params: [4]real32\n"
        /* 0132 */ "  }\n"
        /* 0133 */ "  Transform* = struct {\n"
        /* 0134 */ "    translation: Vector3\n"
        /* 0135 */ "    rotation: Vector4\n"
        /* 0136 */ "    scale: Vector3\n"
        /* 0137 */ "  }\n"
        /* 0138 */ "  BoneInfo* = struct {\n"
        /* 0139 */ "    name: [32]char\n"
        /* 0140 */ "    parent: int32\n"
        /* 0141 */ "  }\n"
        /* 0142 */ "  Model* = struct {\n"
        /* 0143 */ "    transform: Matrix\n"
        /* 0144 */ "    meshCount: int32\n"
        /* 0145 */ "    materialCount: int32\n"
        /* 0146 */ "    meshes: ^Mesh\n"
        /* 0147 */ "    materials: ^Material\n"
        /* 0148 */ "    meshMaterial: ^int32\n"
        /* 0149 */ "    boneCount: int32\n"
        /* 0150 */ "    bones: ^BoneInfo\n"
        /* 0151 */ "    bindPose: ^Transform\n"
        /* 0152 */ "  }\n"
        /* 0153 */ "  ModelAnimation* = struct {\n"
        /* 0154 */ "    boneCount: int32\n"
        /* 0155 */ "    frameCount: int32\n"
        /* 0156 */ "    bones: ^BoneInfo\n"
        /* 0157 */ "    framePoses: ^void\n"
        /* 0158 */ "  }\n"
        /* 0159 */ "  Ray* = struct {\n"
        /* 0160 */ "    position: Vector3\n"
        /* 0161 */ "    direction: Vector3\n"
        /* 0162 */ "  }\n"
        /* 0163 */ "  RayCollision* = struct {\n"
        /* 0164 */ "    hit: bool\n"
        /* 0165 */ "    distance: real32\n"
        /* 0166 */ "    point: Vector3\n"
        /* 0167 */ "    normal: Vector3\n"
        /* 0168 */ "  }\n"
        /* 0169 */ "  BoundingBox* = struct {\n"
        /* 0170 */ "    min: Vector3\n"
        /* 0171 */ "    max: Vector3\n"
        /* 0172 */ "  }\n"
        /* 0173 */ "  Wave* = struct {\n"
        /* 0174 */ "    frameCount: uint32\n"
        /* 0175 */ "    sampleRate: uint32\n"
        /* 0176 */ "    sampleSize: uint32\n"
        /* 0177 */ "    channels: uint32\n"
        /* 0178 */ "    data: ^void\n"
        /* 0179 */ "  }\n"
        /* 0180 */ "  AudioStream* = struct {\n"
        /* 0181 */ "    buffer: ^void\n"
        /* 0182 */ "    processor: ^void\n"
        /* 0183 */ "    sampleRate: uint32\n"
        /* 0184 */ "    sampleSize: uint32\n"
        /* 0185 */ "    channels: uint32\n"
        /* 0186 */ "  }\n"
        /* 0187 */ "  Sound* = struct {\n"
        /* 0188 */ "    stream: AudioStream\n"
        /* 0189 */ "    frameCount: uint32\n"
        /* 0190 */ "  }\n"
        /* 0191 */ "  Music* = struct {\n"
        /* 0192 */ "    stream: AudioStream\n"
        /* 0193 */ "    frameCount: uint32\n"
        /* 0194 */ "    looping: bool\n"
        /* 0195 */ "    ctxType: int32\n"
        /* 0196 */ "    ctxData: ^void\n"
        /* 0197 */ "  }\n"
        /* 0198 */ "  VrDeviceInfo* = struct {\n"
        /* 0199 */ "    hResolution: int32\n"
        /* 0200 */ "    vResolution: int32\n"
        /* 0201 */ "    hScreenSize: real32\n"
        /* 0202 */ "    vScreenSize: real32\n"
        /* 0203 */ "    vScreenCenter: real32\n"
        /* 0204 */ "    eyeToScreenDistance: real32\n"
        /* 0205 */ "    lensSeparationDistance: real32\n"
        /* 0206 */ "    interpupillaryDistance: real32\n"
        /* 0207 */ "    lensDistortionValues: [4]real32\n"
        /* 0208 */ "    chromaAbCorrection: [4]real32\n"
        /* 0209 */ "  }\n"
        /* 0210 */ "  VrStereoConfig* = struct {\n"
        /* 0211 */ "    projection: [2]Matrix\n"
        /* 0212 */ "    viewOffset: [2]Matrix\n"
        /* 0213 */ "    leftLensCenter: [2]real32\n"
        /* 0214 */ "    rightLensCenter: [2]real32\n"
        /* 0215 */ "    leftScreenCenter: [2]real32\n"
        /* 0216 */ "    rightScreenCenter: [2]real32\n"
        /* 0217 */ "    scale: [2]real32\n"
        /* 0218 */ "    scaleIn: [2]real32\n"
        /* 0219 */ "  }\n"
        /* 0220 */ "  FilePathList* = struct {\n"
        /* 0221 */ "    capacity: uint32\n"
        /* 0222 */ "    count: uint32\n"
        /* 0223 */ "    paths: ^str\n"
        /* 0224 */ "  }\n"
        /* 0225 */ "  float3* = struct {\n"
        /* 0226 */ "    v: [3]real32\n"
        /* 0227 */ "  }\n"
        /* 0228 */ "  float16* = struct {\n"
        /* 0229 */ "    v: [16]real32\n"
        /* 0230 */ "  }\n"
        /* 0231 */ ")\n"

        // Callbacks
        /* 0232 */ "type (\n"
        // Skipped TraceLogCallback
        /* 0233 */ "    LoadFileDataCallback = fn(fileName: str, bytesRead: ^uint32): ^uint8\n"
        /* 0234 */ "    SaveFileDataCallback = fn(fileName: str, data: ^void, bytesToWrite: uint32): bool\n"
        /* 0235 */ "    LoadFileTextCallback = fn(fileName: str): str\n"
        /* 0236 */ "    SaveFileTextCallback = fn(fileName: str, text: str): bool\n"
        /* 0237 */ "    AudioCallback = fn(bufferData: ^void, frames: uint32)\n"
        /* 0238 */ ")\n"

        // Function Declarations
        /* 0239 */ "fn InitWindow*(width: int32, height: int32, title: str)\n"
        /* 0240 */ "fn WindowShouldClose*(): bool\n"
        /* 0241 */ "fn CloseWindow*()\n"
        /* 0242 */ "fn IsWindowReady*(): bool\n"
        /* 0243 */ "fn IsWindowFullscreen*(): bool\n"
        /* 0244 */ "fn IsWindowHidden*(): bool\n"
        /* 0245 */ "fn IsWindowMinimized*(): bool\n"
        /* 0246 */ "fn IsWindowMaximized*(): bool\n"
        /* 0247 */ "fn IsWindowFocused*(): bool\n"
        /* 0248 */ "fn IsWindowResized*(): bool\n"
        /* 0249 */ "fn IsWindowState*(flag: uint32): bool\n"
        /* 0250 */ "fn SetWindowState*(flags: uint32)\n"
        /* 0251 */ "fn ClearWindowState*(flags: uint32)\n"
        /* 0252 */ "fn ToggleFullscreen*()\n"
        /* 0253 */ "fn MaximizeWindow*()\n"
        /* 0254 */ "fn MinimizeWindow*()\n"
        /* 0255 */ "fn RestoreWindow*()\n"
        /* 0256 */ "fn SetWindowIcon*(image: Image)\n"
        /* 0257 */ "fn SetWindowTitle*(title: str)\n"
        /* 0258 */ "fn SetWindowPosition*(x: int32, y: int32)\n"
        /* 0259 */ "fn SetWindowMonitor*(monitor: int32)\n"
        /* 0260 */ "fn SetWindowMinSize*(width: int32, height: int32)\n"
        /* 0261 */ "fn SetWindowSize*(width: int32, height: int32)\n"
        /* 0262 */ "fn SetWindowOpacity*(opacity: real32)\n"
        /* 0263 */ "fn GetWindowHandle*(): ^void\n"
        /* 0264 */ "fn GetScreenWidth*(): int32\n"
        /* 0265 */ "fn GetScreenHeight*(): int32\n"
        /* 0266 */ "fn GetRenderWidth*(): int32\n"
        /* 0267 */ "fn GetRenderHeight*(): int32\n"
        /* 0268 */ "fn GetMonitorCount*(): int32\n"
        /* 0269 */ "fn GetCurrentMonitor*(): int32\n"
        /* 0270 */ "fn GetMonitorPosition*(monitor: int32): Vector2\n"
        /* 0271 */ "fn GetMonitorWidth*(monitor: int32): int32\n"
        /* 0272 */ "fn GetMonitorHeight*(monitor: int32): int32\n"
        /* 0273 */ "fn GetMonitorPhysicalWidth*(monitor: int32): int32\n"
        /* 0274 */ "fn GetMonitorPhysicalHeight*(monitor: int32): int32\n"
        /* 0275 */ "fn GetMonitorRefreshRate*(monitor: int32): int32\n"
        /* 0276 */ "fn GetWindowPosition*(): Vector2\n"
        /* 0277 */ "fn GetWindowScaleDPI*(): Vector2\n"
        /* 0278 */ "fn GetMonitorName*(monitor: int32): str\n"
        /* 0279 */ "fn SetClipboardText*(text: str)\n"
        /* 0280 */ "fn GetClipboardText*(): str\n"
        /* 0281 */ "fn EnableEventWaiting*()\n"
        /* 0282 */ "fn DisableEventWaiting*()\n"
        /* 0283 */ "fn SwapScreenBuffer*()\n"
        /* 0284 */ "fn PollInputEvents*()\n"
        /* 0285 */ "fn WaitTime*(seconds: real)\n"
        /* 0286 */ "fn ShowCursor*()\n"
        /* 0287 */ "fn HideCursor*()\n"
        /* 0288 */ "fn IsCursorHidden*(): bool\n"
        /* 0289 */ "fn EnableCursor*()\n"
        /* 0290 */ "fn DisableCursor*()\n"
        /* 0291 */ "fn IsCursorOnScreen*(): bool\n"
        /* 0292 */ "fn ClearBackground*(color: Color)\n"
        /* 0293 */ "fn BeginDrawing*()\n"
        /* 0294 */ "fn EndDrawing*()\n"
        /* 0295 */ "fn BeginMode2D*(camera: Camera2D)\n"
        /* 0296 */ "fn EndMode2D*()\n"
        /* 0297 */ "fn BeginMode3D*(camera: Camera3D)\n"
        /* 0298 */ "fn EndMode3D*()\n"
        /* 0299 */ "fn BeginTextureMode*(target: RenderTexture)\n"
        /* 0300 */ "fn EndTextureMode*()\n"
        /* 0301 */ "fn BeginShaderMode*(shader: Shader)\n"
        /* 0302 */ "fn EndShaderMode*()\n"
        /* 0303 */ "fn BeginBlendMode*(mode: int32)\n"
        /* 0304 */ "fn EndBlendMode*()\n"
        /* 0305 */ "fn BeginScissorMode*(x: int32, y: int32, width: int32, height: int32)\n"
        /* 0306 */ "fn EndScissorMode*()\n"
        /* 0307 */ "fn BeginVrStereoMode*(config: VrStereoConfig)\n"
        /* 0308 */ "fn EndVrStereoMode*()\n"
        /* 0309 */ "fn LoadVrStereoConfig*(device: VrDeviceInfo): VrStereoConfig\n"
        /* 0310 */ "fn UnloadVrStereoConfig*(config: VrStereoConfig)\n"
        /* 0311 */ "fn LoadShader*(vsFileName: str, fsFileName: str): Shader\n"
        /* 0312 */ "fn LoadShaderFromMemory*(vsCode: str, fsCode: str): Shader\n"
        /* 0313 */ "fn GetShaderLocation*(shader: Shader, uniformName: str): int32\n"
        /* 0314 */ "fn GetShaderLocationAttrib*(shader: Shader, attribName: str): int32\n"
        /* 0315 */ "fn SetShaderValue*(shader: Shader, locIndex: int32, value: ^void, uniformType: int32)\n"
        /* 0316 */ "fn SetShaderValueV*(shader: Shader, locIndex: int32, value: ^void, uniformType: int32, count: int32)\n"
        /* 0317 */ "fn SetShaderValueMatrix*(shader: Shader, locIndex: int32, mat: Matrix)\n"
        /* 0318 */ "fn SetShaderValueTexture*(shader: Shader, locIndex: int32, texture: Texture)\n"
        /* 0319 */ "fn UnloadShader*(shader: Shader)\n"
        /* 0320 */ "fn GetMouseRay*(mousePosition: Vector2, camera: Camera3D): Ray\n"
        /* 0321 */ "fn GetCameraMatrix*(camera: Camera3D): Matrix\n"
        /* 0322 */ "fn GetCameraMatrix2D*(camera: Camera2D): Matrix\n"
        /* 0323 */ "fn GetWorldToScreen*(position: Vector3, camera: Camera3D): Vector2\n"
        /* 0324 */ "fn GetScreenToWorld2D*(position: Vector2, camera: Camera2D): Vector2\n"
        /* 0325 */ "fn GetWorldToScreenEx*(position: Vector3, camera: Camera3D, width: int32, height: int32): Vector2\n"
        /* 0326 */ "fn GetWorldToScreen2D*(position: Vector2, camera: Camera2D): Vector2\n"
        /* 0327 */ "fn SetTargetFPS*(fps: int32)\n"
        /* 0328 */ "fn GetFPS*(): int32\n"
        /* 0329 */ "fn GetFrameTime*(): real32\n"
        /* 0330 */ "fn GetTime*(): real\n"
        /* 0331 */ "fn GetRandomValue*(min: int32, max: int32): int32\n"
        /* 0332 */ "fn SetRandomSeed*(seed: uint32)\n"
        /* 0333 */ "fn TakeScreenshot*(fileName: str)\n"
        /* 0334 */ "fn SetConfigFlags*(flags: uint32)\n"
        // Skipping TraceLog
        /* 0335 */ "fn SetTraceLogLevel*(logLevel: int32)\n"
        /* 0336 */ "fn MemAlloc*(size: int32): ^void\n"
        /* 0337 */ "fn MemRealloc*(ptr: ^void, size: int32): ^void\n"
        /* 0338 */ "fn MemFree*(ptr: ^void)\n"
        /* 0339 */ "fn OpenURL*(url: str)\n"
        // Skipping SetTraceLogCallback
        // Skipping SetLoadFileDataCallback
        // Skipping SetSaveFileDataCallback
        // Skipping SetLoadFileTextCallback
        // Skipping SetSaveFileTextCallback
        /* 0340 */ "fn LoadFileData*(fileName: str, bytesRead: ^uint32): ^uint8\n"
        /* 0341 */ "fn UnloadFileData*(data: ^uint8)\n"
        /* 0342 */ "fn SaveFileData*(fileName: str, data: ^void, bytesToWrite: uint32): bool\n"
        /* 0343 */ "fn ExportDataAsCode*(data: str, size: uint32, fileName: str): bool\n"
        /* 0344 */ "fn LoadFileText*(fileName: str): str\n"
        /* 0345 */ "fn UnloadFileText*(text: str)\n"
        /* 0346 */ "fn SaveFileText*(fileName: str, text: str): bool\n"
        /* 0347 */ "fn FileExists*(fileName: str): bool\n"
        /* 0348 */ "fn DirectoryExists*(dirPath: str): bool\n"
        /* 0349 */ "fn IsFileExtension*(fileName: str, ext: str): bool\n"
        /* 0350 */ "fn GetFileLength*(fileName: str): int32\n"
        /* 0351 */ "fn GetFileExtension*(fileName: str): str\n"
        /* 0352 */ "fn GetFileName*(filePath: str): str\n"
        /* 0353 */ "fn GetFileNameWithoutExt*(filePath: str): str\n"
        /* 0354 */ "fn GetDirectoryPath*(filePath: str): str\n"
        /* 0355 */ "fn GetPrevDirectoryPath*(dirPath: str): str\n"
        /* 0356 */ "fn GetWorkingDirectory*(): str\n"
        /* 0357 */ "fn GetApplicationDirectory*(): str\n"
        /* 0358 */ "fn ChangeDirectory*(dir: str): bool\n"
        /* 0359 */ "fn IsPathFile*(path: str): bool\n"
        /* 0360 */ "fn LoadDirectoryFiles*(dirPath: str): FilePathList\n"
        /* 0361 */ "fn LoadDirectoryFilesEx*(basePath: str, filter: str, scanSubdirs: bool): FilePathList\n"
        /* 0362 */ "fn UnloadDirectoryFiles*(files: FilePathList)\n"
        /* 0363 */ "fn IsFileDropped*(): bool\n"
        /* 0364 */ "fn LoadDroppedFiles*(): FilePathList\n"
        /* 0365 */ "fn UnloadDroppedFiles*(files: FilePathList)\n"
        /* 0366 */ "fn GetFileModTime*(fileName: str): int\n"
        /* 0367 */ "fn CompressData*(data: ^uint8, dataSize: int32, compDataSize: ^int32): ^uint8\n"
        /* 0368 */ "fn DecompressData*(compData: ^uint8, compDataSize: int32, dataSize: ^int32): ^uint8\n"
        /* 0369 */ "fn EncodeDataBase64*(data: ^uint8, dataSize: int32, outputSize: ^int32): str\n"
        /* 0370 */ "fn DecodeDataBase64*(data: ^uint8, outputSize: ^int32): ^uint8\n"
        /* 0371 */ "fn IsKeyPressed*(key: int32): bool\n"
        /* 0372 */ "fn IsKeyDown*(key: int32): bool\n"
        /* 0373 */ "fn IsKeyReleased*(key: int32): bool\n"
        /* 0374 */ "fn IsKeyUp*(key: int32): bool\n"
        /* 0375 */ "fn SetExitKey*(key: int32)\n"
        /* 0376 */ "fn GetKeyPressed*(): int32\n"
        /* 0377 */ "fn GetCharPressed*(): int32\n"
        /* 0378 */ "fn IsGamepadAvailable*(gamepad: int32): bool\n"
        /* 0379 */ "fn GetGamepadName*(gamepad: int32): str\n"
        /* 0380 */ "fn IsGamepadButtonPressed*(gamepad: int32, button: int32): bool\n"
        /* 0381 */ "fn IsGamepadButtonDown*(gamepad: int32, button: int32): bool\n"
        /* 0382 */ "fn IsGamepadButtonReleased*(gamepad: int32, button: int32): bool\n"
        /* 0383 */ "fn IsGamepadButtonUp*(gamepad: int32, button: int32): bool\n"
        /* 0384 */ "fn GetGamepadButtonPressed*(): int32\n"
        /* 0385 */ "fn GetGamepadAxisCount*(gamepad: int32): int32\n"
        /* 0386 */ "fn GetGamepadAxisMovement*(gamepad: int32, axis: int32): real32\n"
        /* 0387 */ "fn SetGamepadMappings*(mappings: str): int32\n"
        /* 0388 */ "fn IsMouseButtonPressed*(button: int32): bool\n"
        /* 0389 */ "fn IsMouseButtonDown*(button: int32): bool\n"
        /* 0390 */ "fn IsMouseButtonReleased*(button: int32): bool\n"
        /* 0391 */ "fn IsMouseButtonUp*(button: int32): bool\n"
        /* 0392 */ "fn GetMouseX*(): int32\n"
        /* 0393 */ "fn GetMouseY*(): int32\n"
        /* 0394 */ "fn GetMousePosition*(): Vector2\n"
        /* 0395 */ "fn GetMouseDelta*(): Vector2\n"
        /* 0396 */ "fn SetMousePosition*(x: int32, y: int32)\n"
        /* 0397 */ "fn SetMouseOffset*(offsetX: int32, offsetY: int32)\n"
        /* 0398 */ "fn SetMouseScale*(scaleX: real32, scaleY: real32)\n"
        /* 0399 */ "fn GetMouseWheelMove*(): real32\n"
        /* 0400 */ "fn GetMouseWheelMoveV*(): Vector2\n"
        /* 0401 */ "fn SetMouseCursor*(cursor: int32)\n"
        /* 0402 */ "fn GetTouchX*(): int32\n"
        /* 0403 */ "fn GetTouchY*(): int32\n"
        /* 0404 */ "fn GetTouchPosition*(index: int32): Vector2\n"
        /* 0405 */ "fn GetTouchPointId*(index: int32): int32\n"
        /* 0406 */ "fn GetTouchPointCount*(): int32\n"
        /* 0407 */ "fn SetGesturesEnabled*(flags: uint32)\n"
        /* 0408 */ "fn IsGestureDetected*(gesture: int32): bool\n"
        /* 0409 */ "fn GetGestureDetected*(): int32\n"
        /* 0410 */ "fn GetGestureHoldDuration*(): real32\n"
        /* 0411 */ "fn GetGestureDragVector*(): Vector2\n"
        /* 0412 */ "fn GetGestureDragAngle*(): real32\n"
        /* 0413 */ "fn GetGesturePinchVector*(): Vector2\n"
        /* 0414 */ "fn GetGesturePinchAngle*(): real32\n"
        /* 0415 */ "fn SetCameraMode*(camera: Camera3D, mode: int32)\n"
        /* 0416 */ "fn UpdateCamera*(camera: ^Camera3D)\n"
        /* 0417 */ "fn SetCameraPanControl*(keyPan: int32)\n"
        /* 0418 */ "fn SetCameraAltControl*(keyAlt: int32)\n"
        /* 0419 */ "fn SetCameraSmoothZoomControl*(keySmoothZoom: int32)\n"
        /* 0420 */ "fn SetCameraMoveControls*(keyFront: int32, keyBack: int32, keyRight: int32, keyLeft: int32, keyUp: int32, keyDown: int32)\n"
        /* 0421 */ "fn SetShapesTexture*(texture: Texture, source: Rectangle)\n"
        /* 0422 */ "fn DrawPixel*(posX: int32, posY: int32, color: Color)\n"
        /* 0423 */ "fn DrawPixelV*(position: Vector2, color: Color)\n"
        /* 0424 */ "fn DrawLine*(startPosX: int32, startPosY: int32, endPosX: int32, endPosY: int32, color: Color)\n"
        /* 0425 */ "fn DrawLineV*(startPos: Vector2, endPos: Vector2, color: Color)\n"
        /* 0426 */ "fn DrawLineEx*(startPos: Vector2, endPos: Vector2, thick: real32, color: Color)\n"
        /* 0427 */ "fn DrawLineBezier*(startPos: Vector2, endPos: Vector2, thick: real32, color: Color)\n"
        /* 0428 */ "fn DrawLineBezierQuad*(startPos: Vector2, endPos: Vector2, controlPos: Vector2, thick: real32, color: Color)\n"
        /* 0429 */ "fn DrawLineBezierCubic*(startPos: Vector2, endPos: Vector2, startControlPos: Vector2, endControlPos: Vector2, thick: real32, color: Color)\n"
        /* 0430 */ "fn DrawLineStrip*(points: ^Vector2, pointCount: int32, color: Color)\n"
        /* 0431 */ "fn DrawCircle*(centerX: int32, centerY: int32, radius: real32, color: Color)\n"
        /* 0432 */ "fn DrawCircleSector*(center: Vector2, radius: real32, startAngle: real32, endAngle: real32, segments: int32, color: Color)\n"
        /* 0433 */ "fn DrawCircleSectorLines*(center: Vector2, radius: real32, startAngle: real32, endAngle: real32, segments: int32, color: Color)\n"
        /* 0434 */ "fn DrawCircleGradient*(centerX: int32, centerY: int32, radius: real32, color1: Color, color2: Color)\n"
        /* 0435 */ "fn DrawCircleV*(center: Vector2, radius: real32, color: Color)\n"
        /* 0436 */ "fn DrawCircleLines*(centerX: int32, centerY: int32, radius: real32, color: Color)\n"
        /* 0437 */ "fn DrawEllipse*(centerX: int32, centerY: int32, radiusH: real32, radiusV: real32, color: Color)\n"
        /* 0438 */ "fn DrawEllipseLines*(centerX: int32, centerY: int32, radiusH: real32, radiusV: real32, color: Color)\n"
        /* 0439 */ "fn DrawRing*(center: Vector2, innerRadius: real32, outerRadius: real32, startAngle: real32, endAngle: real32, segments: int32, color: Color)\n"
        /* 0440 */ "fn DrawRingLines*(center: Vector2, innerRadius: real32, outerRadius: real32, startAngle: real32, endAngle: real32, segments: int32, color: Color)\n"
        /* 0441 */ "fn DrawRectangle*(posX: int32, posY: int32, width: int32, height: int32, color: Color)\n"
        /* 0442 */ "fn DrawRectangleV*(position: Vector2, size: Vector2, color: Color)\n"
        /* 0443 */ "fn DrawRectangleRec*(rec: Rectangle, color: Color)\n"
        /* 0444 */ "fn DrawRectanglePro*(rec: Rectangle, origin: Vector2, rotation: real32, color: Color)\n"
        /* 0445 */ "fn DrawRectangleGradientV*(posX: int32, posY: int32, width: int32, height: int32, color1: Color, color2: Color)\n"
        /* 0446 */ "fn DrawRectangleGradientH*(posX: int32, posY: int32, width: int32, height: int32, color1: Color, color2: Color)\n"
        /* 0447 */ "fn DrawRectangleGradientEx*(rec: Rectangle, col1: Color, col2: Color, col3: Color, col4: Color)\n"
        /* 0448 */ "fn DrawRectangleLines*(posX: int32, posY: int32, width: int32, height: int32, color: Color)\n"
        /* 0449 */ "fn DrawRectangleLinesEx*(rec: Rectangle, lineThick: real32, color: Color)\n"
        /* 0450 */ "fn DrawRectangleRounded*(rec: Rectangle, roundness: real32, segments: int32, color: Color)\n"
        /* 0451 */ "fn DrawRectangleRoundedLines*(rec: Rectangle, roundness: real32, segments: int32, lineThick: real32, color: Color)\n"
        /* 0452 */ "fn DrawTriangle*(v1: Vector2, v2: Vector2, v3: Vector2, color: Color)\n"
        /* 0453 */ "fn DrawTriangleLines*(v1: Vector2, v2: Vector2, v3: Vector2, color: Color)\n"
        /* 0454 */ "fn DrawTriangleFan*(points: ^Vector2, pointCount: int32, color: Color)\n"
        /* 0455 */ "fn DrawTriangleStrip*(points: ^Vector2, pointCount: int32, color: Color)\n"
        /* 0456 */ "fn DrawPoly*(center: Vector2, sides: int32, radius: real32, rotation: real32, color: Color)\n"
        /* 0457 */ "fn DrawPolyLines*(center: Vector2, sides: int32, radius: real32, rotation: real32, color: Color)\n"
        /* 0458 */ "fn DrawPolyLinesEx*(center: Vector2, sides: int32, radius: real32, rotation: real32, lineThick: real32, color: Color)\n"
        /* 0459 */ "fn CheckCollisionRecs*(rec1: Rectangle, rec2: Rectangle): bool\n"
        /* 0460 */ "fn CheckCollisionCircles*(center1: Vector2, radius1: real32, center2: Vector2, radius2: real32): bool\n"
        /* 0461 */ "fn CheckCollisionCircleRec*(center: Vector2, radius: real32, rec: Rectangle): bool\n"
        /* 0462 */ "fn CheckCollisionPointRec*(point: Vector2, rec: Rectangle): bool\n"
        /* 0463 */ "fn CheckCollisionPointCircle*(point: Vector2, center: Vector2, radius: real32): bool\n"
        /* 0464 */ "fn CheckCollisionPointTriangle*(point: Vector2, p1: Vector2, p2: Vector2, p3: Vector2): bool\n"
        /* 0465 */ "fn CheckCollisionLines*(startPos1: Vector2, endPos1: Vector2, startPos2: Vector2, endPos2: Vector2, collisionPoint: ^Vector2): bool\n"
        /* 0466 */ "fn CheckCollisionPointLine*(point: Vector2, p1: Vector2, p2: Vector2, threshold: int32): bool\n"
        /* 0467 */ "fn GetCollisionRec*(rec1: Rectangle, rec2: Rectangle): Rectangle\n"
        /* 0468 */ "fn LoadImage*(fileName: str): Image\n"
        /* 0469 */ "fn LoadImageRaw*(fileName: str, width: int32, height: int32, format: int32, headerSize: int32): Image\n"
        /* 0470 */ "fn LoadImageAnim*(fileName: str, frames: ^int32): Image\n"
        /* 0471 */ "fn LoadImageFromMemory*(fileType: str, fileData: ^uint8, dataSize: int32): Image\n"
        /* 0472 */ "fn LoadImageFromTexture*(texture: Texture): Image\n"
        /* 0473 */ "fn LoadImageFromScreen*(): Image\n"
        /* 0474 */ "fn UnloadImage*(image: Image)\n"
        /* 0475 */ "fn ExportImage*(image: Image, fileName: str): bool\n"
        /* 0476 */ "fn ExportImageAsCode*(image: Image, fileName: str): bool\n"
        /* 0477 */ "fn GenImageColor*(width: int32, height: int32, color: Color): Image\n"
        /* 0478 */ "fn GenImageGradientV*(width: int32, height: int32, top: Color, bottom: Color): Image\n"
        /* 0479 */ "fn GenImageGradientH*(width: int32, height: int32, left: Color, right: Color): Image\n"
        /* 0480 */ "fn GenImageGradientRadial*(width: int32, height: int32, density: real32, inner: Color, outer: Color): Image\n"
        /* 0481 */ "fn GenImageChecked*(width: int32, height: int32, checksX: int32, checksY: int32, col1: Color, col2: Color): Image\n"
        /* 0482 */ "fn GenImageWhiteNoise*(width: int32, height: int32, factor: real32): Image\n"
        /* 0483 */ "fn GenImageCellular*(width: int32, height: int32, tileSize: int32): Image\n"
        /* 0484 */ "fn ImageCopy*(image: Image): Image\n"
        /* 0485 */ "fn ImageFromImage*(image: Image, rec: Rectangle): Image\n"
        /* 0486 */ "fn ImageText*(text: str, fontSize: int32, color: Color): Image\n"
        /* 0487 */ "fn ImageTextEx*(font: Font, text: str, fontSize: real32, spacing: real32, tint: Color): Image\n"
        /* 0488 */ "fn ImageFormat*(image: ^Image, newFormat: int32)\n"
        /* 0489 */ "fn ImageToPOT*(image: ^Image, fill: Color)\n"
        /* 0490 */ "fn ImageCrop*(image: ^Image, crop: Rectangle)\n"
        /* 0491 */ "fn ImageAlphaCrop*(image: ^Image, threshold: real32)\n"
        /* 0492 */ "fn ImageAlphaClear*(image: ^Image, color: Color, threshold: real32)\n"
        /* 0493 */ "fn ImageAlphaMask*(image: ^Image, alphaMask: Image)\n"
        /* 0494 */ "fn ImageAlphaPremultiply*(image: ^Image)\n"
        /* 0495 */ "fn ImageResize*(image: ^Image, newWidth: int32, newHeight: int32)\n"
        /* 0496 */ "fn ImageResizeNN*(image: ^Image, newWidth: int32, newHeight: int32)\n"
        /* 0497 */ "fn ImageResizeCanvas*(image: ^Image, newWidth: int32, newHeight: int32, offsetX: int32, offsetY: int32, fill: Color)\n"
        /* 0498 */ "fn ImageMipmaps*(image: ^Image)\n"
        /* 0499 */ "fn ImageDither*(image: ^Image, rBpp: int32, gBpp: int32, bBpp: int32, aBpp: int32)\n"
        /* 0500 */ "fn ImageFlipVertical*(image: ^Image)\n"
        /* 0501 */ "fn ImageFlipHorizontal*(image: ^Image)\n"
        /* 0502 */ "fn ImageRotateCW*(image: ^Image)\n"
        /* 0503 */ "fn ImageRotateCCW*(image: ^Image)\n"
        /* 0504 */ "fn ImageColorTint*(image: ^Image, color: Color)\n"
        /* 0505 */ "fn ImageColorInvert*(image: ^Image)\n"
        /* 0506 */ "fn ImageColorGrayscale*(image: ^Image)\n"
        /* 0507 */ "fn ImageColorContrast*(image: ^Image, contrast: real32)\n"
        /* 0508 */ "fn ImageColorBrightness*(image: ^Image, brightness: int32)\n"
        /* 0509 */ "fn ImageColorReplace*(image: ^Image, color: Color, replace: Color)\n"
        /* 0510 */ "fn LoadImageColors*(image: Image): ^Color\n"
        /* 0511 */ "fn LoadImagePalette*(image: Image, maxPaletteSize: int32, colorCount: ^int32): ^Color\n"
        /* 0512 */ "fn UnloadImageColors*(colors: ^Color)\n"
        /* 0513 */ "fn UnloadImagePalette*(colors: ^Color)\n"
        /* 0514 */ "fn GetImageAlphaBorder*(image: Image, threshold: real32): Rectangle\n"
        /* 0515 */ "fn GetImageColor*(image: Image, x: int32, y: int32): Color\n"
        /* 0516 */ "fn ImageClearBackground*(dst: ^Image, color: Color)\n"
        /* 0517 */ "fn ImageDrawPixel*(dst: ^Image, posX: int32, posY: int32, color: Color)\n"
        /* 0518 */ "fn ImageDrawPixelV*(dst: ^Image, position: Vector2, color: Color)\n"
        /* 0519 */ "fn ImageDrawLine*(dst: ^Image, startPosX: int32, startPosY: int32, endPosX: int32, endPosY: int32, color: Color)\n"
        /* 0520 */ "fn ImageDrawLineV*(dst: ^Image, start: Vector2, end: Vector2, color: Color)\n"
        /* 0521 */ "fn ImageDrawCircle*(dst: ^Image, centerX: int32, centerY: int32, radius: int32, color: Color)\n"
        /* 0522 */ "fn ImageDrawCircleV*(dst: ^Image, center: Vector2, radius: int32, color: Color)\n"
        /* 0523 */ "fn ImageDrawRectangle*(dst: ^Image, posX: int32, posY: int32, width: int32, height: int32, color: Color)\n"
        /* 0524 */ "fn ImageDrawRectangleV*(dst: ^Image, position: Vector2, size: Vector2, color: Color)\n"
        /* 0525 */ "fn ImageDrawRectangleRec*(dst: ^Image, rec: Rectangle, color: Color)\n"
        /* 0526 */ "fn ImageDrawRectangleLines*(dst: ^Image, rec: Rectangle, thick: int32, color: Color)\n"
        /* 0527 */ "fn ImageDraw*(dst: ^Image, src: Image, srcRec: Rectangle, dstRec: Rectangle, tint: Color)\n"
        /* 0528 */ "fn ImageDrawText*(dst: ^Image, text: str, posX: int32, posY: int32, fontSize: int32, color: Color)\n"
        /* 0529 */ "fn ImageDrawTextEx*(dst: ^Image, font: Font, text: str, position: Vector2, fontSize: real32, spacing: real32, tint: Color)\n"
        /* 0530 */ "fn LoadTexture*(fileName: str): Texture\n"
        /* 0531 */ "fn LoadTextureFromImage*(image: Image): Texture\n"
        /* 0532 */ "fn LoadTextureCubemap*(image: Image, layout: int32): Texture\n"
        /* 0533 */ "fn LoadRenderTexture*(width: int32, height: int32): RenderTexture\n"
        /* 0534 */ "fn UnloadTexture*(texture: Texture)\n"
        /* 0535 */ "fn UnloadRenderTexture*(target: RenderTexture)\n"
        /* 0536 */ "fn UpdateTexture*(texture: Texture, pixels: ^void)\n"
        /* 0537 */ "fn UpdateTextureRec*(texture: Texture, rec: Rectangle, pixels: ^void)\n"
        /* 0538 */ "fn GenTextureMipmaps*(texture: ^Texture)\n"
        /* 0539 */ "fn SetTextureFilter*(texture: Texture, filter: int32)\n"
        /* 0540 */ "fn SetTextureWrap*(texture: Texture, wrap: int32)\n"
        /* 0541 */ "fn DrawTexture*(texture: Texture, posX: int32, posY: int32, tint: Color)\n"
        /* 0542 */ "fn DrawTextureV*(texture: Texture, position: Vector2, tint: Color)\n"
        /* 0543 */ "fn DrawTextureEx*(texture: Texture, position: Vector2, rotation: real32, scale: real32, tint: Color)\n"
        /* 0544 */ "fn DrawTextureRec*(texture: Texture, source: Rectangle, position: Vector2, tint: Color)\n"
        /* 0545 */ "fn DrawTextureQuad*(texture: Texture, tiling: Vector2, offset: Vector2, quad: Rectangle, tint: Color)\n"
        /* 0546 */ "fn DrawTextureTiled*(texture: Texture, source: Rectangle, dest: Rectangle, origin: Vector2, rotation: real32, scale: real32, tint: Color)\n"
        /* 0547 */ "fn DrawTexturePro*(texture: Texture, source: Rectangle, dest: Rectangle, origin: Vector2, rotation: real32, tint: Color)\n"
        /* 0548 */ "fn DrawTextureNPatch*(texture: Texture, nPatchInfo: NPatchInfo, dest: Rectangle, origin: Vector2, rotation: real32, tint: Color)\n"
        /* 0549 */ "fn DrawTexturePoly*(texture: Texture, center: Vector2, points: ^Vector2, texcoords: ^Vector2, pointCount: int32, tint: Color)\n"
        /* 0550 */ "fn Fade*(color: Color, alpha: real32): Color\n"
        /* 0551 */ "fn ColorToInt*(color: Color): int32\n"
        /* 0552 */ "fn ColorNormalize*(color: Color): Vector4\n"
        /* 0553 */ "fn ColorFromNormalized*(normalized: Vector4): Color\n"
        /* 0554 */ "fn ColorToHSV*(color: Color): Vector3\n"
        /* 0555 */ "fn ColorFromHSV*(hue: real32, saturation: real32, value: real32): Color\n"
        /* 0556 */ "fn ColorAlpha*(color: Color, alpha: real32): Color\n"
        /* 0557 */ "fn ColorAlphaBlend*(dst: Color, src: Color, tint: Color): Color\n"
        /* 0558 */ "fn GetColor*(hexValue: uint32): Color\n"
        /* 0559 */ "fn GetPixelColor*(srcPtr: ^void, format: int32): Color\n"
        /* 0560 */ "fn SetPixelColor*(dstPtr: ^void, color: Color, format: int32)\n"
        /* 0561 */ "fn GetPixelDataSize*(width: int32, height: int32, format: int32): int32\n"
        /* 0562 */ "fn GetFontDefault*(): Font\n"
        /* 0563 */ "fn LoadFont*(fileName: str): Font\n"
        /* 0564 */ "fn LoadFontEx*(fileName: str, fontSize: int32, fontChars: ^int32, glyphCount: int32): Font\n"
        /* 0565 */ "fn LoadFontFromImage*(image: Image, key: Color, firstChar: int32): Font\n"
        /* 0566 */ "fn LoadFontFromMemory*(fileType: str, fileData: ^uint8, dataSize: int32, fontSize: int32, fontChars: ^int32, glyphCount: int32): Font\n"
        // Skipping LoadFontData
        /* 0567 */ "fn GenImageFontAtlas*(chars: ^void, recs: ^void, glyphCount: int32, fontSize: int32, padding: int32, packMethod: int32): Image\n"
        /* 0568 */ "fn UnloadFontData*(chars: ^GlyphInfo, glyphCount: int32)\n"
        /* 0569 */ "fn UnloadFont*(font: Font)\n"
        /* 0570 */ "fn ExportFontAsCode*(font: Font, fileName: str): bool\n"
        /* 0571 */ "fn DrawFPS*(posX: int32, posY: int32)\n"
        /* 0572 */ "fn DrawText*(text: str, posX: int32, posY: int32, fontSize: int32, color: Color)\n"
        /* 0573 */ "fn DrawTextEx*(font: Font, text: str, position: Vector2, fontSize: real32, spacing: real32, tint: Color)\n"
        /* 0574 */ "fn DrawTextPro*(font: Font, text: str, position: Vector2, origin: Vector2, rotation: real32, fontSize: real32, spacing: real32, tint: Color)\n"
        /* 0575 */ "fn DrawTextCodepoint*(font: Font, codepoint: int32, position: Vector2, fontSize: real32, tint: Color)\n"
        /* 0576 */ "fn DrawTextCodepoints*(font: Font, codepoints: ^int32, count: int32, position: Vector2, fontSize: real32, spacing: real32, tint: Color)\n"
        /* 0577 */ "fn MeasureText*(text: str, fontSize: int32): int32\n"
        /* 0578 */ "fn MeasureTextEx*(font: Font, text: str, fontSize: real32, spacing: real32): Vector2\n"
        /* 0579 */ "fn GetGlyphIndex*(font: Font, codepoint: int32): int32\n"
        /* 0580 */ "fn GetGlyphInfo*(font: Font, codepoint: int32): GlyphInfo\n"
        /* 0581 */ "fn GetGlyphAtlasRec*(font: Font, codepoint: int32): Rectangle\n"
        /* 0582 */ "fn LoadCodepoints*(text: str, count: ^int32): ^int32\n"
        /* 0583 */ "fn UnloadCodepoints*(codepoints: ^int32)\n"
        /* 0584 */ "fn GetCodepointCount*(text: str): int32\n"
        /* 0585 */ "fn GetCodepoint*(text: str, bytesProcessed: ^int32): int32\n"
        /* 0586 */ "fn CodepointToUTF8*(codepoint: int32, byteSize: ^int32): str\n"
        /* 0587 */ "fn TextCodepointsToUTF8*(codepoints: ^int32, length: int32): str\n"
        /* 0588 */ "fn TextCopy*(dst: str, src: str): int32\n"
        /* 0589 */ "fn TextIsEqual*(text1: str, text2: str): bool\n"
        /* 0590 */ "fn TextLength*(text: str): uint32\n"
        // Skipping TextFormat
        /* 0591 */ "fn TextSubtext*(text: str, position: int32, length: int32): str\n"
        /* 0592 */ "fn TextReplace*(text: str, replace: str, by: str): str\n"
        /* 0593 */ "fn TextInsert*(text: str, insert: str, position: int32): str\n"
        /* 0594 */ "fn TextJoin*(textList: ^str, count: int32, delimiter: str): str\n"
        /* 0595 */ "fn TextSplit*(text: str, delimiter: char, count: ^int32): ^str\n"
        /* 0596 */ "fn TextAppend*(text: str, append: str, position: ^int32)\n"
        /* 0597 */ "fn TextFindIndex*(text: str, find: str): int32\n"
        /* 0598 */ "fn TextToUpper*(text: str): str\n"
        /* 0599 */ "fn TextToLower*(text: str): str\n"
        /* 0600 */ "fn TextToPascal*(text: str): str\n"
        /* 0601 */ "fn TextToInteger*(text: str): int32\n"
        /* 0602 */ "fn DrawLine3D*(startPos: Vector3, endPos: Vector3, color: Color)\n"
        /* 0603 */ "fn DrawPoint3D*(position: Vector3, color: Color)\n"
        /* 0604 */ "fn DrawCircle3D*(center: Vector3, radius: real32, rotationAxis: Vector3, rotationAngle: real32, color: Color)\n"
        /* 0605 */ "fn DrawTriangle3D*(v1: Vector3, v2: Vector3, v3: Vector3, color: Color)\n"
        /* 0606 */ "fn DrawTriangleStrip3D*(points: ^Vector3, pointCount: int32, color: Color)\n"
        /* 0607 */ "fn DrawCube*(position: Vector3, width: real32, height: real32, length: real32, color: Color)\n"
        /* 0608 */ "fn DrawCubeV*(position: Vector3, size: Vector3, color: Color)\n"
        /* 0609 */ "fn DrawCubeWires*(position: Vector3, width: real32, height: real32, length: real32, color: Color)\n"
        /* 0610 */ "fn DrawCubeWiresV*(position: Vector3, size: Vector3, color: Color)\n"
        /* 0611 */ "fn DrawCubeTexture*(texture: Texture, position: Vector3, width: real32, height: real32, length: real32, color: Color)\n"
        /* 0612 */ "fn DrawCubeTextureRec*(texture: Texture, source: Rectangle, position: Vector3, width: real32, height: real32, length: real32, color: Color)\n"
        /* 0613 */ "fn DrawSphere*(centerPos: Vector3, radius: real32, color: Color)\n"
        /* 0614 */ "fn DrawSphereEx*(centerPos: Vector3, radius: real32, rings: int32, slices: int32, color: Color)\n"
        /* 0615 */ "fn DrawSphereWires*(centerPos: Vector3, radius: real32, rings: int32, slices: int32, color: Color)\n"
        /* 0616 */ "fn DrawCylinder*(position: Vector3, radiusTop: real32, radiusBottom: real32, height: real32, slices: int32, color: Color)\n"
        /* 0617 */ "fn DrawCylinderEx*(startPos: Vector3, endPos: Vector3, startRadius: real32, endRadius: real32, sides: int32, color: Color)\n"
        /* 0618 */ "fn DrawCylinderWires*(position: Vector3, radiusTop: real32, radiusBottom: real32, height: real32, slices: int32, color: Color)\n"
        /* 0619 */ "fn DrawCylinderWiresEx*(startPos: Vector3, endPos: Vector3, startRadius: real32, endRadius: real32, sides: int32, color: Color)\n"
        /* 0620 */ "fn DrawPlane*(centerPos: Vector3, size: Vector2, color: Color)\n"
        /* 0621 */ "fn DrawRay*(ray: Ray, color: Color)\n"
        /* 0622 */ "fn DrawGrid*(slices: int32, spacing: real32)\n"
        /* 0623 */ "fn LoadModel*(fileName: str): Model\n"
        /* 0624 */ "fn LoadModelFromMesh*(mesh: Mesh): Model\n"
        /* 0625 */ "fn UnloadModel*(model: Model)\n"
        /* 0626 */ "fn UnloadModelKeepMeshes*(model: Model)\n"
        /* 0627 */ "fn GetModelBoundingBox*(model: Model): BoundingBox\n"
        /* 0628 */ "fn DrawModel*(model: Model, position: Vector3, scale: real32, tint: Color)\n"
        /* 0629 */ "fn DrawModelEx*(model: Model, position: Vector3, rotationAxis: Vector3, rotationAngle: real32, scale: Vector3, tint: Color)\n"
        /* 0630 */ "fn DrawModelWires*(model: Model, position: Vector3, scale: real32, tint: Color)\n"
        /* 0631 */ "fn DrawModelWiresEx*(model: Model, position: Vector3, rotationAxis: Vector3, rotationAngle: real32, scale: Vector3, tint: Color)\n"
        /* 0632 */ "fn DrawBoundingBox*(box: BoundingBox, color: Color)\n"
        /* 0633 */ "fn DrawBillboard*(camera: Camera3D, texture: Texture, position: Vector3, size: real32, tint: Color)\n"
        /* 0634 */ "fn DrawBillboardRec*(camera: Camera3D, texture: Texture, source: Rectangle, position: Vector3, size: Vector2, tint: Color)\n"
        /* 0635 */ "fn DrawBillboardPro*(camera: Camera3D, texture: Texture, source: Rectangle, position: Vector3, up: Vector3, size: Vector2, origin: Vector2, rotation: real32, tint: Color)\n"
        /* 0636 */ "fn UploadMesh*(mesh: ^Mesh, dynamic: bool)\n"
        /* 0637 */ "fn UpdateMeshBuffer*(mesh: Mesh, index: int32, data: ^void, dataSize: int32, offset: int32)\n"
        /* 0638 */ "fn UnloadMesh*(mesh: Mesh)\n"
        /* 0639 */ "fn DrawMesh*(mesh: Mesh, material: Material, transform: Matrix)\n"
        /* 0640 */ "fn DrawMeshInstanced*(mesh: Mesh, material: Material, transforms: ^Matrix, instances: int32)\n"
        /* 0641 */ "fn ExportMesh*(mesh: Mesh, fileName: str): bool\n"
        /* 0642 */ "fn GetMeshBoundingBox*(mesh: Mesh): BoundingBox\n"
        /* 0643 */ "fn GenMeshTangents*(mesh: ^Mesh)\n"
        /* 0644 */ "fn GenMeshPoly*(sides: int32, radius: real32): Mesh\n"
        /* 0645 */ "fn GenMeshPlane*(width: real32, length: real32, resX: int32, resZ: int32): Mesh\n"
        /* 0646 */ "fn GenMeshCube*(width: real32, height: real32, length: real32): Mesh\n"
        /* 0647 */ "fn GenMeshSphere*(radius: real32, rings: int32, slices: int32): Mesh\n"
        /* 0648 */ "fn GenMeshHemiSphere*(radius: real32, rings: int32, slices: int32): Mesh\n"
        /* 0649 */ "fn GenMeshCylinder*(radius: real32, height: real32, slices: int32): Mesh\n"
        /* 0650 */ "fn GenMeshCone*(radius: real32, height: real32, slices: int32): Mesh\n"
        /* 0651 */ "fn GenMeshTorus*(radius: real32, size: real32, radSeg: int32, sides: int32): Mesh\n"
        /* 0652 */ "fn GenMeshKnot*(radius: real32, size: real32, radSeg: int32, sides: int32): Mesh\n"
        /* 0653 */ "fn GenMeshHeightmap*(heightmap: Image, size: Vector3): Mesh\n"
        /* 0654 */ "fn GenMeshCubicmap*(cubicmap: Image, cubeSize: Vector3): Mesh\n"
        /* 0655 */ "fn LoadMaterials*(fileName: str, materialCount: ^int32): ^Material\n"
        /* 0656 */ "fn LoadMaterialDefault*(): Material\n"
        /* 0657 */ "fn UnloadMaterial*(material: Material)\n"
        /* 0658 */ "fn SetMaterialTexture*(material: ^Material, mapType: int32, texture: Texture)\n"
        /* 0659 */ "fn SetModelMeshMaterial*(model: ^Model, meshId: int32, materialId: int32)\n"
        /* 0660 */ "fn LoadModelAnimations*(fileName: str, animCount: ^uint32): ^ModelAnimation\n"
        /* 0661 */ "fn UpdateModelAnimation*(model: Model, anim: ModelAnimation, frame: int32)\n"
        /* 0662 */ "fn UnloadModelAnimation*(anim: ModelAnimation)\n"
        /* 0663 */ "fn UnloadModelAnimations*(animations: ^ModelAnimation, count: uint32)\n"
        /* 0664 */ "fn IsModelAnimationValid*(model: Model, anim: ModelAnimation): bool\n"
        /* 0665 */ "fn CheckCollisionSpheres*(center1: Vector3, radius1: real32, center2: Vector3, radius2: real32): bool\n"
        /* 0666 */ "fn CheckCollisionBoxes*(box1: BoundingBox, box2: BoundingBox): bool\n"
        /* 0667 */ "fn CheckCollisionBoxSphere*(box: BoundingBox, center: Vector3, radius: real32): bool\n"
        /* 0668 */ "fn GetRayCollisionSphere*(ray: Ray, center: Vector3, radius: real32): RayCollision\n"
        /* 0669 */ "fn GetRayCollisionBox*(ray: Ray, box: BoundingBox): RayCollision\n"
        /* 0670 */ "fn GetRayCollisionMesh*(ray: Ray, mesh: Mesh, transform: Matrix): RayCollision\n"
        /* 0671 */ "fn GetRayCollisionTriangle*(ray: Ray, p1: Vector3, p2: Vector3, p3: Vector3): RayCollision\n"
        /* 0672 */ "fn GetRayCollisionQuad*(ray: Ray, p1: Vector3, p2: Vector3, p3: Vector3, p4: Vector3): RayCollision\n"
        /* 0673 */ "fn InitAudioDevice*()\n"
        /* 0674 */ "fn CloseAudioDevice*()\n"
        /* 0675 */ "fn IsAudioDeviceReady*(): bool\n"
        /* 0676 */ "fn SetMasterVolume*(volume: real32)\n"
        /* 0677 */ "fn LoadWave*(fileName: str): Wave\n"
        /* 0678 */ "fn LoadWaveFromMemory*(fileType: str, fileData: ^uint8, dataSize: int32): Wave\n"
        /* 0679 */ "fn LoadSound*(fileName: str): Sound\n"
        /* 0680 */ "fn LoadSoundFromWave*(wave: Wave): Sound\n"
        /* 0681 */ "fn UpdateSound*(sound: Sound, data: ^void, sampleCount: int32)\n"
        /* 0682 */ "fn UnloadWave*(wave: Wave)\n"
        /* 0683 */ "fn UnloadSound*(sound: Sound)\n"
        /* 0684 */ "fn ExportWave*(wave: Wave, fileName: str): bool\n"
        /* 0685 */ "fn ExportWaveAsCode*(wave: Wave, fileName: str): bool\n"
        /* 0686 */ "fn PlaySound*(sound: Sound)\n"
        /* 0687 */ "fn StopSound*(sound: Sound)\n"
        /* 0688 */ "fn PauseSound*(sound: Sound)\n"
        /* 0689 */ "fn ResumeSound*(sound: Sound)\n"
        /* 0690 */ "fn PlaySoundMulti*(sound: Sound)\n"
        /* 0691 */ "fn StopSoundMulti*()\n"
        /* 0692 */ "fn GetSoundsPlaying*(): int32\n"
        /* 0693 */ "fn IsSoundPlaying*(sound: Sound): bool\n"
        /* 0694 */ "fn SetSoundVolume*(sound: Sound, volume: real32)\n"
        /* 0695 */ "fn SetSoundPitch*(sound: Sound, pitch: real32)\n"
        /* 0696 */ "fn SetSoundPan*(sound: Sound, pan: real32)\n"
        /* 0697 */ "fn WaveCopy*(wave: Wave): Wave\n"
        /* 0698 */ "fn WaveCrop*(wave: ^Wave, initSample: int32, finalSample: int32)\n"
        /* 0699 */ "fn WaveFormat*(wave: ^Wave, sampleRate: int32, sampleSize: int32, channels: int32)\n"
        /* 0700 */ "fn LoadWaveSamples*(wave: Wave): ^real32\n"
        /* 0701 */ "fn UnloadWaveSamples*(samples: ^real32)\n"
        /* 0702 */ "fn LoadMusicStream*(fileName: str): Music\n"
        /* 0703 */ "fn LoadMusicStreamFromMemory*(fileType: str, data: ^uint8, dataSize: int32): Music\n"
        /* 0704 */ "fn UnloadMusicStream*(music: Music)\n"
        /* 0705 */ "fn PlayMusicStream*(music: Music)\n"
        /* 0706 */ "fn IsMusicStreamPlaying*(music: Music): bool\n"
        /* 0707 */ "fn UpdateMusicStream*(music: Music)\n"
        /* 0708 */ "fn StopMusicStream*(music: Music)\n"
        /* 0709 */ "fn PauseMusicStream*(music: Music)\n"
        /* 0710 */ "fn ResumeMusicStream*(music: Music)\n"
        /* 0711 */ "fn SeekMusicStream*(music: Music, position: real32)\n"
        /* 0712 */ "fn SetMusicVolume*(music: Music, volume: real32)\n"
        /* 0713 */ "fn SetMusicPitch*(music: Music, pitch: real32)\n"
        /* 0714 */ "fn SetMusicPan*(music: Music, pan: real32)\n"
        /* 0715 */ "fn GetMusicTimeLength*(music: Music): real32\n"
        /* 0716 */ "fn GetMusicTimePlayed*(music: Music): real32\n"
        /* 0717 */ "fn LoadAudioStream*(sampleRate: uint32, sampleSize: uint32, channels: uint32): AudioStream\n"
        /* 0718 */ "fn UnloadAudioStream*(stream: AudioStream)\n"
        /* 0719 */ "fn UpdateAudioStream*(stream: AudioStream, data: ^void, frameCount: int32)\n"
        /* 0720 */ "fn IsAudioStreamProcessed*(stream: AudioStream): bool\n"
        /* 0721 */ "fn PlayAudioStream*(stream: AudioStream)\n"
        /* 0722 */ "fn PauseAudioStream*(stream: AudioStream)\n"
        /* 0723 */ "fn ResumeAudioStream*(stream: AudioStream)\n"
        /* 0724 */ "fn IsAudioStreamPlaying*(stream: AudioStream): bool\n"
        /* 0725 */ "fn StopAudioStream*(stream: AudioStream)\n"
        /* 0726 */ "fn SetAudioStreamVolume*(stream: AudioStream, volume: real32)\n"
        /* 0727 */ "fn SetAudioStreamPitch*(stream: AudioStream, pitch: real32)\n"
        /* 0728 */ "fn SetAudioStreamPan*(stream: AudioStream, pan: real32)\n"
        /* 0729 */ "fn SetAudioStreamBufferSizeDefault*(size: int32)\n"
        // Skipping SetAudioStreamCallback
        // Skipping AttachAudioStreamProcessor
        // Skipping DetachAudioStreamProcessor
        /* 0730 */ "fn Clamp*(value: real32, min: real32, max: real32): real32\n"
        /* 0731 */ "fn Lerp*(start: real32, end: real32, amount: real32): real32\n"
        /* 0732 */ "fn Normalize*(value: real32, start: real32, end: real32): real32\n"
        /* 0733 */ "fn Remap*(value: real32, inputStart: real32, inputEnd: real32, outputStart: real32, outputEnd: real32): real32\n"
        /* 0734 */ "fn Wrap*(value: real32, min: real32, max: real32): real32\n"
        /* 0735 */ "fn FloatEquals*(x: real32, y: real32): int32\n"
        /* 0736 */ "fn Vector2Zero*(): Vector2\n"
        /* 0737 */ "fn Vector2One*(): Vector2\n"
        /* 0738 */ "fn Vector2Add*(v1: Vector2, v2: Vector2): Vector2\n"
        /* 0739 */ "fn Vector2AddValue*(v: Vector2, add: real32): Vector2\n"
        /* 0740 */ "fn Vector2Subtract*(v1: Vector2, v2: Vector2): Vector2\n"
        /* 0741 */ "fn Vector2SubtractValue*(v: Vector2, sub: real32): Vector2\n"
        /* 0742 */ "fn Vector2Length*(v: Vector2): real32\n"
        /* 0743 */ "fn Vector2LengthSqr*(v: Vector2): real32\n"
        /* 0744 */ "fn Vector2DotProduct*(v1: Vector2, v2: Vector2): real32\n"
        /* 0745 */ "fn Vector2Distance*(v1: Vector2, v2: Vector2): real32\n"
        /* 0746 */ "fn Vector2DistanceSqr*(v1: Vector2, v2: Vector2): real32\n"
        /* 0747 */ "fn Vector2Angle*(v1: Vector2, v2: Vector2): real32\n"
        /* 0748 */ "fn Vector2Scale*(v: Vector2, scale: real32): Vector2\n"
        /* 0749 */ "fn Vector2Multiply*(v1: Vector2, v2: Vector2): Vector2\n"
        /* 0750 */ "fn Vector2Negate*(v: Vector2): Vector2\n"
        /* 0751 */ "fn Vector2Divide*(v1: Vector2, v2: Vector2): Vector2\n"
        /* 0752 */ "fn Vector2Normalize*(v: Vector2): Vector2\n"
        /* 0753 */ "fn Vector2Transform*(v: Vector2, mat: Matrix): Vector2\n"
        /* 0754 */ "fn Vector2Lerp*(v1: Vector2, v2: Vector2, amount: real32): Vector2\n"
        /* 0755 */ "fn Vector2Reflect*(v: Vector2, normal: Vector2): Vector2\n"
        /* 0756 */ "fn Vector2Rotate*(v: Vector2, angle: real32): Vector2\n"
        /* 0757 */ "fn Vector2MoveTowards*(v: Vector2, target: Vector2, maxDistance: real32): Vector2\n"
        /* 0758 */ "fn Vector2Invert*(v: Vector2): Vector2\n"
        /* 0759 */ "fn Vector2Clamp*(v: Vector2, min: Vector2, max: Vector2): Vector2\n"
        /* 0760 */ "fn Vector2ClampValue*(v: Vector2, min: real32, max: real32): Vector2\n"
        /* 0761 */ "fn Vector2Equals*(p: Vector2, q: Vector2): int32\n"
        /* 0762 */ "fn Vector3Zero*(): Vector3\n"
        /* 0763 */ "fn Vector3One*(): Vector3\n"
        /* 0764 */ "fn Vector3Add*(v1: Vector3, v2: Vector3): Vector3\n"
        /* 0765 */ "fn Vector3AddValue*(v: Vector3, add: real32): Vector3\n"
        /* 0766 */ "fn Vector3Subtract*(v1: Vector3, v2: Vector3): Vector3\n"
        /* 0767 */ "fn Vector3SubtractValue*(v: Vector3, sub: real32): Vector3\n"
        /* 0768 */ "fn Vector3Scale*(v: Vector3, scalar: real32): Vector3\n"
        /* 0769 */ "fn Vector3Multiply*(v1: Vector3, v2: Vector3): Vector3\n"
        /* 0770 */ "fn Vector3CrossProduct*(v1: Vector3, v2: Vector3): Vector3\n"
        /* 0771 */ "fn Vector3Perpendicular*(v: Vector3): Vector3\n"
        /* 0772 */ "fn Vector3Length*(v: Vector3): real32\n"
        /* 0773 */ "fn Vector3LengthSqr*(v: Vector3): real32\n"
        /* 0774 */ "fn Vector3DotProduct*(v1: Vector3, v2: Vector3): real32\n"
        /* 0775 */ "fn Vector3Distance*(v1: Vector3, v2: Vector3): real32\n"
        /* 0776 */ "fn Vector3DistanceSqr*(v1: Vector3, v2: Vector3): real32\n"
        /* 0777 */ "fn Vector3Angle*(v1: Vector3, v2: Vector3): real32\n"
        /* 0778 */ "fn Vector3Negate*(v: Vector3): Vector3\n"
        /* 0779 */ "fn Vector3Divide*(v1: Vector3, v2: Vector3): Vector3\n"
        /* 0780 */ "fn Vector3Normalize*(v: Vector3): Vector3\n"
        /* 0781 */ "fn Vector3OrthoNormalize*(v1: ^Vector3, v2: ^Vector3)\n"
        /* 0782 */ "fn Vector3Transform*(v: Vector3, mat: Matrix): Vector3\n"
        /* 0783 */ "fn Vector3RotateByQuaternion*(v: Vector3, q: Vector4): Vector3\n"
        /* 0784 */ "fn Vector3RotateByAxisAngle*(v: Vector3, axis: Vector3, angle: real32): Vector3\n"
        /* 0785 */ "fn Vector3Lerp*(v1: Vector3, v2: Vector3, amount: real32): Vector3\n"
        /* 0786 */ "fn Vector3Reflect*(v: Vector3, normal: Vector3): Vector3\n"
        /* 0787 */ "fn Vector3Min*(v1: Vector3, v2: Vector3): Vector3\n"
        /* 0788 */ "fn Vector3Max*(v1: Vector3, v2: Vector3): Vector3\n"
        /* 0789 */ "fn Vector3Barycenter*(p: Vector3, a: Vector3, b: Vector3, c: Vector3): Vector3\n"
        /* 0790 */ "fn Vector3Unproject*(source: Vector3, projection: Matrix, view: Matrix): Vector3\n"
        /* 0791 */ "fn Vector3ToFloatV*(v: Vector3): float3\n"
        /* 0792 */ "fn Vector3Invert*(v: Vector3): Vector3\n"
        /* 0793 */ "fn Vector3Clamp*(v: Vector3, min: Vector3, max: Vector3): Vector3\n"
        /* 0794 */ "fn Vector3ClampValue*(v: Vector3, min: real32, max: real32): Vector3\n"
        /* 0795 */ "fn Vector3Equals*(p: Vector3, q: Vector3): int32\n"
        /* 0796 */ "fn Vector3Refract*(v: Vector3, n: Vector3, r: real32): Vector3\n"
        /* 0797 */ "fn MatrixDeterminant*(mat: Matrix): real32\n"
        /* 0798 */ "fn MatrixTrace*(mat: Matrix): real32\n"
        /* 0799 */ "fn MatrixTranspose*(mat: Matrix): Matrix\n"
        /* 0800 */ "fn MatrixInvert*(mat: Matrix): Matrix\n"
        /* 0801 */ "fn MatrixIdentity*(): Matrix\n"
        /* 0802 */ "fn MatrixAdd*(left: Matrix, right: Matrix): Matrix\n"
        /* 0803 */ "fn MatrixSubtract*(left: Matrix, right: Matrix): Matrix\n"
        /* 0804 */ "fn MatrixMultiply*(left: Matrix, right: Matrix): Matrix\n"
        /* 0805 */ "fn MatrixTranslate*(x: real32, y: real32, z: real32): Matrix\n"
        /* 0806 */ "fn MatrixRotate*(axis: Vector3, angle: real32): Matrix\n"
        /* 0807 */ "fn MatrixRotateX*(angle: real32): Matrix\n"
        /* 0808 */ "fn MatrixRotateY*(angle: real32): Matrix\n"
        /* 0809 */ "fn MatrixRotateZ*(angle: real32): Matrix\n"
        /* 0810 */ "fn MatrixRotateXYZ*(angle: Vector3): Matrix\n"
        /* 0811 */ "fn MatrixRotateZYX*(angle: Vector3): Matrix\n"
        /* 0812 */ "fn MatrixScale*(x: real32, y: real32, z: real32): Matrix\n"
        /* 0813 */ "fn MatrixFrustum*(left: real, right: real, bottom: real, top: real, near: real, far: real): Matrix\n"
        /* 0814 */ "fn MatrixPerspective*(fovy: real, aspect: real, near: real, far: real): Matrix\n"
        /* 0815 */ "fn MatrixOrtho*(left: real, right: real, bottom: real, top: real, near: real, far: real): Matrix\n"
        /* 0816 */ "fn MatrixLookAt*(eye: Vector3, target: Vector3, up: Vector3): Matrix\n"
        /* 0817 */ "fn MatrixToFloatV*(mat: Matrix): float16\n"
        /* 0818 */ "fn QuaternionAdd*(q1: Vector4, q2: Vector4): Vector4\n"
        /* 0819 */ "fn QuaternionAddValue*(q: Vector4, add: real32): Vector4\n"
        /* 0820 */ "fn QuaternionSubtract*(q1: Vector4, q2: Vector4): Vector4\n"
        /* 0821 */ "fn QuaternionSubtractValue*(q: Vector4, sub: real32): Vector4\n"
        /* 0822 */ "fn QuaternionIdentity*(): Vector4\n"
        /* 0823 */ "fn QuaternionLength*(q: Vector4): real32\n"
        /* 0824 */ "fn QuaternionNormalize*(q: Vector4): Vector4\n"
        /* 0825 */ "fn QuaternionInvert*(q: Vector4): Vector4\n"
        /* 0826 */ "fn QuaternionMultiply*(q1: Vector4, q2: Vector4): Vector4\n"
        /* 0827 */ "fn QuaternionScale*(q: Vector4, mul: real32): Vector4\n"
        /* 0828 */ "fn QuaternionDivide*(q1: Vector4, q2: Vector4): Vector4\n"
        /* 0829 */ "fn QuaternionLerp*(q1: Vector4, q2: Vector4, amount: real32): Vector4\n"
        /* 0830 */ "fn QuaternionNlerp*(q1: Vector4, q2: Vector4, amount: real32): Vector4\n"
        /* 0831 */ "fn QuaternionSlerp*(q1: Vector4, q2: Vector4, amount: real32): Vector4\n"
        /* 0832 */ "fn QuaternionFromVector3ToVector3*(from: Vector3, to: Vector3): Vector4\n"
        /* 0833 */ "fn QuaternionFromMatrix*(mat: Matrix): Vector4\n"
        /* 0834 */ "fn QuaternionToMatrix*(q: Vector4): Matrix\n"
        /* 0835 */ "fn QuaternionFromAxisAngle*(axis: Vector3, angle: real32): Vector4\n"
        /* 0836 */ "fn QuaternionToAxisAngle*(q: Vector4, outAxis: ^Vector3, outAngle: ^real32)\n"
        /* 0837 */ "fn QuaternionFromEuler*(pitch: real32, yaw: real32, roll: real32): Vector4\n"
        /* 0838 */ "fn QuaternionToEuler*(q: Vector4): Vector3\n"
        /* 0839 */ "fn QuaternionTransform*(q: Vector4, mat: Matrix): Vector4\n"
        /* 0840 */ "fn QuaternionEquals*(p: Vector4, q: Vector4): int32\n"

        // Enums
        /* 0841 */ "const FLAG_VSYNC_HINT* = 64\n"
        /* 0842 */ "const FLAG_FULLSCREEN_MODE* = 2\n"
        /* 0843 */ "const FLAG_WINDOW_RESIZABLE* = 4\n"
        /* 0844 */ "const FLAG_WINDOW_UNDECORATED* = 8\n"
        /* 0845 */ "const FLAG_WINDOW_HIDDEN* = 128\n"
        /* 0846 */ "const FLAG_WINDOW_MINIMIZED* = 512\n"
        /* 0847 */ "const FLAG_WINDOW_MAXIMIZED* = 1024\n"
        /* 0848 */ "const FLAG_WINDOW_UNFOCUSED* = 2048\n"
        /* 0849 */ "const FLAG_WINDOW_TOPMOST* = 4096\n"
        /* 0850 */ "const FLAG_WINDOW_ALWAYS_RUN* = 256\n"
        /* 0851 */ "const FLAG_WINDOW_TRANSPARENT* = 16\n"
        /* 0852 */ "const FLAG_WINDOW_HIGHDPI* = 8192\n"
        /* 0853 */ "const FLAG_WINDOW_MOUSE_PASSTHROUGH* = 16384\n"
        /* 0854 */ "const FLAG_MSAA_4X_HINT* = 32\n"
        /* 0855 */ "const FLAG_INTERLACED_HINT* = 65536\n"
        /* 0856 */ "const LOG_ALL* = 0\n"
        /* 0857 */ "const LOG_TRACE* = 1\n"
        /* 0858 */ "const LOG_DEBUG* = 2\n"
        /* 0859 */ "const LOG_INFO* = 3\n"
        /* 0860 */ "const LOG_WARNING* = 4\n"
        /* 0861 */ "const LOG_ERROR* = 5\n"
        /* 0862 */ "const LOG_FATAL* = 6\n"
        /* 0863 */ "const LOG_NONE* = 7\n"
        /* 0864 */ "const KEY_NULL* = 0\n"
        /* 0865 */ "const KEY_APOSTROPHE* = 39\n"
        /* 0866 */ "const KEY_COMMA* = 44\n"
        /* 0867 */ "const KEY_MINUS* = 45\n"
        /* 0868 */ "const KEY_PERIOD* = 46\n"
        /* 0869 */ "const KEY_SLASH* = 47\n"
        /* 0870 */ "const KEY_ZERO* = 48\n"
        /* 0871 */ "const KEY_ONE* = 49\n"
        /* 0872 */ "const KEY_TWO* = 50\n"
        /* 0873 */ "const KEY_THREE* = 51\n"
        /* 0874 */ "const KEY_FOUR* = 52\n"
        /* 0875 */ "const KEY_FIVE* = 53\n"
        /* 0876 */ "const KEY_SIX* = 54\n"
        /* 0877 */ "const KEY_SEVEN* = 55\n"
        /* 0878 */ "const KEY_EIGHT* = 56\n"
        /* 0879 */ "const KEY_NINE* = 57\n"
        /* 0880 */ "const KEY_SEMICOLON* = 59\n"
        /* 0881 */ "const KEY_EQUAL* = 61\n"
        /* 0882 */ "const KEY_A* = 65\n"
        /* 0883 */ "const KEY_B* = 66\n"
        /* 0884 */ "const KEY_C* = 67\n"
        /* 0885 */ "const KEY_D* = 68\n"
        /* 0886 */ "const KEY_E* = 69\n"
        /* 0887 */ "const KEY_F* = 70\n"
        /* 0888 */ "const KEY_G* = 71\n"
        /* 0889 */ "const KEY_H* = 72\n"
        /* 0890 */ "const KEY_I* = 73\n"
        /* 0891 */ "const KEY_J* = 74\n"
        /* 0892 */ "const KEY_K* = 75\n"
        /* 0893 */ "const KEY_L* = 76\n"
        /* 0894 */ "const KEY_M* = 77\n"
        /* 0895 */ "const KEY_N* = 78\n"
        /* 0896 */ "const KEY_O* = 79\n"
        /* 0897 */ "const KEY_P* = 80\n"
        /* 0898 */ "const KEY_Q* = 81\n"
        /* 0899 */ "const KEY_R* = 82\n"
        /* 0900 */ "const KEY_S* = 83\n"
        /* 0901 */ "const KEY_T* = 84\n"
        /* 0902 */ "const KEY_U* = 85\n"
        /* 0903 */ "const KEY_V* = 86\n"
        /* 0904 */ "const KEY_W* = 87\n"
        /* 0905 */ "const KEY_X* = 88\n"
        /* 0906 */ "const KEY_Y* = 89\n"
        /* 0907 */ "const KEY_Z* = 90\n"
        /* 0908 */ "const KEY_LEFT_BRACKET* = 91\n"
        /* 0909 */ "const KEY_BACKSLASH* = 92\n"
        /* 0910 */ "const KEY_RIGHT_BRACKET* = 93\n"
        /* 0911 */ "const KEY_GRAVE* = 96\n"
        /* 0912 */ "const KEY_SPACE* = 32\n"
        /* 0913 */ "const KEY_ESCAPE* = 256\n"
        /* 0914 */ "const KEY_ENTER* = 257\n"
        /* 0915 */ "const KEY_TAB* = 258\n"
        /* 0916 */ "const KEY_BACKSPACE* = 259\n"
        /* 0917 */ "const KEY_INSERT* = 260\n"
        /* 0918 */ "const KEY_DELETE* = 261\n"
        /* 0919 */ "const KEY_RIGHT* = 262\n"
        /* 0920 */ "const KEY_LEFT* = 263\n"
        /* 0921 */ "const KEY_DOWN* = 264\n"
        /* 0922 */ "const KEY_UP* = 265\n"
        /* 0923 */ "const KEY_PAGE_UP* = 266\n"
        /* 0924 */ "const KEY_PAGE_DOWN* = 267\n"
        /* 0925 */ "const KEY_HOME* = 268\n"
        /* 0926 */ "const KEY_END* = 269\n"
        /* 0927 */ "const KEY_CAPS_LOCK* = 280\n"
        /* 0928 */ "const KEY_SCROLL_LOCK* = 281\n"
        /* 0929 */ "const KEY_NUM_LOCK* = 282\n"
        /* 0930 */ "const KEY_PRINT_SCREEN* = 283\n"
        /* 0931 */ "const KEY_PAUSE* = 284\n"
        /* 0932 */ "const KEY_F1* = 290\n"
        /* 0933 */ "const KEY_F2* = 291\n"
        /* 0934 */ "const KEY_F3* = 292\n"
        /* 0935 */ "const KEY_F4* = 293\n"
        /* 0936 */ "const KEY_F5* = 294\n"
        /* 0937 */ "const KEY_F6* = 295\n"
        /* 0938 */ "const KEY_F7* = 296\n"
        /* 0939 */ "const KEY_F8* = 297\n"
        /* 0940 */ "const KEY_F9* = 298\n"
        /* 0941 */ "const KEY_F10* = 299\n"
        /* 0942 */ "const KEY_F11* = 300\n"
        /* 0943 */ "const KEY_F12* = 301\n"
        /* 0944 */ "const KEY_LEFT_SHIFT* = 340\n"
        /* 0945 */ "const KEY_LEFT_CONTROL* = 341\n"
        /* 0946 */ "const KEY_LEFT_ALT* = 342\n"
        /* 0947 */ "const KEY_LEFT_SUPER* = 343\n"
        /* 0948 */ "const KEY_RIGHT_SHIFT* = 344\n"
        /* 0949 */ "const KEY_RIGHT_CONTROL* = 345\n"
        /* 0950 */ "const KEY_RIGHT_ALT* = 346\n"
        /* 0951 */ "const KEY_RIGHT_SUPER* = 347\n"
        /* 0952 */ "const KEY_KB_MENU* = 348\n"
        /* 0953 */ "const KEY_KP_0* = 320\n"
        /* 0954 */ "const KEY_KP_1* = 321\n"
        /* 0955 */ "const KEY_KP_2* = 322\n"
        /* 0956 */ "const KEY_KP_3* = 323\n"
        /* 0957 */ "const KEY_KP_4* = 324\n"
        /* 0958 */ "const KEY_KP_5* = 325\n"
        /* 0959 */ "const KEY_KP_6* = 326\n"
        /* 0960 */ "const KEY_KP_7* = 327\n"
        /* 0961 */ "const KEY_KP_8* = 328\n"
        /* 0962 */ "const KEY_KP_9* = 329\n"
        /* 0963 */ "const KEY_KP_DECIMAL* = 330\n"
        /* 0964 */ "const KEY_KP_DIVIDE* = 331\n"
        /* 0965 */ "const KEY_KP_MULTIPLY* = 332\n"
        /* 0966 */ "const KEY_KP_SUBTRACT* = 333\n"
        /* 0967 */ "const KEY_KP_ADD* = 334\n"
        /* 0968 */ "const KEY_KP_ENTER* = 335\n"
        /* 0969 */ "const KEY_KP_EQUAL* = 336\n"
        /* 0970 */ "const KEY_BACK* = 4\n"
        /* 0971 */ "const KEY_MENU* = 82\n"
        /* 0972 */ "const KEY_VOLUME_UP* = 24\n"
        /* 0973 */ "const KEY_VOLUME_DOWN* = 25\n"
        /* 0974 */ "const MOUSE_BUTTON_LEFT* = 0\n"
        /* 0975 */ "const MOUSE_BUTTON_RIGHT* = 1\n"
        /* 0976 */ "const MOUSE_BUTTON_MIDDLE* = 2\n"
        /* 0977 */ "const MOUSE_BUTTON_SIDE* = 3\n"
        /* 0978 */ "const MOUSE_BUTTON_EXTRA* = 4\n"
        /* 0979 */ "const MOUSE_BUTTON_FORWARD* = 5\n"
        /* 0980 */ "const MOUSE_BUTTON_BACK* = 6\n"
        /* 0981 */ "const MOUSE_CURSOR_DEFAULT* = 0\n"
        /* 0982 */ "const MOUSE_CURSOR_ARROW* = 1\n"
        /* 0983 */ "const MOUSE_CURSOR_IBEAM* = 2\n"
        /* 0984 */ "const MOUSE_CURSOR_CROSSHAIR* = 3\n"
        /* 0985 */ "const MOUSE_CURSOR_POINTING_HAND* = 4\n"
        /* 0986 */ "const MOUSE_CURSOR_RESIZE_EW* = 5\n"
        /* 0987 */ "const MOUSE_CURSOR_RESIZE_NS* = 6\n"
        /* 0988 */ "const MOUSE_CURSOR_RESIZE_NWSE* = 7\n"
        /* 0989 */ "const MOUSE_CURSOR_RESIZE_NESW* = 8\n"
        /* 0990 */ "const MOUSE_CURSOR_RESIZE_ALL* = 9\n"
        /* 0991 */ "const MOUSE_CURSOR_NOT_ALLOWED* = 10\n"
        /* 0992 */ "const GAMEPAD_BUTTON_UNKNOWN* = 0\n"
        /* 0993 */ "const GAMEPAD_BUTTON_LEFT_FACE_UP* = 1\n"
        /* 0994 */ "const GAMEPAD_BUTTON_LEFT_FACE_RIGHT* = 2\n"
        /* 0995 */ "const GAMEPAD_BUTTON_LEFT_FACE_DOWN* = 3\n"
        /* 0996 */ "const GAMEPAD_BUTTON_LEFT_FACE_LEFT* = 4\n"
        /* 0997 */ "const GAMEPAD_BUTTON_RIGHT_FACE_UP* = 5\n"
        /* 0998 */ "const GAMEPAD_BUTTON_RIGHT_FACE_RIGHT* = 6\n"
        /* 0999 */ "const GAMEPAD_BUTTON_RIGHT_FACE_DOWN* = 7\n"
        /* 1000 */ "const GAMEPAD_BUTTON_RIGHT_FACE_LEFT* = 8\n"
        /* 1001 */ "const GAMEPAD_BUTTON_LEFT_TRIGGER_1* = 9\n"
        /* 1002 */ "const GAMEPAD_BUTTON_LEFT_TRIGGER_2* = 10\n"
        /* 1003 */ "const GAMEPAD_BUTTON_RIGHT_TRIGGER_1* = 11\n"
        /* 1004 */ "const GAMEPAD_BUTTON_RIGHT_TRIGGER_2* = 12\n"
        /* 1005 */ "const GAMEPAD_BUTTON_MIDDLE_LEFT* = 13\n"
        /* 1006 */ "const GAMEPAD_BUTTON_MIDDLE* = 14\n"
        /* 1007 */ "const GAMEPAD_BUTTON_MIDDLE_RIGHT* = 15\n"
        /* 1008 */ "const GAMEPAD_BUTTON_LEFT_THUMB* = 16\n"
        /* 1009 */ "const GAMEPAD_BUTTON_RIGHT_THUMB* = 17\n"
        /* 1010 */ "const GAMEPAD_AXIS_LEFT_X* = 0\n"
        /* 1011 */ "const GAMEPAD_AXIS_LEFT_Y* = 1\n"
        /* 1012 */ "const GAMEPAD_AXIS_RIGHT_X* = 2\n"
        /* 1013 */ "const GAMEPAD_AXIS_RIGHT_Y* = 3\n"
        /* 1014 */ "const GAMEPAD_AXIS_LEFT_TRIGGER* = 4\n"
        /* 1015 */ "const GAMEPAD_AXIS_RIGHT_TRIGGER* = 5\n"
        /* 1016 */ "const MATERIAL_MAP_ALBEDO* = 0\n"
        /* 1017 */ "const MATERIAL_MAP_METALNESS* = 1\n"
        /* 1018 */ "const MATERIAL_MAP_NORMAL* = 2\n"
        /* 1019 */ "const MATERIAL_MAP_ROUGHNESS* = 3\n"
        /* 1020 */ "const MATERIAL_MAP_OCCLUSION* = 4\n"
        /* 1021 */ "const MATERIAL_MAP_EMISSION* = 5\n"
        /* 1022 */ "const MATERIAL_MAP_HEIGHT* = 6\n"
        /* 1023 */ "const MATERIAL_MAP_CUBEMAP* = 7\n"
        /* 1024 */ "const MATERIAL_MAP_IRRADIANCE* = 8\n"
        /* 1025 */ "const MATERIAL_MAP_PREFILTER* = 9\n"
        /* 1026 */ "const MATERIAL_MAP_BRDF* = 10\n"
        /* 1027 */ "const SHADER_LOC_VERTEX_POSITION* = 0\n"
        /* 1028 */ "const SHADER_LOC_VERTEX_TEXCOORD01* = 1\n"
        /* 1029 */ "const SHADER_LOC_VERTEX_TEXCOORD02* = 2\n"
        /* 1030 */ "const SHADER_LOC_VERTEX_NORMAL* = 3\n"
        /* 1031 */ "const SHADER_LOC_VERTEX_TANGENT* = 4\n"
        /* 1032 */ "const SHADER_LOC_VERTEX_COLOR* = 5\n"
        /* 1033 */ "const SHADER_LOC_MATRIX_MVP* = 6\n"
        /* 1034 */ "const SHADER_LOC_MATRIX_VIEW* = 7\n"
        /* 1035 */ "const SHADER_LOC_MATRIX_PROJECTION* = 8\n"
        /* 1036 */ "const SHADER_LOC_MATRIX_MODEL* = 9\n"
        /* 1037 */ "const SHADER_LOC_MATRIX_NORMAL* = 10\n"
        /* 1038 */ "const SHADER_LOC_VECTOR_VIEW* = 11\n"
        /* 1039 */ "const SHADER_LOC_COLOR_DIFFUSE* = 12\n"
        /* 1040 */ "const SHADER_LOC_COLOR_SPECULAR* = 13\n"
        /* 1041 */ "const SHADER_LOC_COLOR_AMBIENT* = 14\n"
        /* 1042 */ "const SHADER_LOC_MAP_ALBEDO* = 15\n"
        /* 1043 */ "const SHADER_LOC_MAP_METALNESS* = 16\n"
        /* 1044 */ "const SHADER_LOC_MAP_NORMAL* = 17\n"
        /* 1045 */ "const SHADER_LOC_MAP_ROUGHNESS* = 18\n"
        /* 1046 */ "const SHADER_LOC_MAP_OCCLUSION* = 19\n"
        /* 1047 */ "const SHADER_LOC_MAP_EMISSION* = 20\n"
        /* 1048 */ "const SHADER_LOC_MAP_HEIGHT* = 21\n"
        /* 1049 */ "const SHADER_LOC_MAP_CUBEMAP* = 22\n"
        /* 1050 */ "const SHADER_LOC_MAP_IRRADIANCE* = 23\n"
        /* 1051 */ "const SHADER_LOC_MAP_PREFILTER* = 24\n"
        /* 1052 */ "const SHADER_LOC_MAP_BRDF* = 25\n"
        /* 1053 */ "const SHADER_UNIFORM_FLOAT* = 0\n"
        /* 1054 */ "const SHADER_UNIFORM_VEC2* = 1\n"
        /* 1055 */ "const SHADER_UNIFORM_VEC3* = 2\n"
        /* 1056 */ "const SHADER_UNIFORM_VEC4* = 3\n"
        /* 1057 */ "const SHADER_UNIFORM_INT* = 4\n"
        /* 1058 */ "const SHADER_UNIFORM_IVEC2* = 5\n"
        /* 1059 */ "const SHADER_UNIFORM_IVEC3* = 6\n"
        /* 1060 */ "const SHADER_UNIFORM_IVEC4* = 7\n"
        /* 1061 */ "const SHADER_UNIFORM_SAMPLER2D* = 8\n"
        /* 1062 */ "const SHADER_ATTRIB_FLOAT* = 0\n"
        /* 1063 */ "const SHADER_ATTRIB_VEC2* = 1\n"
        /* 1064 */ "const SHADER_ATTRIB_VEC3* = 2\n"
        /* 1065 */ "const SHADER_ATTRIB_VEC4* = 3\n"
        /* 1066 */ "const PIXELFORMAT_UNCOMPRESSED_GRAYSCALE* = 1\n"
        /* 1067 */ "const PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA* = 2\n"
        /* 1068 */ "const PIXELFORMAT_UNCOMPRESSED_R5G6B5* = 3\n"
        /* 1069 */ "const PIXELFORMAT_UNCOMPRESSED_R8G8B8* = 4\n"
        /* 1070 */ "const PIXELFORMAT_UNCOMPRESSED_R5G5B5A1* = 5\n"
        /* 1071 */ "const PIXELFORMAT_UNCOMPRESSED_R4G4B4A4* = 6\n"
        /* 1072 */ "const PIXELFORMAT_UNCOMPRESSED_R8G8B8A8* = 7\n"
        /* 1073 */ "const PIXELFORMAT_UNCOMPRESSED_R32* = 8\n"
        /* 1074 */ "const PIXELFORMAT_UNCOMPRESSED_R32G32B32* = 9\n"
        /* 1075 */ "const PIXELFORMAT_UNCOMPRESSED_R32G32B32A32* = 10\n"
        /* 1076 */ "const PIXELFORMAT_COMPRESSED_DXT1_RGB* = 11\n"
        /* 1077 */ "const PIXELFORMAT_COMPRESSED_DXT1_RGBA* = 12\n"
        /* 1078 */ "const PIXELFORMAT_COMPRESSED_DXT3_RGBA* = 13\n"
        /* 1079 */ "const PIXELFORMAT_COMPRESSED_DXT5_RGBA* = 14\n"
        /* 1080 */ "const PIXELFORMAT_COMPRESSED_ETC1_RGB* = 15\n"
        /* 1081 */ "const PIXELFORMAT_COMPRESSED_ETC2_RGB* = 16\n"
        /* 1082 */ "const PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA* = 17\n"
        /* 1083 */ "const PIXELFORMAT_COMPRESSED_PVRT_RGB* = 18\n"
        /* 1084 */ "const PIXELFORMAT_COMPRESSED_PVRT_RGBA* = 19\n"
        /* 1085 */ "const PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA* = 20\n"
        /* 1086 */ "const PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA* = 21\n"
        /* 1087 */ "const TEXTURE_FILTER_POINT* = 0\n"
        /* 1088 */ "const TEXTURE_FILTER_BILINEAR* = 1\n"
        /* 1089 */ "const TEXTURE_FILTER_TRILINEAR* = 2\n"
        /* 1090 */ "const TEXTURE_FILTER_ANISOTROPIC_4X* = 3\n"
        /* 1091 */ "const TEXTURE_FILTER_ANISOTROPIC_8X* = 4\n"
        /* 1092 */ "const TEXTURE_FILTER_ANISOTROPIC_16X* = 5\n"
        /* 1093 */ "const TEXTURE_WRAP_REPEAT* = 0\n"
        /* 1094 */ "const TEXTURE_WRAP_CLAMP* = 1\n"
        /* 1095 */ "const TEXTURE_WRAP_MIRROR_REPEAT* = 2\n"
        /* 1096 */ "const TEXTURE_WRAP_MIRROR_CLAMP* = 3\n"
        /* 1097 */ "const CUBEMAP_LAYOUT_AUTO_DETECT* = 0\n"
        /* 1098 */ "const CUBEMAP_LAYOUT_LINE_VERTICAL* = 1\n"
        /* 1099 */ "const CUBEMAP_LAYOUT_LINE_HORIZONTAL* = 2\n"
        /* 1100 */ "const CUBEMAP_LAYOUT_CROSS_THREE_BY_FOUR* = 3\n"
        /* 1101 */ "const CUBEMAP_LAYOUT_CROSS_FOUR_BY_THREE* = 4\n"
        /* 1102 */ "const CUBEMAP_LAYOUT_PANORAMA* = 5\n"
        /* 1103 */ "const FONT_DEFAULT* = 0\n"
        /* 1104 */ "const FONT_BITMAP* = 1\n"
        /* 1105 */ "const FONT_SDF* = 2\n"
        /* 1106 */ "const BLEND_ALPHA* = 0\n"
        /* 1107 */ "const BLEND_ADDITIVE* = 1\n"
        /* 1108 */ "const BLEND_MULTIPLIED* = 2\n"
        /* 1109 */ "const BLEND_ADD_COLORS* = 3\n"
        /* 1110 */ "const BLEND_SUBTRACT_COLORS* = 4\n"
        /* 1111 */ "const BLEND_ALPHA_PREMULTIPLY* = 5\n"
        /* 1112 */ "const BLEND_CUSTOM* = 6\n"
        /* 1113 */ "const GESTURE_NONE* = 0\n"
        /* 1114 */ "const GESTURE_TAP* = 1\n"
        /* 1115 */ "const GESTURE_DOUBLETAP* = 2\n"
        /* 1116 */ "const GESTURE_HOLD* = 4\n"
        /* 1117 */ "const GESTURE_DRAG* = 8\n"
        /* 1118 */ "const GESTURE_SWIPE_RIGHT* = 16\n"
        /* 1119 */ "const GESTURE_SWIPE_LEFT* = 32\n"
        /* 1120 */ "const GESTURE_SWIPE_UP* = 64\n"
        /* 1121 */ "const GESTURE_SWIPE_DOWN* = 128\n"
        /* 1122 */ "const GESTURE_PINCH_IN* = 256\n"
        /* 1123 */ "const GESTURE_PINCH_OUT* = 512\n"
        /* 1124 */ "const CAMERA_CUSTOM* = 0\n"
        /* 1125 */ "const CAMERA_FREE* = 1\n"
        /* 1126 */ "const CAMERA_ORBITAL* = 2\n"
        /* 1127 */ "const CAMERA_FIRST_PERSON* = 3\n"
        /* 1128 */ "const CAMERA_THIRD_PERSON* = 4\n"
        /* 1129 */ "const CAMERA_PERSPECTIVE* = 0\n"
        /* 1130 */ "const CAMERA_ORTHOGRAPHIC* = 1\n"
        /* 1131 */ "const NPATCH_NINE_PATCH* = 0\n"
        /* 1132 */ "const NPATCH_THREE_PATCH_VERTICAL* = 1\n"
        /* 1133 */ "const NPATCH_THREE_PATCH_HORIZONTAL* = 2\n"

        // Defines
        /* 1134 */ "const RAYLIB_VERSION* = \"4.2\"\n"
        // Skipped define: __declspec(x)
        // Skipped define: RLAPI
        /* 1135 */ "const PI* = 3.141592653589793\n"
        // Skipped define: DEG2RAD
        // Skipped define: RAD2DEG
        // Skipped define: RL_MALLOC(sz)
        // Skipped define: RL_CALLOC(n,sz)
        // Skipped define: RL_REALLOC(ptr,sz)
        // Skipped define: RL_FREE(ptr)
        // Skipped define: CLITERAL(type)
        /* 1136 */ "const LIGHTGRAY* = Color{ 200, 200, 200, 255 }\n"
        /* 1137 */ "const GRAY* = Color{ 130, 130, 130, 255 }\n"
        /* 1138 */ "const DARKGRAY* = Color{ 80, 80, 80, 255 }\n"
        /* 1139 */ "const YELLOW* = Color{ 253, 249, 0, 255 }\n"
        /* 1140 */ "const GOLD* = Color{ 255, 203, 0, 255 }\n"
        /* 1141 */ "const ORANGE* = Color{ 255, 161, 0, 255 }\n"
        /* 1142 */ "const PINK* = Color{ 255, 109, 194, 255 }\n"
        /* 1143 */ "const RED* = Color{ 230, 41, 55, 255 }\n"
        /* 1144 */ "const MAROON* = Color{ 190, 33, 55, 255 }\n"
        /* 1145 */ "const GREEN* = Color{ 0, 228, 48, 255 }\n"
        /* 1146 */ "const LIME* = Color{ 0, 158, 47, 255 }\n"
        /* 1147 */ "const DARKGREEN* = Color{ 0, 117, 44, 255 }\n"
        /* 1148 */ "const SKYBLUE* = Color{ 102, 191, 255, 255 }\n"
        /* 1149 */ "const BLUE* = Color{ 0, 121, 241, 255 }\n"
        /* 1150 */ "const DARKBLUE* = Color{ 0, 82, 172, 255 }\n"
        /* 1151 */ "const PURPLE* = Color{ 200, 122, 255, 255 }\n"
        /* 1152 */ "const VIOLET* = Color{ 135, 60, 190, 255 }\n"
        /* 1153 */ "const DARKPURPLE* = Color{ 112, 31, 126, 255 }\n"
        /* 1154 */ "const BEIGE* = Color{ 211, 176, 131, 255 }\n"
        /* 1155 */ "const BROWN* = Color{ 127, 106, 79, 255 }\n"
        /* 1156 */ "const DARKBROWN* = Color{ 76, 63, 47, 255 }\n"
        /* 1157 */ "const WHITE* = Color{ 255, 255, 255, 255 }\n"
        /* 1158 */ "const BLACK* = Color{ 0, 0, 0, 255 }\n"
        /* 1159 */ "const BLANK* = Color{ 0, 0, 0, 0 }\n"
        /* 1160 */ "const MAGENTA* = Color{ 255, 0, 255, 255 }\n"
        /* 1161 */ "const RAYWHITE* = Color{ 245, 245, 245, 255 }\n"
        // Skipped define: MOUSE_LEFT_BUTTON
        // Skipped define: MOUSE_RIGHT_BUTTON
        // Skipped define: MOUSE_MIDDLE_BUTTON
        // Skipped define: MATERIAL_MAP_DIFFUSE
        // Skipped define: MATERIAL_MAP_SPECULAR
        // Skipped define: SHADER_LOC_MAP_DIFFUSE
        // Skipped define: SHADER_LOC_MAP_SPECULAR
        // Skipped define: RMAPI
        /* 1162 */ "const EPSILON* = 0.000001\n"
        // Skipped define: MatrixToFloat(mat)
        // Skipped define: Vector3ToFloat(vec)

        // Custom functions
        "fn TraceLog*(errorType: int , message: str)\n"

        // End of the module.
        " ";

    return umkaAddModule(umka, "raylib", moduleCode);
}

#if defined(__cplusplus)
}
#endif

#endif // RAYLIB_UMKA_IMPLEMENTATION_ONCE
#endif // RAYLIB_UMKA_IMPLEMENTATION
