/**********************************************************************************************
*
*   raylib-umka v0.0.3 - Umka bindings for raylib.
*
*   https://github.com/RobLoach/raylib-umka
*
*   DEPENDENCIES:
*       - raylib 4.2 https://www.raylib.com/
*       - Umka https://github.com/vtereshkov/umka-lang
*
*   NOTE: Do not edit this file, as it is automatically generated.
*
*   LICENSE: zlib/libpng
*
*   raylib-umka is licensed under an unmodified zlib/libpng license, which is an OSI-certified,
*   BSD-like license that allows static linking with closed source software:
*
*   Copyright (c) 2022 Rob Loach (https://robloach.net)
*
*   This software is provided "as-is", without any express or implied warranty. In no event
*   will the authors be held liable for any damages arising from the use of this software.
*
*   Permission is granted to anyone to use this software for any purpose, including commercial
*   applications, and to alter it and redistribute it freely, subject to the following restrictions:
*
*     1. The origin of this software must not be misrepresented; you must not claim that you
*     wrote the original software. If you use this software in a product, an acknowledgment
*     in the product documentation would be appreciated but is not required.
*
*     2. Altered source versions must be plainly marked as such, and must not be misrepresented
*     as being the original software.
*
*     3. This notice may not be removed or altered from any source distribution.
*
**********************************************************************************************/

#ifndef RAYLIB_UMKA_H_
#define RAYLIB_UMKA_H_

#if defined(__cplusplus)
extern "C" {
#endif

/**
 * RAYLIB_UMKA_NO_ADD_MODULE allows enabling or disabling the umkaAddRaylib() method.
 */
#ifndef RAYLIB_UMKA_NO_ADD_MODULE

/**
 * Adds the raylib module to an Umka instance.
 *
 * @param umka The Umka instance you would like to add the raylib module to.
 *
 * @return True if it succeeds, false otherwise.
 */
bool umkaAddRaylib(void *umka);

#endif  // RAYLIB_UMKA_NO_ADD_MODULE

#if defined(__cplusplus)
}
#endif

#endif  // RAYLIB_UMKA_H_

#ifdef RAYLIB_UMKA_IMPLEMENTATION
#ifndef RAYLIB_UMKA_IMPLEMENTATION_ONCE
#define RAYLIB_UMKA_IMPLEMENTATION_ONCE

// raylib.h
#ifndef RAYLIB_UMKA_RAYLIB_H
#define RAYLIB_UMKA_RAYLIB_H "raylib.h"
#endif
#include RAYLIB_UMKA_RAYLIB_H

// raymath.h
#ifndef RAYLIB_UMKA_RAYMATH_H
#define RAYLIB_UMKA_RAYMATH_H "raymath.h"
#endif
#include RAYLIB_UMKA_RAYMATH_H

// rlgl.h
#ifndef RAYLIB_UMKA_RLGL_H
#define RAYLIB_UMKA_RLGL_H "rlgl.h"
#endif
#include RAYLIB_UMKA_RLGL_H

// umka_api.h
#ifndef RAYLIB_UMKA_UMKA_API_H
#define RAYLIB_UMKA_UMKA_API_H "umka_api.h"
#endif
#include RAYLIB_UMKA_UMKA_API_H

// memcpy()
#ifndef RAYLIB_UMKA_MEMCPY
#include <string.h>
#define RAYLIB_UMKA_MEMCPY memcpy
#endif

#ifndef RAYLIB_UMKA_FUNCTION
#define RAYLIB_UMKA_FUNCTION(functionName)
#endif

#if defined(__cplusplus)
extern "C" {
#endif

/**
 * Umka bindings for InitWindow().
 *
 * @see InitWindow()
 */
RAYLIB_UMKA_FUNCTION(InitWindow)
void umkaInitWindow(UmkaStackSlot *params, UmkaStackSlot *result) {
    int width = params[2].intVal;
    int height = params[1].intVal;
    const char * title = (const char *)params[0].ptrVal;
    InitWindow(width, height, title);
}

/**
 * Umka bindings for WindowShouldClose().
 *
 * @see WindowShouldClose()
 */
RAYLIB_UMKA_FUNCTION(WindowShouldClose)
void umkaWindowShouldClose(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->intVal = (int)WindowShouldClose();
}

/**
 * Umka bindings for CloseWindow().
 *
 * @see CloseWindow()
 */
RAYLIB_UMKA_FUNCTION(CloseWindow)
void umkaCloseWindow(UmkaStackSlot *params, UmkaStackSlot *result) {
    CloseWindow();
}

/**
 * Umka bindings for IsWindowReady().
 *
 * @see IsWindowReady()
 */
RAYLIB_UMKA_FUNCTION(IsWindowReady)
void umkaIsWindowReady(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->intVal = (int)IsWindowReady();
}

/**
 * Umka bindings for IsWindowFullscreen().
 *
 * @see IsWindowFullscreen()
 */
RAYLIB_UMKA_FUNCTION(IsWindowFullscreen)
void umkaIsWindowFullscreen(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->intVal = (int)IsWindowFullscreen();
}

/**
 * Umka bindings for IsWindowHidden().
 *
 * @see IsWindowHidden()
 */
RAYLIB_UMKA_FUNCTION(IsWindowHidden)
void umkaIsWindowHidden(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->intVal = (int)IsWindowHidden();
}

/**
 * Umka bindings for IsWindowMinimized().
 *
 * @see IsWindowMinimized()
 */
RAYLIB_UMKA_FUNCTION(IsWindowMinimized)
void umkaIsWindowMinimized(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->intVal = (int)IsWindowMinimized();
}

/**
 * Umka bindings for IsWindowMaximized().
 *
 * @see IsWindowMaximized()
 */
RAYLIB_UMKA_FUNCTION(IsWindowMaximized)
void umkaIsWindowMaximized(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->intVal = (int)IsWindowMaximized();
}

/**
 * Umka bindings for IsWindowFocused().
 *
 * @see IsWindowFocused()
 */
RAYLIB_UMKA_FUNCTION(IsWindowFocused)
void umkaIsWindowFocused(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->intVal = (int)IsWindowFocused();
}

/**
 * Umka bindings for IsWindowResized().
 *
 * @see IsWindowResized()
 */
RAYLIB_UMKA_FUNCTION(IsWindowResized)
void umkaIsWindowResized(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->intVal = (int)IsWindowResized();
}

/**
 * Umka bindings for IsWindowState().
 *
 * @see IsWindowState()
 */
RAYLIB_UMKA_FUNCTION(IsWindowState)
void umkaIsWindowState(UmkaStackSlot *params, UmkaStackSlot *result) {
    unsigned int flag = params[0].uintVal;
    result->intVal = (int)IsWindowState(flag);
}

/**
 * Umka bindings for SetWindowState().
 *
 * @see SetWindowState()
 */
RAYLIB_UMKA_FUNCTION(SetWindowState)
void umkaSetWindowState(UmkaStackSlot *params, UmkaStackSlot *result) {
    unsigned int flags = params[0].uintVal;
    SetWindowState(flags);
}

/**
 * Umka bindings for ClearWindowState().
 *
 * @see ClearWindowState()
 */
RAYLIB_UMKA_FUNCTION(ClearWindowState)
void umkaClearWindowState(UmkaStackSlot *params, UmkaStackSlot *result) {
    unsigned int flags = params[0].uintVal;
    ClearWindowState(flags);
}

/**
 * Umka bindings for ToggleFullscreen().
 *
 * @see ToggleFullscreen()
 */
RAYLIB_UMKA_FUNCTION(ToggleFullscreen)
void umkaToggleFullscreen(UmkaStackSlot *params, UmkaStackSlot *result) {
    ToggleFullscreen();
}

/**
 * Umka bindings for MaximizeWindow().
 *
 * @see MaximizeWindow()
 */
RAYLIB_UMKA_FUNCTION(MaximizeWindow)
void umkaMaximizeWindow(UmkaStackSlot *params, UmkaStackSlot *result) {
    MaximizeWindow();
}

/**
 * Umka bindings for MinimizeWindow().
 *
 * @see MinimizeWindow()
 */
RAYLIB_UMKA_FUNCTION(MinimizeWindow)
void umkaMinimizeWindow(UmkaStackSlot *params, UmkaStackSlot *result) {
    MinimizeWindow();
}

/**
 * Umka bindings for RestoreWindow().
 *
 * @see RestoreWindow()
 */
RAYLIB_UMKA_FUNCTION(RestoreWindow)
void umkaRestoreWindow(UmkaStackSlot *params, UmkaStackSlot *result) {
    RestoreWindow();
}

/**
 * Umka bindings for SetWindowIcon().
 *
 * @see SetWindowIcon()
 */
RAYLIB_UMKA_FUNCTION(SetWindowIcon)
void umkaSetWindowIcon(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image* image = (Image*)&params[0];
    SetWindowIcon(*image);
}

/**
 * Umka bindings for SetWindowTitle().
 *
 * @see SetWindowTitle()
 */
RAYLIB_UMKA_FUNCTION(SetWindowTitle)
void umkaSetWindowTitle(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * title = (const char *)params[0].ptrVal;
    SetWindowTitle(title);
}

/**
 * Umka bindings for SetWindowPosition().
 *
 * @see SetWindowPosition()
 */
RAYLIB_UMKA_FUNCTION(SetWindowPosition)
void umkaSetWindowPosition(UmkaStackSlot *params, UmkaStackSlot *result) {
    int x = params[1].intVal;
    int y = params[0].intVal;
    SetWindowPosition(x, y);
}

/**
 * Umka bindings for SetWindowMonitor().
 *
 * @see SetWindowMonitor()
 */
RAYLIB_UMKA_FUNCTION(SetWindowMonitor)
void umkaSetWindowMonitor(UmkaStackSlot *params, UmkaStackSlot *result) {
    int monitor = params[0].intVal;
    SetWindowMonitor(monitor);
}

/**
 * Umka bindings for SetWindowMinSize().
 *
 * @see SetWindowMinSize()
 */
RAYLIB_UMKA_FUNCTION(SetWindowMinSize)
void umkaSetWindowMinSize(UmkaStackSlot *params, UmkaStackSlot *result) {
    int width = params[1].intVal;
    int height = params[0].intVal;
    SetWindowMinSize(width, height);
}

/**
 * Umka bindings for SetWindowSize().
 *
 * @see SetWindowSize()
 */
RAYLIB_UMKA_FUNCTION(SetWindowSize)
void umkaSetWindowSize(UmkaStackSlot *params, UmkaStackSlot *result) {
    int width = params[1].intVal;
    int height = params[0].intVal;
    SetWindowSize(width, height);
}

/**
 * Umka bindings for SetWindowOpacity().
 *
 * @see SetWindowOpacity()
 */
RAYLIB_UMKA_FUNCTION(SetWindowOpacity)
void umkaSetWindowOpacity(UmkaStackSlot *params, UmkaStackSlot *result) {
    float opacity = params[0].real32Val;
    SetWindowOpacity(opacity);
}

/**
 * Umka bindings for GetWindowHandle().
 *
 * @see GetWindowHandle()
 */
RAYLIB_UMKA_FUNCTION(GetWindowHandle)
void umkaGetWindowHandle(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->ptrVal = (void*)GetWindowHandle();
}

/**
 * Umka bindings for GetScreenWidth().
 *
 * @see GetScreenWidth()
 */
RAYLIB_UMKA_FUNCTION(GetScreenWidth)
void umkaGetScreenWidth(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->intVal = GetScreenWidth();
}

/**
 * Umka bindings for GetScreenHeight().
 *
 * @see GetScreenHeight()
 */
RAYLIB_UMKA_FUNCTION(GetScreenHeight)
void umkaGetScreenHeight(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->intVal = GetScreenHeight();
}

/**
 * Umka bindings for GetRenderWidth().
 *
 * @see GetRenderWidth()
 */
RAYLIB_UMKA_FUNCTION(GetRenderWidth)
void umkaGetRenderWidth(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->intVal = GetRenderWidth();
}

/**
 * Umka bindings for GetRenderHeight().
 *
 * @see GetRenderHeight()
 */
RAYLIB_UMKA_FUNCTION(GetRenderHeight)
void umkaGetRenderHeight(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->intVal = GetRenderHeight();
}

/**
 * Umka bindings for GetMonitorCount().
 *
 * @see GetMonitorCount()
 */
RAYLIB_UMKA_FUNCTION(GetMonitorCount)
void umkaGetMonitorCount(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->intVal = GetMonitorCount();
}

/**
 * Umka bindings for GetCurrentMonitor().
 *
 * @see GetCurrentMonitor()
 */
RAYLIB_UMKA_FUNCTION(GetCurrentMonitor)
void umkaGetCurrentMonitor(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->intVal = GetCurrentMonitor();
}

/**
 * Umka bindings for GetMonitorPosition().
 *
 * @see GetMonitorPosition()
 */
RAYLIB_UMKA_FUNCTION(GetMonitorPosition)
void umkaGetMonitorPosition(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    int monitor = params[1].intVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector2), NULL);
    Vector2 out = GetMonitorPosition(monitor);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector2));
}

/**
 * Umka bindings for GetMonitorWidth().
 *
 * @see GetMonitorWidth()
 */
RAYLIB_UMKA_FUNCTION(GetMonitorWidth)
void umkaGetMonitorWidth(UmkaStackSlot *params, UmkaStackSlot *result) {
    int monitor = params[0].intVal;
    result->intVal = GetMonitorWidth(monitor);
}

/**
 * Umka bindings for GetMonitorHeight().
 *
 * @see GetMonitorHeight()
 */
RAYLIB_UMKA_FUNCTION(GetMonitorHeight)
void umkaGetMonitorHeight(UmkaStackSlot *params, UmkaStackSlot *result) {
    int monitor = params[0].intVal;
    result->intVal = GetMonitorHeight(monitor);
}

/**
 * Umka bindings for GetMonitorPhysicalWidth().
 *
 * @see GetMonitorPhysicalWidth()
 */
RAYLIB_UMKA_FUNCTION(GetMonitorPhysicalWidth)
void umkaGetMonitorPhysicalWidth(UmkaStackSlot *params, UmkaStackSlot *result) {
    int monitor = params[0].intVal;
    result->intVal = GetMonitorPhysicalWidth(monitor);
}

/**
 * Umka bindings for GetMonitorPhysicalHeight().
 *
 * @see GetMonitorPhysicalHeight()
 */
RAYLIB_UMKA_FUNCTION(GetMonitorPhysicalHeight)
void umkaGetMonitorPhysicalHeight(UmkaStackSlot *params, UmkaStackSlot *result) {
    int monitor = params[0].intVal;
    result->intVal = GetMonitorPhysicalHeight(monitor);
}

/**
 * Umka bindings for GetMonitorRefreshRate().
 *
 * @see GetMonitorRefreshRate()
 */
RAYLIB_UMKA_FUNCTION(GetMonitorRefreshRate)
void umkaGetMonitorRefreshRate(UmkaStackSlot *params, UmkaStackSlot *result) {
    int monitor = params[0].intVal;
    result->intVal = GetMonitorRefreshRate(monitor);
}

/**
 * Umka bindings for GetWindowPosition().
 *
 * @see GetWindowPosition()
 */
RAYLIB_UMKA_FUNCTION(GetWindowPosition)
void umkaGetWindowPosition(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector2), NULL);
    Vector2 out = GetWindowPosition();
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector2));
}

/**
 * Umka bindings for GetWindowScaleDPI().
 *
 * @see GetWindowScaleDPI()
 */
RAYLIB_UMKA_FUNCTION(GetWindowScaleDPI)
void umkaGetWindowScaleDPI(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector2), NULL);
    Vector2 out = GetWindowScaleDPI();
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector2));
}

/**
 * Umka bindings for GetMonitorName().
 *
 * @see GetMonitorName()
 */
RAYLIB_UMKA_FUNCTION(GetMonitorName)
void umkaGetMonitorName(UmkaStackSlot *params, UmkaStackSlot *result) {
    int monitor = params[0].intVal;
    result->ptrVal = (void*)GetMonitorName(monitor);
}

/**
 * Umka bindings for SetClipboardText().
 *
 * @see SetClipboardText()
 */
RAYLIB_UMKA_FUNCTION(SetClipboardText)
void umkaSetClipboardText(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * text = (const char *)params[0].ptrVal;
    SetClipboardText(text);
}

/**
 * Umka bindings for GetClipboardText().
 *
 * @see GetClipboardText()
 */
RAYLIB_UMKA_FUNCTION(GetClipboardText)
void umkaGetClipboardText(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->ptrVal = (void*)GetClipboardText();
}

/**
 * Umka bindings for EnableEventWaiting().
 *
 * @see EnableEventWaiting()
 */
RAYLIB_UMKA_FUNCTION(EnableEventWaiting)
void umkaEnableEventWaiting(UmkaStackSlot *params, UmkaStackSlot *result) {
    EnableEventWaiting();
}

/**
 * Umka bindings for DisableEventWaiting().
 *
 * @see DisableEventWaiting()
 */
RAYLIB_UMKA_FUNCTION(DisableEventWaiting)
void umkaDisableEventWaiting(UmkaStackSlot *params, UmkaStackSlot *result) {
    DisableEventWaiting();
}

/**
 * Umka bindings for SwapScreenBuffer().
 *
 * @see SwapScreenBuffer()
 */
RAYLIB_UMKA_FUNCTION(SwapScreenBuffer)
void umkaSwapScreenBuffer(UmkaStackSlot *params, UmkaStackSlot *result) {
    SwapScreenBuffer();
}

/**
 * Umka bindings for PollInputEvents().
 *
 * @see PollInputEvents()
 */
RAYLIB_UMKA_FUNCTION(PollInputEvents)
void umkaPollInputEvents(UmkaStackSlot *params, UmkaStackSlot *result) {
    PollInputEvents();
}

/**
 * Umka bindings for WaitTime().
 *
 * @see WaitTime()
 */
RAYLIB_UMKA_FUNCTION(WaitTime)
void umkaWaitTime(UmkaStackSlot *params, UmkaStackSlot *result) {
    double seconds = params[0].realVal;
    WaitTime(seconds);
}

/**
 * Umka bindings for ShowCursor().
 *
 * @see ShowCursor()
 */
RAYLIB_UMKA_FUNCTION(ShowCursor)
void umkaShowCursor(UmkaStackSlot *params, UmkaStackSlot *result) {
    ShowCursor();
}

/**
 * Umka bindings for HideCursor().
 *
 * @see HideCursor()
 */
RAYLIB_UMKA_FUNCTION(HideCursor)
void umkaHideCursor(UmkaStackSlot *params, UmkaStackSlot *result) {
    HideCursor();
}

/**
 * Umka bindings for IsCursorHidden().
 *
 * @see IsCursorHidden()
 */
RAYLIB_UMKA_FUNCTION(IsCursorHidden)
void umkaIsCursorHidden(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->intVal = (int)IsCursorHidden();
}

/**
 * Umka bindings for EnableCursor().
 *
 * @see EnableCursor()
 */
RAYLIB_UMKA_FUNCTION(EnableCursor)
void umkaEnableCursor(UmkaStackSlot *params, UmkaStackSlot *result) {
    EnableCursor();
}

/**
 * Umka bindings for DisableCursor().
 *
 * @see DisableCursor()
 */
RAYLIB_UMKA_FUNCTION(DisableCursor)
void umkaDisableCursor(UmkaStackSlot *params, UmkaStackSlot *result) {
    DisableCursor();
}

/**
 * Umka bindings for IsCursorOnScreen().
 *
 * @see IsCursorOnScreen()
 */
RAYLIB_UMKA_FUNCTION(IsCursorOnScreen)
void umkaIsCursorOnScreen(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->intVal = (int)IsCursorOnScreen();
}

/**
 * Umka bindings for ClearBackground().
 *
 * @see ClearBackground()
 */
RAYLIB_UMKA_FUNCTION(ClearBackground)
void umkaClearBackground(UmkaStackSlot *params, UmkaStackSlot *result) {
    Color* color = (Color*)&params[0];
    ClearBackground(*color);
}

/**
 * Umka bindings for BeginDrawing().
 *
 * @see BeginDrawing()
 */
RAYLIB_UMKA_FUNCTION(BeginDrawing)
void umkaBeginDrawing(UmkaStackSlot *params, UmkaStackSlot *result) {
    BeginDrawing();
}

/**
 * Umka bindings for EndDrawing().
 *
 * @see EndDrawing()
 */
RAYLIB_UMKA_FUNCTION(EndDrawing)
void umkaEndDrawing(UmkaStackSlot *params, UmkaStackSlot *result) {
    EndDrawing();
}

/**
 * Umka bindings for BeginMode2D().
 *
 * @see BeginMode2D()
 */
RAYLIB_UMKA_FUNCTION(BeginMode2D)
void umkaBeginMode2D(UmkaStackSlot *params, UmkaStackSlot *result) {
    Camera2D* camera = (Camera2D*)&params[0];
    BeginMode2D(*camera);
}

/**
 * Umka bindings for EndMode2D().
 *
 * @see EndMode2D()
 */
RAYLIB_UMKA_FUNCTION(EndMode2D)
void umkaEndMode2D(UmkaStackSlot *params, UmkaStackSlot *result) {
    EndMode2D();
}

/**
 * Umka bindings for BeginMode3D().
 *
 * @see BeginMode3D()
 */
RAYLIB_UMKA_FUNCTION(BeginMode3D)
void umkaBeginMode3D(UmkaStackSlot *params, UmkaStackSlot *result) {
    Camera3D* camera = (Camera3D*)&params[0];
    BeginMode3D(*camera);
}

/**
 * Umka bindings for EndMode3D().
 *
 * @see EndMode3D()
 */
RAYLIB_UMKA_FUNCTION(EndMode3D)
void umkaEndMode3D(UmkaStackSlot *params, UmkaStackSlot *result) {
    EndMode3D();
}

/**
 * Umka bindings for BeginTextureMode().
 *
 * @see BeginTextureMode()
 */
RAYLIB_UMKA_FUNCTION(BeginTextureMode)
void umkaBeginTextureMode(UmkaStackSlot *params, UmkaStackSlot *result) {
    RenderTexture2D* target = (RenderTexture2D*)&params[0];
    BeginTextureMode(*target);
}

/**
 * Umka bindings for EndTextureMode().
 *
 * @see EndTextureMode()
 */
RAYLIB_UMKA_FUNCTION(EndTextureMode)
void umkaEndTextureMode(UmkaStackSlot *params, UmkaStackSlot *result) {
    EndTextureMode();
}

/**
 * Umka bindings for BeginShaderMode().
 *
 * @see BeginShaderMode()
 */
RAYLIB_UMKA_FUNCTION(BeginShaderMode)
void umkaBeginShaderMode(UmkaStackSlot *params, UmkaStackSlot *result) {
    Shader* shader = (Shader*)&params[0];
    BeginShaderMode(*shader);
}

/**
 * Umka bindings for EndShaderMode().
 *
 * @see EndShaderMode()
 */
RAYLIB_UMKA_FUNCTION(EndShaderMode)
void umkaEndShaderMode(UmkaStackSlot *params, UmkaStackSlot *result) {
    EndShaderMode();
}

/**
 * Umka bindings for BeginBlendMode().
 *
 * @see BeginBlendMode()
 */
RAYLIB_UMKA_FUNCTION(BeginBlendMode)
void umkaBeginBlendMode(UmkaStackSlot *params, UmkaStackSlot *result) {
    int mode = params[0].intVal;
    BeginBlendMode(mode);
}

/**
 * Umka bindings for EndBlendMode().
 *
 * @see EndBlendMode()
 */
RAYLIB_UMKA_FUNCTION(EndBlendMode)
void umkaEndBlendMode(UmkaStackSlot *params, UmkaStackSlot *result) {
    EndBlendMode();
}

/**
 * Umka bindings for BeginScissorMode().
 *
 * @see BeginScissorMode()
 */
RAYLIB_UMKA_FUNCTION(BeginScissorMode)
void umkaBeginScissorMode(UmkaStackSlot *params, UmkaStackSlot *result) {
    int x = params[3].intVal;
    int y = params[2].intVal;
    int width = params[1].intVal;
    int height = params[0].intVal;
    BeginScissorMode(x, y, width, height);
}

/**
 * Umka bindings for EndScissorMode().
 *
 * @see EndScissorMode()
 */
RAYLIB_UMKA_FUNCTION(EndScissorMode)
void umkaEndScissorMode(UmkaStackSlot *params, UmkaStackSlot *result) {
    EndScissorMode();
}

/**
 * Umka bindings for BeginVrStereoMode().
 *
 * @see BeginVrStereoMode()
 */
RAYLIB_UMKA_FUNCTION(BeginVrStereoMode)
void umkaBeginVrStereoMode(UmkaStackSlot *params, UmkaStackSlot *result) {
    VrStereoConfig* config = (VrStereoConfig*)&params[0];
    BeginVrStereoMode(*config);
}

/**
 * Umka bindings for EndVrStereoMode().
 *
 * @see EndVrStereoMode()
 */
RAYLIB_UMKA_FUNCTION(EndVrStereoMode)
void umkaEndVrStereoMode(UmkaStackSlot *params, UmkaStackSlot *result) {
    EndVrStereoMode();
}

/**
 * Umka bindings for LoadVrStereoConfig().
 *
 * @see LoadVrStereoConfig()
 */
RAYLIB_UMKA_FUNCTION(LoadVrStereoConfig)
void umkaLoadVrStereoConfig(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    VrDeviceInfo* device = (VrDeviceInfo*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(VrStereoConfig), NULL);
    VrStereoConfig out = LoadVrStereoConfig(*device);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(VrStereoConfig));
}

/**
 * Umka bindings for UnloadVrStereoConfig().
 *
 * @see UnloadVrStereoConfig()
 */
RAYLIB_UMKA_FUNCTION(UnloadVrStereoConfig)
void umkaUnloadVrStereoConfig(UmkaStackSlot *params, UmkaStackSlot *result) {
    VrStereoConfig* config = (VrStereoConfig*)&params[0];
    UnloadVrStereoConfig(*config);
}

/**
 * Umka bindings for LoadShader().
 *
 * @see LoadShader()
 */
RAYLIB_UMKA_FUNCTION(LoadShader)
void umkaLoadShader(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    const char * vsFileName = (const char *)params[2].ptrVal;
    const char * fsFileName = (const char *)params[1].ptrVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Shader), NULL);
    Shader out = LoadShader(vsFileName, fsFileName);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Shader));
}

/**
 * Umka bindings for LoadShaderFromMemory().
 *
 * @see LoadShaderFromMemory()
 */
RAYLIB_UMKA_FUNCTION(LoadShaderFromMemory)
void umkaLoadShaderFromMemory(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    const char * vsCode = (const char *)params[2].ptrVal;
    const char * fsCode = (const char *)params[1].ptrVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Shader), NULL);
    Shader out = LoadShaderFromMemory(vsCode, fsCode);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Shader));
}

/**
 * Umka bindings for GetShaderLocation().
 *
 * @see GetShaderLocation()
 */
RAYLIB_UMKA_FUNCTION(GetShaderLocation)
void umkaGetShaderLocation(UmkaStackSlot *params, UmkaStackSlot *result) {
    Shader* shader = (Shader*)&params[1];
    const char * uniformName = (const char *)params[0].ptrVal;
    result->intVal = GetShaderLocation(*shader, uniformName);
}

/**
 * Umka bindings for GetShaderLocationAttrib().
 *
 * @see GetShaderLocationAttrib()
 */
RAYLIB_UMKA_FUNCTION(GetShaderLocationAttrib)
void umkaGetShaderLocationAttrib(UmkaStackSlot *params, UmkaStackSlot *result) {
    Shader* shader = (Shader*)&params[1];
    const char * attribName = (const char *)params[0].ptrVal;
    result->intVal = GetShaderLocationAttrib(*shader, attribName);
}

/**
 * Umka bindings for SetShaderValue().
 *
 * @see SetShaderValue()
 */
RAYLIB_UMKA_FUNCTION(SetShaderValue)
void umkaSetShaderValue(UmkaStackSlot *params, UmkaStackSlot *result) {
    Shader* shader = (Shader*)&params[3];
    int locIndex = params[2].intVal;
    const void * value = (const void *)params[1].ptrVal;
    int uniformType = params[0].intVal;
    SetShaderValue(*shader, locIndex, value, uniformType);
}

/**
 * Umka bindings for SetShaderValueV().
 *
 * @see SetShaderValueV()
 */
RAYLIB_UMKA_FUNCTION(SetShaderValueV)
void umkaSetShaderValueV(UmkaStackSlot *params, UmkaStackSlot *result) {
    Shader* shader = (Shader*)&params[4];
    int locIndex = params[3].intVal;
    const void * value = (const void *)params[2].ptrVal;
    int uniformType = params[1].intVal;
    int count = params[0].intVal;
    SetShaderValueV(*shader, locIndex, value, uniformType, count);
}

/**
 * Umka bindings for SetShaderValueMatrix().
 *
 * @see SetShaderValueMatrix()
 */
RAYLIB_UMKA_FUNCTION(SetShaderValueMatrix)
void umkaSetShaderValueMatrix(UmkaStackSlot *params, UmkaStackSlot *result) {
    Shader* shader = (Shader*)&params[2];
    int locIndex = params[1].intVal;
    Matrix* mat = (Matrix*)&params[0];
    SetShaderValueMatrix(*shader, locIndex, *mat);
}

/**
 * Umka bindings for SetShaderValueTexture().
 *
 * @see SetShaderValueTexture()
 */
RAYLIB_UMKA_FUNCTION(SetShaderValueTexture)
void umkaSetShaderValueTexture(UmkaStackSlot *params, UmkaStackSlot *result) {
    Shader* shader = (Shader*)&params[2];
    int locIndex = params[1].intVal;
    Texture2D* texture = (Texture2D*)&params[0];
    SetShaderValueTexture(*shader, locIndex, *texture);
}

/**
 * Umka bindings for UnloadShader().
 *
 * @see UnloadShader()
 */
RAYLIB_UMKA_FUNCTION(UnloadShader)
void umkaUnloadShader(UmkaStackSlot *params, UmkaStackSlot *result) {
    Shader* shader = (Shader*)&params[0];
    UnloadShader(*shader);
}

/**
 * Umka bindings for GetMouseRay().
 *
 * @see GetMouseRay()
 */
RAYLIB_UMKA_FUNCTION(GetMouseRay)
void umkaGetMouseRay(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector2* mousePosition = (Vector2*)&params[2];
    Camera* camera = (Camera*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Ray), NULL);
    Ray out = GetMouseRay(*mousePosition, *camera);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Ray));
}

/**
 * Umka bindings for GetCameraMatrix().
 *
 * @see GetCameraMatrix()
 */
RAYLIB_UMKA_FUNCTION(GetCameraMatrix)
void umkaGetCameraMatrix(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Camera* camera = (Camera*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Matrix), NULL);
    Matrix out = GetCameraMatrix(*camera);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Matrix));
}

/**
 * Umka bindings for GetCameraMatrix2D().
 *
 * @see GetCameraMatrix2D()
 */
RAYLIB_UMKA_FUNCTION(GetCameraMatrix2D)
void umkaGetCameraMatrix2D(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Camera2D* camera = (Camera2D*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Matrix), NULL);
    Matrix out = GetCameraMatrix2D(*camera);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Matrix));
}

/**
 * Umka bindings for GetWorldToScreen().
 *
 * @see GetWorldToScreen()
 */
RAYLIB_UMKA_FUNCTION(GetWorldToScreen)
void umkaGetWorldToScreen(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector3* position = (Vector3*)&params[2];
    Camera* camera = (Camera*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector2), NULL);
    Vector2 out = GetWorldToScreen(*position, *camera);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector2));
}

/**
 * Umka bindings for GetScreenToWorld2D().
 *
 * @see GetScreenToWorld2D()
 */
RAYLIB_UMKA_FUNCTION(GetScreenToWorld2D)
void umkaGetScreenToWorld2D(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector2* position = (Vector2*)&params[2];
    Camera2D* camera = (Camera2D*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector2), NULL);
    Vector2 out = GetScreenToWorld2D(*position, *camera);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector2));
}

/**
 * Umka bindings for GetWorldToScreenEx().
 *
 * @see GetWorldToScreenEx()
 */
RAYLIB_UMKA_FUNCTION(GetWorldToScreenEx)
void umkaGetWorldToScreenEx(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector3* position = (Vector3*)&params[4];
    Camera* camera = (Camera*)&params[3];
    int width = params[2].intVal;
    int height = params[1].intVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector2), NULL);
    Vector2 out = GetWorldToScreenEx(*position, *camera, width, height);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector2));
}

/**
 * Umka bindings for GetWorldToScreen2D().
 *
 * @see GetWorldToScreen2D()
 */
RAYLIB_UMKA_FUNCTION(GetWorldToScreen2D)
void umkaGetWorldToScreen2D(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector2* position = (Vector2*)&params[2];
    Camera2D* camera = (Camera2D*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector2), NULL);
    Vector2 out = GetWorldToScreen2D(*position, *camera);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector2));
}

/**
 * Umka bindings for SetTargetFPS().
 *
 * @see SetTargetFPS()
 */
RAYLIB_UMKA_FUNCTION(SetTargetFPS)
void umkaSetTargetFPS(UmkaStackSlot *params, UmkaStackSlot *result) {
    int fps = params[0].intVal;
    SetTargetFPS(fps);
}

/**
 * Umka bindings for GetFPS().
 *
 * @see GetFPS()
 */
RAYLIB_UMKA_FUNCTION(GetFPS)
void umkaGetFPS(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->intVal = GetFPS();
}

/**
 * Umka bindings for GetFrameTime().
 *
 * @see GetFrameTime()
 */
RAYLIB_UMKA_FUNCTION(GetFrameTime)
void umkaGetFrameTime(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->realVal = GetFrameTime();
}

/**
 * Umka bindings for GetTime().
 *
 * @see GetTime()
 */
RAYLIB_UMKA_FUNCTION(GetTime)
void umkaGetTime(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->realVal = GetTime();
}

/**
 * Umka bindings for GetRandomValue().
 *
 * @see GetRandomValue()
 */
RAYLIB_UMKA_FUNCTION(GetRandomValue)
void umkaGetRandomValue(UmkaStackSlot *params, UmkaStackSlot *result) {
    int min = params[1].intVal;
    int max = params[0].intVal;
    result->intVal = GetRandomValue(min, max);
}

/**
 * Umka bindings for SetRandomSeed().
 *
 * @see SetRandomSeed()
 */
RAYLIB_UMKA_FUNCTION(SetRandomSeed)
void umkaSetRandomSeed(UmkaStackSlot *params, UmkaStackSlot *result) {
    unsigned int seed = params[0].uintVal;
    SetRandomSeed(seed);
}

/**
 * Umka bindings for TakeScreenshot().
 *
 * @see TakeScreenshot()
 */
RAYLIB_UMKA_FUNCTION(TakeScreenshot)
void umkaTakeScreenshot(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * fileName = (const char *)params[0].ptrVal;
    TakeScreenshot(fileName);
}

/**
 * Umka bindings for SetConfigFlags().
 *
 * @see SetConfigFlags()
 */
RAYLIB_UMKA_FUNCTION(SetConfigFlags)
void umkaSetConfigFlags(UmkaStackSlot *params, UmkaStackSlot *result) {
    unsigned int flags = params[0].uintVal;
    SetConfigFlags(flags);
}

// Function TraceLog() skipped

/**
 * Umka bindings for SetTraceLogLevel().
 *
 * @see SetTraceLogLevel()
 */
RAYLIB_UMKA_FUNCTION(SetTraceLogLevel)
void umkaSetTraceLogLevel(UmkaStackSlot *params, UmkaStackSlot *result) {
    int logLevel = params[0].intVal;
    SetTraceLogLevel(logLevel);
}

/**
 * Umka bindings for MemAlloc().
 *
 * @see MemAlloc()
 */
RAYLIB_UMKA_FUNCTION(MemAlloc)
void umkaMemAlloc(UmkaStackSlot *params, UmkaStackSlot *result) {
    int size = params[0].intVal;
    result->ptrVal = (void*)MemAlloc(size);
}

/**
 * Umka bindings for MemRealloc().
 *
 * @see MemRealloc()
 */
RAYLIB_UMKA_FUNCTION(MemRealloc)
void umkaMemRealloc(UmkaStackSlot *params, UmkaStackSlot *result) {
    void * ptr = (void *)params[1].ptrVal;
    int size = params[0].intVal;
    result->ptrVal = (void*)MemRealloc(ptr, size);
}

/**
 * Umka bindings for MemFree().
 *
 * @see MemFree()
 */
RAYLIB_UMKA_FUNCTION(MemFree)
void umkaMemFree(UmkaStackSlot *params, UmkaStackSlot *result) {
    void * ptr = (void *)params[0].ptrVal;
    MemFree(ptr);
}

/**
 * Umka bindings for OpenURL().
 *
 * @see OpenURL()
 */
RAYLIB_UMKA_FUNCTION(OpenURL)
void umkaOpenURL(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * url = (const char *)params[0].ptrVal;
    OpenURL(url);
}

// Function SetTraceLogCallback() skipped

// Function SetLoadFileDataCallback() skipped

// Function SetSaveFileDataCallback() skipped

// Function SetLoadFileTextCallback() skipped

// Function SetSaveFileTextCallback() skipped

/**
 * Umka bindings for LoadFileData().
 *
 * @see LoadFileData()
 */
RAYLIB_UMKA_FUNCTION(LoadFileData)
void umkaLoadFileData(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * fileName = (const char *)params[1].ptrVal;
    unsigned int * bytesRead = (unsigned int *)params[0].ptrVal;
    result->ptrVal = (void*)LoadFileData(fileName, bytesRead);
}

/**
 * Umka bindings for UnloadFileData().
 *
 * @see UnloadFileData()
 */
RAYLIB_UMKA_FUNCTION(UnloadFileData)
void umkaUnloadFileData(UmkaStackSlot *params, UmkaStackSlot *result) {
    unsigned char * data = (unsigned char *)params[0].ptrVal;
    UnloadFileData(data);
}

/**
 * Umka bindings for SaveFileData().
 *
 * @see SaveFileData()
 */
RAYLIB_UMKA_FUNCTION(SaveFileData)
void umkaSaveFileData(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * fileName = (const char *)params[2].ptrVal;
    void * data = (void *)params[1].ptrVal;
    unsigned int bytesToWrite = params[0].uintVal;
    result->intVal = (int)SaveFileData(fileName, data, bytesToWrite);
}

/**
 * Umka bindings for ExportDataAsCode().
 *
 * @see ExportDataAsCode()
 */
RAYLIB_UMKA_FUNCTION(ExportDataAsCode)
void umkaExportDataAsCode(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * data = (const char *)params[2].ptrVal;
    unsigned int size = params[1].uintVal;
    const char * fileName = (const char *)params[0].ptrVal;
    result->intVal = (int)ExportDataAsCode(data, size, fileName);
}

/**
 * Umka bindings for LoadFileText().
 *
 * @see LoadFileText()
 */
RAYLIB_UMKA_FUNCTION(LoadFileText)
void umkaLoadFileText(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * fileName = (const char *)params[0].ptrVal;
    result->ptrVal = (void*)LoadFileText(fileName);
}

/**
 * Umka bindings for UnloadFileText().
 *
 * @see UnloadFileText()
 */
RAYLIB_UMKA_FUNCTION(UnloadFileText)
void umkaUnloadFileText(UmkaStackSlot *params, UmkaStackSlot *result) {
    char * text = (char *)params[0].ptrVal;
    UnloadFileText(text);
}

/**
 * Umka bindings for SaveFileText().
 *
 * @see SaveFileText()
 */
RAYLIB_UMKA_FUNCTION(SaveFileText)
void umkaSaveFileText(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * fileName = (const char *)params[1].ptrVal;
    char * text = (char *)params[0].ptrVal;
    result->intVal = (int)SaveFileText(fileName, text);
}

/**
 * Umka bindings for FileExists().
 *
 * @see FileExists()
 */
RAYLIB_UMKA_FUNCTION(FileExists)
void umkaFileExists(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * fileName = (const char *)params[0].ptrVal;
    result->intVal = (int)FileExists(fileName);
}

/**
 * Umka bindings for DirectoryExists().
 *
 * @see DirectoryExists()
 */
RAYLIB_UMKA_FUNCTION(DirectoryExists)
void umkaDirectoryExists(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * dirPath = (const char *)params[0].ptrVal;
    result->intVal = (int)DirectoryExists(dirPath);
}

/**
 * Umka bindings for IsFileExtension().
 *
 * @see IsFileExtension()
 */
RAYLIB_UMKA_FUNCTION(IsFileExtension)
void umkaIsFileExtension(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * fileName = (const char *)params[1].ptrVal;
    const char * ext = (const char *)params[0].ptrVal;
    result->intVal = (int)IsFileExtension(fileName, ext);
}

/**
 * Umka bindings for GetFileLength().
 *
 * @see GetFileLength()
 */
RAYLIB_UMKA_FUNCTION(GetFileLength)
void umkaGetFileLength(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * fileName = (const char *)params[0].ptrVal;
    result->intVal = GetFileLength(fileName);
}

/**
 * Umka bindings for GetFileExtension().
 *
 * @see GetFileExtension()
 */
RAYLIB_UMKA_FUNCTION(GetFileExtension)
void umkaGetFileExtension(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * fileName = (const char *)params[0].ptrVal;
    result->ptrVal = (void*)GetFileExtension(fileName);
}

/**
 * Umka bindings for GetFileName().
 *
 * @see GetFileName()
 */
RAYLIB_UMKA_FUNCTION(GetFileName)
void umkaGetFileName(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * filePath = (const char *)params[0].ptrVal;
    result->ptrVal = (void*)GetFileName(filePath);
}

/**
 * Umka bindings for GetFileNameWithoutExt().
 *
 * @see GetFileNameWithoutExt()
 */
RAYLIB_UMKA_FUNCTION(GetFileNameWithoutExt)
void umkaGetFileNameWithoutExt(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * filePath = (const char *)params[0].ptrVal;
    result->ptrVal = (void*)GetFileNameWithoutExt(filePath);
}

/**
 * Umka bindings for GetDirectoryPath().
 *
 * @see GetDirectoryPath()
 */
RAYLIB_UMKA_FUNCTION(GetDirectoryPath)
void umkaGetDirectoryPath(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * filePath = (const char *)params[0].ptrVal;
    result->ptrVal = (void*)GetDirectoryPath(filePath);
}

/**
 * Umka bindings for GetPrevDirectoryPath().
 *
 * @see GetPrevDirectoryPath()
 */
RAYLIB_UMKA_FUNCTION(GetPrevDirectoryPath)
void umkaGetPrevDirectoryPath(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * dirPath = (const char *)params[0].ptrVal;
    result->ptrVal = (void*)GetPrevDirectoryPath(dirPath);
}

/**
 * Umka bindings for GetWorkingDirectory().
 *
 * @see GetWorkingDirectory()
 */
RAYLIB_UMKA_FUNCTION(GetWorkingDirectory)
void umkaGetWorkingDirectory(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->ptrVal = (void*)GetWorkingDirectory();
}

/**
 * Umka bindings for GetApplicationDirectory().
 *
 * @see GetApplicationDirectory()
 */
RAYLIB_UMKA_FUNCTION(GetApplicationDirectory)
void umkaGetApplicationDirectory(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->ptrVal = (void*)GetApplicationDirectory();
}

/**
 * Umka bindings for ChangeDirectory().
 *
 * @see ChangeDirectory()
 */
RAYLIB_UMKA_FUNCTION(ChangeDirectory)
void umkaChangeDirectory(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * dir = (const char *)params[0].ptrVal;
    result->intVal = (int)ChangeDirectory(dir);
}

/**
 * Umka bindings for IsPathFile().
 *
 * @see IsPathFile()
 */
RAYLIB_UMKA_FUNCTION(IsPathFile)
void umkaIsPathFile(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * path = (const char *)params[0].ptrVal;
    result->intVal = (int)IsPathFile(path);
}

/**
 * Umka bindings for LoadDirectoryFiles().
 *
 * @see LoadDirectoryFiles()
 */
RAYLIB_UMKA_FUNCTION(LoadDirectoryFiles)
void umkaLoadDirectoryFiles(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    const char * dirPath = (const char *)params[1].ptrVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(FilePathList), NULL);
    FilePathList out = LoadDirectoryFiles(dirPath);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(FilePathList));
}

/**
 * Umka bindings for LoadDirectoryFilesEx().
 *
 * @see LoadDirectoryFilesEx()
 */
RAYLIB_UMKA_FUNCTION(LoadDirectoryFilesEx)
void umkaLoadDirectoryFilesEx(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    const char * basePath = (const char *)params[3].ptrVal;
    const char * filter = (const char *)params[2].ptrVal;
    bool scanSubdirs = (bool)params[1].intVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(FilePathList), NULL);
    FilePathList out = LoadDirectoryFilesEx(basePath, filter, scanSubdirs);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(FilePathList));
}

/**
 * Umka bindings for UnloadDirectoryFiles().
 *
 * @see UnloadDirectoryFiles()
 */
RAYLIB_UMKA_FUNCTION(UnloadDirectoryFiles)
void umkaUnloadDirectoryFiles(UmkaStackSlot *params, UmkaStackSlot *result) {
    FilePathList* files = (FilePathList*)&params[0];
    UnloadDirectoryFiles(*files);
}

/**
 * Umka bindings for IsFileDropped().
 *
 * @see IsFileDropped()
 */
RAYLIB_UMKA_FUNCTION(IsFileDropped)
void umkaIsFileDropped(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->intVal = (int)IsFileDropped();
}

/**
 * Umka bindings for LoadDroppedFiles().
 *
 * @see LoadDroppedFiles()
 */
RAYLIB_UMKA_FUNCTION(LoadDroppedFiles)
void umkaLoadDroppedFiles(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(FilePathList), NULL);
    FilePathList out = LoadDroppedFiles();
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(FilePathList));
}

/**
 * Umka bindings for UnloadDroppedFiles().
 *
 * @see UnloadDroppedFiles()
 */
RAYLIB_UMKA_FUNCTION(UnloadDroppedFiles)
void umkaUnloadDroppedFiles(UmkaStackSlot *params, UmkaStackSlot *result) {
    FilePathList* files = (FilePathList*)&params[0];
    UnloadDroppedFiles(*files);
}

/**
 * Umka bindings for GetFileModTime().
 *
 * @see GetFileModTime()
 */
RAYLIB_UMKA_FUNCTION(GetFileModTime)
void umkaGetFileModTime(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * fileName = (const char *)params[0].ptrVal;
    result->intVal = GetFileModTime(fileName);
}

/**
 * Umka bindings for CompressData().
 *
 * @see CompressData()
 */
RAYLIB_UMKA_FUNCTION(CompressData)
void umkaCompressData(UmkaStackSlot *params, UmkaStackSlot *result) {
    const unsigned char * data = (const unsigned char *)params[2].ptrVal;
    int dataSize = params[1].intVal;
    int * compDataSize = (int *)params[0].ptrVal;
    result->ptrVal = (void*)CompressData(data, dataSize, compDataSize);
}

/**
 * Umka bindings for DecompressData().
 *
 * @see DecompressData()
 */
RAYLIB_UMKA_FUNCTION(DecompressData)
void umkaDecompressData(UmkaStackSlot *params, UmkaStackSlot *result) {
    const unsigned char * compData = (const unsigned char *)params[2].ptrVal;
    int compDataSize = params[1].intVal;
    int * dataSize = (int *)params[0].ptrVal;
    result->ptrVal = (void*)DecompressData(compData, compDataSize, dataSize);
}

/**
 * Umka bindings for EncodeDataBase64().
 *
 * @see EncodeDataBase64()
 */
RAYLIB_UMKA_FUNCTION(EncodeDataBase64)
void umkaEncodeDataBase64(UmkaStackSlot *params, UmkaStackSlot *result) {
    const unsigned char * data = (const unsigned char *)params[2].ptrVal;
    int dataSize = params[1].intVal;
    int * outputSize = (int *)params[0].ptrVal;
    result->ptrVal = (void*)EncodeDataBase64(data, dataSize, outputSize);
}

/**
 * Umka bindings for DecodeDataBase64().
 *
 * @see DecodeDataBase64()
 */
RAYLIB_UMKA_FUNCTION(DecodeDataBase64)
void umkaDecodeDataBase64(UmkaStackSlot *params, UmkaStackSlot *result) {
    const unsigned char * data = (const unsigned char *)params[1].ptrVal;
    int * outputSize = (int *)params[0].ptrVal;
    result->ptrVal = (void*)DecodeDataBase64(data, outputSize);
}

/**
 * Umka bindings for IsKeyPressed().
 *
 * @see IsKeyPressed()
 */
RAYLIB_UMKA_FUNCTION(IsKeyPressed)
void umkaIsKeyPressed(UmkaStackSlot *params, UmkaStackSlot *result) {
    int key = params[0].intVal;
    result->intVal = (int)IsKeyPressed(key);
}

/**
 * Umka bindings for IsKeyDown().
 *
 * @see IsKeyDown()
 */
RAYLIB_UMKA_FUNCTION(IsKeyDown)
void umkaIsKeyDown(UmkaStackSlot *params, UmkaStackSlot *result) {
    int key = params[0].intVal;
    result->intVal = (int)IsKeyDown(key);
}

/**
 * Umka bindings for IsKeyReleased().
 *
 * @see IsKeyReleased()
 */
RAYLIB_UMKA_FUNCTION(IsKeyReleased)
void umkaIsKeyReleased(UmkaStackSlot *params, UmkaStackSlot *result) {
    int key = params[0].intVal;
    result->intVal = (int)IsKeyReleased(key);
}

/**
 * Umka bindings for IsKeyUp().
 *
 * @see IsKeyUp()
 */
RAYLIB_UMKA_FUNCTION(IsKeyUp)
void umkaIsKeyUp(UmkaStackSlot *params, UmkaStackSlot *result) {
    int key = params[0].intVal;
    result->intVal = (int)IsKeyUp(key);
}

/**
 * Umka bindings for SetExitKey().
 *
 * @see SetExitKey()
 */
RAYLIB_UMKA_FUNCTION(SetExitKey)
void umkaSetExitKey(UmkaStackSlot *params, UmkaStackSlot *result) {
    int key = params[0].intVal;
    SetExitKey(key);
}

/**
 * Umka bindings for GetKeyPressed().
 *
 * @see GetKeyPressed()
 */
RAYLIB_UMKA_FUNCTION(GetKeyPressed)
void umkaGetKeyPressed(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->intVal = GetKeyPressed();
}

/**
 * Umka bindings for GetCharPressed().
 *
 * @see GetCharPressed()
 */
RAYLIB_UMKA_FUNCTION(GetCharPressed)
void umkaGetCharPressed(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->intVal = GetCharPressed();
}

/**
 * Umka bindings for IsGamepadAvailable().
 *
 * @see IsGamepadAvailable()
 */
RAYLIB_UMKA_FUNCTION(IsGamepadAvailable)
void umkaIsGamepadAvailable(UmkaStackSlot *params, UmkaStackSlot *result) {
    int gamepad = params[0].intVal;
    result->intVal = (int)IsGamepadAvailable(gamepad);
}

/**
 * Umka bindings for GetGamepadName().
 *
 * @see GetGamepadName()
 */
RAYLIB_UMKA_FUNCTION(GetGamepadName)
void umkaGetGamepadName(UmkaStackSlot *params, UmkaStackSlot *result) {
    int gamepad = params[0].intVal;
    result->ptrVal = (void*)GetGamepadName(gamepad);
}

/**
 * Umka bindings for IsGamepadButtonPressed().
 *
 * @see IsGamepadButtonPressed()
 */
RAYLIB_UMKA_FUNCTION(IsGamepadButtonPressed)
void umkaIsGamepadButtonPressed(UmkaStackSlot *params, UmkaStackSlot *result) {
    int gamepad = params[1].intVal;
    int button = params[0].intVal;
    result->intVal = (int)IsGamepadButtonPressed(gamepad, button);
}

/**
 * Umka bindings for IsGamepadButtonDown().
 *
 * @see IsGamepadButtonDown()
 */
RAYLIB_UMKA_FUNCTION(IsGamepadButtonDown)
void umkaIsGamepadButtonDown(UmkaStackSlot *params, UmkaStackSlot *result) {
    int gamepad = params[1].intVal;
    int button = params[0].intVal;
    result->intVal = (int)IsGamepadButtonDown(gamepad, button);
}

/**
 * Umka bindings for IsGamepadButtonReleased().
 *
 * @see IsGamepadButtonReleased()
 */
RAYLIB_UMKA_FUNCTION(IsGamepadButtonReleased)
void umkaIsGamepadButtonReleased(UmkaStackSlot *params, UmkaStackSlot *result) {
    int gamepad = params[1].intVal;
    int button = params[0].intVal;
    result->intVal = (int)IsGamepadButtonReleased(gamepad, button);
}

/**
 * Umka bindings for IsGamepadButtonUp().
 *
 * @see IsGamepadButtonUp()
 */
RAYLIB_UMKA_FUNCTION(IsGamepadButtonUp)
void umkaIsGamepadButtonUp(UmkaStackSlot *params, UmkaStackSlot *result) {
    int gamepad = params[1].intVal;
    int button = params[0].intVal;
    result->intVal = (int)IsGamepadButtonUp(gamepad, button);
}

/**
 * Umka bindings for GetGamepadButtonPressed().
 *
 * @see GetGamepadButtonPressed()
 */
RAYLIB_UMKA_FUNCTION(GetGamepadButtonPressed)
void umkaGetGamepadButtonPressed(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->intVal = GetGamepadButtonPressed();
}

/**
 * Umka bindings for GetGamepadAxisCount().
 *
 * @see GetGamepadAxisCount()
 */
RAYLIB_UMKA_FUNCTION(GetGamepadAxisCount)
void umkaGetGamepadAxisCount(UmkaStackSlot *params, UmkaStackSlot *result) {
    int gamepad = params[0].intVal;
    result->intVal = GetGamepadAxisCount(gamepad);
}

/**
 * Umka bindings for GetGamepadAxisMovement().
 *
 * @see GetGamepadAxisMovement()
 */
RAYLIB_UMKA_FUNCTION(GetGamepadAxisMovement)
void umkaGetGamepadAxisMovement(UmkaStackSlot *params, UmkaStackSlot *result) {
    int gamepad = params[1].intVal;
    int axis = params[0].intVal;
    result->realVal = GetGamepadAxisMovement(gamepad, axis);
}

/**
 * Umka bindings for SetGamepadMappings().
 *
 * @see SetGamepadMappings()
 */
RAYLIB_UMKA_FUNCTION(SetGamepadMappings)
void umkaSetGamepadMappings(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * mappings = (const char *)params[0].ptrVal;
    result->intVal = SetGamepadMappings(mappings);
}

/**
 * Umka bindings for IsMouseButtonPressed().
 *
 * @see IsMouseButtonPressed()
 */
RAYLIB_UMKA_FUNCTION(IsMouseButtonPressed)
void umkaIsMouseButtonPressed(UmkaStackSlot *params, UmkaStackSlot *result) {
    int button = params[0].intVal;
    result->intVal = (int)IsMouseButtonPressed(button);
}

/**
 * Umka bindings for IsMouseButtonDown().
 *
 * @see IsMouseButtonDown()
 */
RAYLIB_UMKA_FUNCTION(IsMouseButtonDown)
void umkaIsMouseButtonDown(UmkaStackSlot *params, UmkaStackSlot *result) {
    int button = params[0].intVal;
    result->intVal = (int)IsMouseButtonDown(button);
}

/**
 * Umka bindings for IsMouseButtonReleased().
 *
 * @see IsMouseButtonReleased()
 */
RAYLIB_UMKA_FUNCTION(IsMouseButtonReleased)
void umkaIsMouseButtonReleased(UmkaStackSlot *params, UmkaStackSlot *result) {
    int button = params[0].intVal;
    result->intVal = (int)IsMouseButtonReleased(button);
}

/**
 * Umka bindings for IsMouseButtonUp().
 *
 * @see IsMouseButtonUp()
 */
RAYLIB_UMKA_FUNCTION(IsMouseButtonUp)
void umkaIsMouseButtonUp(UmkaStackSlot *params, UmkaStackSlot *result) {
    int button = params[0].intVal;
    result->intVal = (int)IsMouseButtonUp(button);
}

/**
 * Umka bindings for GetMouseX().
 *
 * @see GetMouseX()
 */
RAYLIB_UMKA_FUNCTION(GetMouseX)
void umkaGetMouseX(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->intVal = GetMouseX();
}

/**
 * Umka bindings for GetMouseY().
 *
 * @see GetMouseY()
 */
RAYLIB_UMKA_FUNCTION(GetMouseY)
void umkaGetMouseY(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->intVal = GetMouseY();
}

/**
 * Umka bindings for GetMousePosition().
 *
 * @see GetMousePosition()
 */
RAYLIB_UMKA_FUNCTION(GetMousePosition)
void umkaGetMousePosition(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector2), NULL);
    Vector2 out = GetMousePosition();
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector2));
}

/**
 * Umka bindings for GetMouseDelta().
 *
 * @see GetMouseDelta()
 */
RAYLIB_UMKA_FUNCTION(GetMouseDelta)
void umkaGetMouseDelta(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector2), NULL);
    Vector2 out = GetMouseDelta();
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector2));
}

/**
 * Umka bindings for SetMousePosition().
 *
 * @see SetMousePosition()
 */
RAYLIB_UMKA_FUNCTION(SetMousePosition)
void umkaSetMousePosition(UmkaStackSlot *params, UmkaStackSlot *result) {
    int x = params[1].intVal;
    int y = params[0].intVal;
    SetMousePosition(x, y);
}

/**
 * Umka bindings for SetMouseOffset().
 *
 * @see SetMouseOffset()
 */
RAYLIB_UMKA_FUNCTION(SetMouseOffset)
void umkaSetMouseOffset(UmkaStackSlot *params, UmkaStackSlot *result) {
    int offsetX = params[1].intVal;
    int offsetY = params[0].intVal;
    SetMouseOffset(offsetX, offsetY);
}

/**
 * Umka bindings for SetMouseScale().
 *
 * @see SetMouseScale()
 */
RAYLIB_UMKA_FUNCTION(SetMouseScale)
void umkaSetMouseScale(UmkaStackSlot *params, UmkaStackSlot *result) {
    float scaleX = params[1].real32Val;
    float scaleY = params[0].real32Val;
    SetMouseScale(scaleX, scaleY);
}

/**
 * Umka bindings for GetMouseWheelMove().
 *
 * @see GetMouseWheelMove()
 */
RAYLIB_UMKA_FUNCTION(GetMouseWheelMove)
void umkaGetMouseWheelMove(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->realVal = GetMouseWheelMove();
}

/**
 * Umka bindings for GetMouseWheelMoveV().
 *
 * @see GetMouseWheelMoveV()
 */
RAYLIB_UMKA_FUNCTION(GetMouseWheelMoveV)
void umkaGetMouseWheelMoveV(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector2), NULL);
    Vector2 out = GetMouseWheelMoveV();
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector2));
}

/**
 * Umka bindings for SetMouseCursor().
 *
 * @see SetMouseCursor()
 */
RAYLIB_UMKA_FUNCTION(SetMouseCursor)
void umkaSetMouseCursor(UmkaStackSlot *params, UmkaStackSlot *result) {
    int cursor = params[0].intVal;
    SetMouseCursor(cursor);
}

/**
 * Umka bindings for GetTouchX().
 *
 * @see GetTouchX()
 */
RAYLIB_UMKA_FUNCTION(GetTouchX)
void umkaGetTouchX(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->intVal = GetTouchX();
}

/**
 * Umka bindings for GetTouchY().
 *
 * @see GetTouchY()
 */
RAYLIB_UMKA_FUNCTION(GetTouchY)
void umkaGetTouchY(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->intVal = GetTouchY();
}

/**
 * Umka bindings for GetTouchPosition().
 *
 * @see GetTouchPosition()
 */
RAYLIB_UMKA_FUNCTION(GetTouchPosition)
void umkaGetTouchPosition(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    int index = params[1].intVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector2), NULL);
    Vector2 out = GetTouchPosition(index);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector2));
}

/**
 * Umka bindings for GetTouchPointId().
 *
 * @see GetTouchPointId()
 */
RAYLIB_UMKA_FUNCTION(GetTouchPointId)
void umkaGetTouchPointId(UmkaStackSlot *params, UmkaStackSlot *result) {
    int index = params[0].intVal;
    result->intVal = GetTouchPointId(index);
}

/**
 * Umka bindings for GetTouchPointCount().
 *
 * @see GetTouchPointCount()
 */
RAYLIB_UMKA_FUNCTION(GetTouchPointCount)
void umkaGetTouchPointCount(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->intVal = GetTouchPointCount();
}

/**
 * Umka bindings for SetGesturesEnabled().
 *
 * @see SetGesturesEnabled()
 */
RAYLIB_UMKA_FUNCTION(SetGesturesEnabled)
void umkaSetGesturesEnabled(UmkaStackSlot *params, UmkaStackSlot *result) {
    unsigned int flags = params[0].uintVal;
    SetGesturesEnabled(flags);
}

/**
 * Umka bindings for IsGestureDetected().
 *
 * @see IsGestureDetected()
 */
RAYLIB_UMKA_FUNCTION(IsGestureDetected)
void umkaIsGestureDetected(UmkaStackSlot *params, UmkaStackSlot *result) {
    int gesture = params[0].intVal;
    result->intVal = (int)IsGestureDetected(gesture);
}

/**
 * Umka bindings for GetGestureDetected().
 *
 * @see GetGestureDetected()
 */
RAYLIB_UMKA_FUNCTION(GetGestureDetected)
void umkaGetGestureDetected(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->intVal = GetGestureDetected();
}

/**
 * Umka bindings for GetGestureHoldDuration().
 *
 * @see GetGestureHoldDuration()
 */
RAYLIB_UMKA_FUNCTION(GetGestureHoldDuration)
void umkaGetGestureHoldDuration(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->realVal = GetGestureHoldDuration();
}

/**
 * Umka bindings for GetGestureDragVector().
 *
 * @see GetGestureDragVector()
 */
RAYLIB_UMKA_FUNCTION(GetGestureDragVector)
void umkaGetGestureDragVector(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector2), NULL);
    Vector2 out = GetGestureDragVector();
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector2));
}

/**
 * Umka bindings for GetGestureDragAngle().
 *
 * @see GetGestureDragAngle()
 */
RAYLIB_UMKA_FUNCTION(GetGestureDragAngle)
void umkaGetGestureDragAngle(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->realVal = GetGestureDragAngle();
}

/**
 * Umka bindings for GetGesturePinchVector().
 *
 * @see GetGesturePinchVector()
 */
RAYLIB_UMKA_FUNCTION(GetGesturePinchVector)
void umkaGetGesturePinchVector(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector2), NULL);
    Vector2 out = GetGesturePinchVector();
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector2));
}

/**
 * Umka bindings for GetGesturePinchAngle().
 *
 * @see GetGesturePinchAngle()
 */
RAYLIB_UMKA_FUNCTION(GetGesturePinchAngle)
void umkaGetGesturePinchAngle(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->realVal = GetGesturePinchAngle();
}

/**
 * Umka bindings for SetCameraMode().
 *
 * @see SetCameraMode()
 */
RAYLIB_UMKA_FUNCTION(SetCameraMode)
void umkaSetCameraMode(UmkaStackSlot *params, UmkaStackSlot *result) {
    Camera* camera = (Camera*)&params[1];
    int mode = params[0].intVal;
    SetCameraMode(*camera, mode);
}

/**
 * Umka bindings for UpdateCamera().
 *
 * @see UpdateCamera()
 */
RAYLIB_UMKA_FUNCTION(UpdateCamera)
void umkaUpdateCamera(UmkaStackSlot *params, UmkaStackSlot *result) {
    Camera * camera = (Camera *)params[0].ptrVal;
    UpdateCamera(camera);
}

/**
 * Umka bindings for SetCameraPanControl().
 *
 * @see SetCameraPanControl()
 */
RAYLIB_UMKA_FUNCTION(SetCameraPanControl)
void umkaSetCameraPanControl(UmkaStackSlot *params, UmkaStackSlot *result) {
    int keyPan = params[0].intVal;
    SetCameraPanControl(keyPan);
}

/**
 * Umka bindings for SetCameraAltControl().
 *
 * @see SetCameraAltControl()
 */
RAYLIB_UMKA_FUNCTION(SetCameraAltControl)
void umkaSetCameraAltControl(UmkaStackSlot *params, UmkaStackSlot *result) {
    int keyAlt = params[0].intVal;
    SetCameraAltControl(keyAlt);
}

/**
 * Umka bindings for SetCameraSmoothZoomControl().
 *
 * @see SetCameraSmoothZoomControl()
 */
RAYLIB_UMKA_FUNCTION(SetCameraSmoothZoomControl)
void umkaSetCameraSmoothZoomControl(UmkaStackSlot *params, UmkaStackSlot *result) {
    int keySmoothZoom = params[0].intVal;
    SetCameraSmoothZoomControl(keySmoothZoom);
}

/**
 * Umka bindings for SetCameraMoveControls().
 *
 * @see SetCameraMoveControls()
 */
RAYLIB_UMKA_FUNCTION(SetCameraMoveControls)
void umkaSetCameraMoveControls(UmkaStackSlot *params, UmkaStackSlot *result) {
    int keyFront = params[5].intVal;
    int keyBack = params[4].intVal;
    int keyRight = params[3].intVal;
    int keyLeft = params[2].intVal;
    int keyUp = params[1].intVal;
    int keyDown = params[0].intVal;
    SetCameraMoveControls(keyFront, keyBack, keyRight, keyLeft, keyUp, keyDown);
}

/**
 * Umka bindings for SetShapesTexture().
 *
 * @see SetShapesTexture()
 */
RAYLIB_UMKA_FUNCTION(SetShapesTexture)
void umkaSetShapesTexture(UmkaStackSlot *params, UmkaStackSlot *result) {
    Texture2D* texture = (Texture2D*)&params[1];
    Rectangle* source = (Rectangle*)&params[0];
    SetShapesTexture(*texture, *source);
}

/**
 * Umka bindings for DrawPixel().
 *
 * @see DrawPixel()
 */
RAYLIB_UMKA_FUNCTION(DrawPixel)
void umkaDrawPixel(UmkaStackSlot *params, UmkaStackSlot *result) {
    int posX = params[2].intVal;
    int posY = params[1].intVal;
    Color* color = (Color*)&params[0];
    DrawPixel(posX, posY, *color);
}

/**
 * Umka bindings for DrawPixelV().
 *
 * @see DrawPixelV()
 */
RAYLIB_UMKA_FUNCTION(DrawPixelV)
void umkaDrawPixelV(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2* position = (Vector2*)&params[1];
    Color* color = (Color*)&params[0];
    DrawPixelV(*position, *color);
}

/**
 * Umka bindings for DrawLine().
 *
 * @see DrawLine()
 */
RAYLIB_UMKA_FUNCTION(DrawLine)
void umkaDrawLine(UmkaStackSlot *params, UmkaStackSlot *result) {
    int startPosX = params[4].intVal;
    int startPosY = params[3].intVal;
    int endPosX = params[2].intVal;
    int endPosY = params[1].intVal;
    Color* color = (Color*)&params[0];
    DrawLine(startPosX, startPosY, endPosX, endPosY, *color);
}

/**
 * Umka bindings for DrawLineV().
 *
 * @see DrawLineV()
 */
RAYLIB_UMKA_FUNCTION(DrawLineV)
void umkaDrawLineV(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2* startPos = (Vector2*)&params[2];
    Vector2* endPos = (Vector2*)&params[1];
    Color* color = (Color*)&params[0];
    DrawLineV(*startPos, *endPos, *color);
}

/**
 * Umka bindings for DrawLineEx().
 *
 * @see DrawLineEx()
 */
RAYLIB_UMKA_FUNCTION(DrawLineEx)
void umkaDrawLineEx(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2* startPos = (Vector2*)&params[3];
    Vector2* endPos = (Vector2*)&params[2];
    float thick = params[1].real32Val;
    Color* color = (Color*)&params[0];
    DrawLineEx(*startPos, *endPos, thick, *color);
}

/**
 * Umka bindings for DrawLineBezier().
 *
 * @see DrawLineBezier()
 */
RAYLIB_UMKA_FUNCTION(DrawLineBezier)
void umkaDrawLineBezier(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2* startPos = (Vector2*)&params[3];
    Vector2* endPos = (Vector2*)&params[2];
    float thick = params[1].real32Val;
    Color* color = (Color*)&params[0];
    DrawLineBezier(*startPos, *endPos, thick, *color);
}

/**
 * Umka bindings for DrawLineBezierQuad().
 *
 * @see DrawLineBezierQuad()
 */
RAYLIB_UMKA_FUNCTION(DrawLineBezierQuad)
void umkaDrawLineBezierQuad(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2* startPos = (Vector2*)&params[4];
    Vector2* endPos = (Vector2*)&params[3];
    Vector2* controlPos = (Vector2*)&params[2];
    float thick = params[1].real32Val;
    Color* color = (Color*)&params[0];
    DrawLineBezierQuad(*startPos, *endPos, *controlPos, thick, *color);
}

/**
 * Umka bindings for DrawLineBezierCubic().
 *
 * @see DrawLineBezierCubic()
 */
RAYLIB_UMKA_FUNCTION(DrawLineBezierCubic)
void umkaDrawLineBezierCubic(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2* startPos = (Vector2*)&params[5];
    Vector2* endPos = (Vector2*)&params[4];
    Vector2* startControlPos = (Vector2*)&params[3];
    Vector2* endControlPos = (Vector2*)&params[2];
    float thick = params[1].real32Val;
    Color* color = (Color*)&params[0];
    DrawLineBezierCubic(*startPos, *endPos, *startControlPos, *endControlPos, thick, *color);
}

/**
 * Umka bindings for DrawLineStrip().
 *
 * @see DrawLineStrip()
 */
RAYLIB_UMKA_FUNCTION(DrawLineStrip)
void umkaDrawLineStrip(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2 * points = (Vector2 *)params[2].ptrVal;
    int pointCount = params[1].intVal;
    Color* color = (Color*)&params[0];
    DrawLineStrip(points, pointCount, *color);
}

/**
 * Umka bindings for DrawCircle().
 *
 * @see DrawCircle()
 */
RAYLIB_UMKA_FUNCTION(DrawCircle)
void umkaDrawCircle(UmkaStackSlot *params, UmkaStackSlot *result) {
    int centerX = params[3].intVal;
    int centerY = params[2].intVal;
    float radius = params[1].real32Val;
    Color* color = (Color*)&params[0];
    DrawCircle(centerX, centerY, radius, *color);
}

/**
 * Umka bindings for DrawCircleSector().
 *
 * @see DrawCircleSector()
 */
RAYLIB_UMKA_FUNCTION(DrawCircleSector)
void umkaDrawCircleSector(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2* center = (Vector2*)&params[5];
    float radius = params[4].real32Val;
    float startAngle = params[3].real32Val;
    float endAngle = params[2].real32Val;
    int segments = params[1].intVal;
    Color* color = (Color*)&params[0];
    DrawCircleSector(*center, radius, startAngle, endAngle, segments, *color);
}

/**
 * Umka bindings for DrawCircleSectorLines().
 *
 * @see DrawCircleSectorLines()
 */
RAYLIB_UMKA_FUNCTION(DrawCircleSectorLines)
void umkaDrawCircleSectorLines(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2* center = (Vector2*)&params[5];
    float radius = params[4].real32Val;
    float startAngle = params[3].real32Val;
    float endAngle = params[2].real32Val;
    int segments = params[1].intVal;
    Color* color = (Color*)&params[0];
    DrawCircleSectorLines(*center, radius, startAngle, endAngle, segments, *color);
}

/**
 * Umka bindings for DrawCircleGradient().
 *
 * @see DrawCircleGradient()
 */
RAYLIB_UMKA_FUNCTION(DrawCircleGradient)
void umkaDrawCircleGradient(UmkaStackSlot *params, UmkaStackSlot *result) {
    int centerX = params[4].intVal;
    int centerY = params[3].intVal;
    float radius = params[2].real32Val;
    Color* color1 = (Color*)&params[1];
    Color* color2 = (Color*)&params[0];
    DrawCircleGradient(centerX, centerY, radius, *color1, *color2);
}

/**
 * Umka bindings for DrawCircleV().
 *
 * @see DrawCircleV()
 */
RAYLIB_UMKA_FUNCTION(DrawCircleV)
void umkaDrawCircleV(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2* center = (Vector2*)&params[2];
    float radius = params[1].real32Val;
    Color* color = (Color*)&params[0];
    DrawCircleV(*center, radius, *color);
}

/**
 * Umka bindings for DrawCircleLines().
 *
 * @see DrawCircleLines()
 */
RAYLIB_UMKA_FUNCTION(DrawCircleLines)
void umkaDrawCircleLines(UmkaStackSlot *params, UmkaStackSlot *result) {
    int centerX = params[3].intVal;
    int centerY = params[2].intVal;
    float radius = params[1].real32Val;
    Color* color = (Color*)&params[0];
    DrawCircleLines(centerX, centerY, radius, *color);
}

/**
 * Umka bindings for DrawEllipse().
 *
 * @see DrawEllipse()
 */
RAYLIB_UMKA_FUNCTION(DrawEllipse)
void umkaDrawEllipse(UmkaStackSlot *params, UmkaStackSlot *result) {
    int centerX = params[4].intVal;
    int centerY = params[3].intVal;
    float radiusH = params[2].real32Val;
    float radiusV = params[1].real32Val;
    Color* color = (Color*)&params[0];
    DrawEllipse(centerX, centerY, radiusH, radiusV, *color);
}

/**
 * Umka bindings for DrawEllipseLines().
 *
 * @see DrawEllipseLines()
 */
RAYLIB_UMKA_FUNCTION(DrawEllipseLines)
void umkaDrawEllipseLines(UmkaStackSlot *params, UmkaStackSlot *result) {
    int centerX = params[4].intVal;
    int centerY = params[3].intVal;
    float radiusH = params[2].real32Val;
    float radiusV = params[1].real32Val;
    Color* color = (Color*)&params[0];
    DrawEllipseLines(centerX, centerY, radiusH, radiusV, *color);
}

/**
 * Umka bindings for DrawRing().
 *
 * @see DrawRing()
 */
RAYLIB_UMKA_FUNCTION(DrawRing)
void umkaDrawRing(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2* center = (Vector2*)&params[6];
    float innerRadius = params[5].real32Val;
    float outerRadius = params[4].real32Val;
    float startAngle = params[3].real32Val;
    float endAngle = params[2].real32Val;
    int segments = params[1].intVal;
    Color* color = (Color*)&params[0];
    DrawRing(*center, innerRadius, outerRadius, startAngle, endAngle, segments, *color);
}

/**
 * Umka bindings for DrawRingLines().
 *
 * @see DrawRingLines()
 */
RAYLIB_UMKA_FUNCTION(DrawRingLines)
void umkaDrawRingLines(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2* center = (Vector2*)&params[6];
    float innerRadius = params[5].real32Val;
    float outerRadius = params[4].real32Val;
    float startAngle = params[3].real32Val;
    float endAngle = params[2].real32Val;
    int segments = params[1].intVal;
    Color* color = (Color*)&params[0];
    DrawRingLines(*center, innerRadius, outerRadius, startAngle, endAngle, segments, *color);
}

/**
 * Umka bindings for DrawRectangle().
 *
 * @see DrawRectangle()
 */
RAYLIB_UMKA_FUNCTION(DrawRectangle)
void umkaDrawRectangle(UmkaStackSlot *params, UmkaStackSlot *result) {
    int posX = params[4].intVal;
    int posY = params[3].intVal;
    int width = params[2].intVal;
    int height = params[1].intVal;
    Color* color = (Color*)&params[0];
    DrawRectangle(posX, posY, width, height, *color);
}

/**
 * Umka bindings for DrawRectangleV().
 *
 * @see DrawRectangleV()
 */
RAYLIB_UMKA_FUNCTION(DrawRectangleV)
void umkaDrawRectangleV(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2* position = (Vector2*)&params[2];
    Vector2* size = (Vector2*)&params[1];
    Color* color = (Color*)&params[0];
    DrawRectangleV(*position, *size, *color);
}

/**
 * Umka bindings for DrawRectangleRec().
 *
 * @see DrawRectangleRec()
 */
RAYLIB_UMKA_FUNCTION(DrawRectangleRec)
void umkaDrawRectangleRec(UmkaStackSlot *params, UmkaStackSlot *result) {
    Rectangle* rec = (Rectangle*)&params[1];
    Color* color = (Color*)&params[0];
    DrawRectangleRec(*rec, *color);
}

/**
 * Umka bindings for DrawRectanglePro().
 *
 * @see DrawRectanglePro()
 */
RAYLIB_UMKA_FUNCTION(DrawRectanglePro)
void umkaDrawRectanglePro(UmkaStackSlot *params, UmkaStackSlot *result) {
    Rectangle* rec = (Rectangle*)&params[3];
    Vector2* origin = (Vector2*)&params[2];
    float rotation = params[1].real32Val;
    Color* color = (Color*)&params[0];
    DrawRectanglePro(*rec, *origin, rotation, *color);
}

/**
 * Umka bindings for DrawRectangleGradientV().
 *
 * @see DrawRectangleGradientV()
 */
RAYLIB_UMKA_FUNCTION(DrawRectangleGradientV)
void umkaDrawRectangleGradientV(UmkaStackSlot *params, UmkaStackSlot *result) {
    int posX = params[5].intVal;
    int posY = params[4].intVal;
    int width = params[3].intVal;
    int height = params[2].intVal;
    Color* color1 = (Color*)&params[1];
    Color* color2 = (Color*)&params[0];
    DrawRectangleGradientV(posX, posY, width, height, *color1, *color2);
}

/**
 * Umka bindings for DrawRectangleGradientH().
 *
 * @see DrawRectangleGradientH()
 */
RAYLIB_UMKA_FUNCTION(DrawRectangleGradientH)
void umkaDrawRectangleGradientH(UmkaStackSlot *params, UmkaStackSlot *result) {
    int posX = params[5].intVal;
    int posY = params[4].intVal;
    int width = params[3].intVal;
    int height = params[2].intVal;
    Color* color1 = (Color*)&params[1];
    Color* color2 = (Color*)&params[0];
    DrawRectangleGradientH(posX, posY, width, height, *color1, *color2);
}

/**
 * Umka bindings for DrawRectangleGradientEx().
 *
 * @see DrawRectangleGradientEx()
 */
RAYLIB_UMKA_FUNCTION(DrawRectangleGradientEx)
void umkaDrawRectangleGradientEx(UmkaStackSlot *params, UmkaStackSlot *result) {
    Rectangle* rec = (Rectangle*)&params[4];
    Color* col1 = (Color*)&params[3];
    Color* col2 = (Color*)&params[2];
    Color* col3 = (Color*)&params[1];
    Color* col4 = (Color*)&params[0];
    DrawRectangleGradientEx(*rec, *col1, *col2, *col3, *col4);
}

/**
 * Umka bindings for DrawRectangleLines().
 *
 * @see DrawRectangleLines()
 */
RAYLIB_UMKA_FUNCTION(DrawRectangleLines)
void umkaDrawRectangleLines(UmkaStackSlot *params, UmkaStackSlot *result) {
    int posX = params[4].intVal;
    int posY = params[3].intVal;
    int width = params[2].intVal;
    int height = params[1].intVal;
    Color* color = (Color*)&params[0];
    DrawRectangleLines(posX, posY, width, height, *color);
}

/**
 * Umka bindings for DrawRectangleLinesEx().
 *
 * @see DrawRectangleLinesEx()
 */
RAYLIB_UMKA_FUNCTION(DrawRectangleLinesEx)
void umkaDrawRectangleLinesEx(UmkaStackSlot *params, UmkaStackSlot *result) {
    Rectangle* rec = (Rectangle*)&params[2];
    float lineThick = params[1].real32Val;
    Color* color = (Color*)&params[0];
    DrawRectangleLinesEx(*rec, lineThick, *color);
}

/**
 * Umka bindings for DrawRectangleRounded().
 *
 * @see DrawRectangleRounded()
 */
RAYLIB_UMKA_FUNCTION(DrawRectangleRounded)
void umkaDrawRectangleRounded(UmkaStackSlot *params, UmkaStackSlot *result) {
    Rectangle* rec = (Rectangle*)&params[3];
    float roundness = params[2].real32Val;
    int segments = params[1].intVal;
    Color* color = (Color*)&params[0];
    DrawRectangleRounded(*rec, roundness, segments, *color);
}

/**
 * Umka bindings for DrawRectangleRoundedLines().
 *
 * @see DrawRectangleRoundedLines()
 */
RAYLIB_UMKA_FUNCTION(DrawRectangleRoundedLines)
void umkaDrawRectangleRoundedLines(UmkaStackSlot *params, UmkaStackSlot *result) {
    Rectangle* rec = (Rectangle*)&params[4];
    float roundness = params[3].real32Val;
    int segments = params[2].intVal;
    float lineThick = params[1].real32Val;
    Color* color = (Color*)&params[0];
    DrawRectangleRoundedLines(*rec, roundness, segments, lineThick, *color);
}

/**
 * Umka bindings for DrawTriangle().
 *
 * @see DrawTriangle()
 */
RAYLIB_UMKA_FUNCTION(DrawTriangle)
void umkaDrawTriangle(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2* v1 = (Vector2*)&params[3];
    Vector2* v2 = (Vector2*)&params[2];
    Vector2* v3 = (Vector2*)&params[1];
    Color* color = (Color*)&params[0];
    DrawTriangle(*v1, *v2, *v3, *color);
}

/**
 * Umka bindings for DrawTriangleLines().
 *
 * @see DrawTriangleLines()
 */
RAYLIB_UMKA_FUNCTION(DrawTriangleLines)
void umkaDrawTriangleLines(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2* v1 = (Vector2*)&params[3];
    Vector2* v2 = (Vector2*)&params[2];
    Vector2* v3 = (Vector2*)&params[1];
    Color* color = (Color*)&params[0];
    DrawTriangleLines(*v1, *v2, *v3, *color);
}

/**
 * Umka bindings for DrawTriangleFan().
 *
 * @see DrawTriangleFan()
 */
RAYLIB_UMKA_FUNCTION(DrawTriangleFan)
void umkaDrawTriangleFan(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2 * points = (Vector2 *)params[2].ptrVal;
    int pointCount = params[1].intVal;
    Color* color = (Color*)&params[0];
    DrawTriangleFan(points, pointCount, *color);
}

/**
 * Umka bindings for DrawTriangleStrip().
 *
 * @see DrawTriangleStrip()
 */
RAYLIB_UMKA_FUNCTION(DrawTriangleStrip)
void umkaDrawTriangleStrip(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2 * points = (Vector2 *)params[2].ptrVal;
    int pointCount = params[1].intVal;
    Color* color = (Color*)&params[0];
    DrawTriangleStrip(points, pointCount, *color);
}

/**
 * Umka bindings for DrawPoly().
 *
 * @see DrawPoly()
 */
RAYLIB_UMKA_FUNCTION(DrawPoly)
void umkaDrawPoly(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2* center = (Vector2*)&params[4];
    int sides = params[3].intVal;
    float radius = params[2].real32Val;
    float rotation = params[1].real32Val;
    Color* color = (Color*)&params[0];
    DrawPoly(*center, sides, radius, rotation, *color);
}

/**
 * Umka bindings for DrawPolyLines().
 *
 * @see DrawPolyLines()
 */
RAYLIB_UMKA_FUNCTION(DrawPolyLines)
void umkaDrawPolyLines(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2* center = (Vector2*)&params[4];
    int sides = params[3].intVal;
    float radius = params[2].real32Val;
    float rotation = params[1].real32Val;
    Color* color = (Color*)&params[0];
    DrawPolyLines(*center, sides, radius, rotation, *color);
}

/**
 * Umka bindings for DrawPolyLinesEx().
 *
 * @see DrawPolyLinesEx()
 */
RAYLIB_UMKA_FUNCTION(DrawPolyLinesEx)
void umkaDrawPolyLinesEx(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2* center = (Vector2*)&params[5];
    int sides = params[4].intVal;
    float radius = params[3].real32Val;
    float rotation = params[2].real32Val;
    float lineThick = params[1].real32Val;
    Color* color = (Color*)&params[0];
    DrawPolyLinesEx(*center, sides, radius, rotation, lineThick, *color);
}

/**
 * Umka bindings for CheckCollisionRecs().
 *
 * @see CheckCollisionRecs()
 */
RAYLIB_UMKA_FUNCTION(CheckCollisionRecs)
void umkaCheckCollisionRecs(UmkaStackSlot *params, UmkaStackSlot *result) {
    Rectangle* rec1 = (Rectangle*)&params[1];
    Rectangle* rec2 = (Rectangle*)&params[0];
    result->intVal = (int)CheckCollisionRecs(*rec1, *rec2);
}

/**
 * Umka bindings for CheckCollisionCircles().
 *
 * @see CheckCollisionCircles()
 */
RAYLIB_UMKA_FUNCTION(CheckCollisionCircles)
void umkaCheckCollisionCircles(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2* center1 = (Vector2*)&params[3];
    float radius1 = params[2].real32Val;
    Vector2* center2 = (Vector2*)&params[1];
    float radius2 = params[0].real32Val;
    result->intVal = (int)CheckCollisionCircles(*center1, radius1, *center2, radius2);
}

/**
 * Umka bindings for CheckCollisionCircleRec().
 *
 * @see CheckCollisionCircleRec()
 */
RAYLIB_UMKA_FUNCTION(CheckCollisionCircleRec)
void umkaCheckCollisionCircleRec(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2* center = (Vector2*)&params[2];
    float radius = params[1].real32Val;
    Rectangle* rec = (Rectangle*)&params[0];
    result->intVal = (int)CheckCollisionCircleRec(*center, radius, *rec);
}

/**
 * Umka bindings for CheckCollisionPointRec().
 *
 * @see CheckCollisionPointRec()
 */
RAYLIB_UMKA_FUNCTION(CheckCollisionPointRec)
void umkaCheckCollisionPointRec(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2* point = (Vector2*)&params[1];
    Rectangle* rec = (Rectangle*)&params[0];
    result->intVal = (int)CheckCollisionPointRec(*point, *rec);
}

/**
 * Umka bindings for CheckCollisionPointCircle().
 *
 * @see CheckCollisionPointCircle()
 */
RAYLIB_UMKA_FUNCTION(CheckCollisionPointCircle)
void umkaCheckCollisionPointCircle(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2* point = (Vector2*)&params[2];
    Vector2* center = (Vector2*)&params[1];
    float radius = params[0].real32Val;
    result->intVal = (int)CheckCollisionPointCircle(*point, *center, radius);
}

/**
 * Umka bindings for CheckCollisionPointTriangle().
 *
 * @see CheckCollisionPointTriangle()
 */
RAYLIB_UMKA_FUNCTION(CheckCollisionPointTriangle)
void umkaCheckCollisionPointTriangle(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2* point = (Vector2*)&params[3];
    Vector2* p1 = (Vector2*)&params[2];
    Vector2* p2 = (Vector2*)&params[1];
    Vector2* p3 = (Vector2*)&params[0];
    result->intVal = (int)CheckCollisionPointTriangle(*point, *p1, *p2, *p3);
}

/**
 * Umka bindings for CheckCollisionLines().
 *
 * @see CheckCollisionLines()
 */
RAYLIB_UMKA_FUNCTION(CheckCollisionLines)
void umkaCheckCollisionLines(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2* startPos1 = (Vector2*)&params[4];
    Vector2* endPos1 = (Vector2*)&params[3];
    Vector2* startPos2 = (Vector2*)&params[2];
    Vector2* endPos2 = (Vector2*)&params[1];
    Vector2 * collisionPoint = (Vector2 *)params[0].ptrVal;
    result->intVal = (int)CheckCollisionLines(*startPos1, *endPos1, *startPos2, *endPos2, collisionPoint);
}

/**
 * Umka bindings for CheckCollisionPointLine().
 *
 * @see CheckCollisionPointLine()
 */
RAYLIB_UMKA_FUNCTION(CheckCollisionPointLine)
void umkaCheckCollisionPointLine(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2* point = (Vector2*)&params[3];
    Vector2* p1 = (Vector2*)&params[2];
    Vector2* p2 = (Vector2*)&params[1];
    int threshold = params[0].intVal;
    result->intVal = (int)CheckCollisionPointLine(*point, *p1, *p2, threshold);
}

/**
 * Umka bindings for GetCollisionRec().
 *
 * @see GetCollisionRec()
 */
RAYLIB_UMKA_FUNCTION(GetCollisionRec)
void umkaGetCollisionRec(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Rectangle* rec1 = (Rectangle*)&params[2];
    Rectangle* rec2 = (Rectangle*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Rectangle), NULL);
    Rectangle out = GetCollisionRec(*rec1, *rec2);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Rectangle));
}

/**
 * Umka bindings for LoadImage().
 *
 * @see LoadImage()
 */
RAYLIB_UMKA_FUNCTION(LoadImage)
void umkaLoadImage(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    const char * fileName = (const char *)params[1].ptrVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Image), NULL);
    Image out = LoadImage(fileName);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Image));
}

/**
 * Umka bindings for LoadImageRaw().
 *
 * @see LoadImageRaw()
 */
RAYLIB_UMKA_FUNCTION(LoadImageRaw)
void umkaLoadImageRaw(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    const char * fileName = (const char *)params[5].ptrVal;
    int width = params[4].intVal;
    int height = params[3].intVal;
    int format = params[2].intVal;
    int headerSize = params[1].intVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Image), NULL);
    Image out = LoadImageRaw(fileName, width, height, format, headerSize);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Image));
}

/**
 * Umka bindings for LoadImageAnim().
 *
 * @see LoadImageAnim()
 */
RAYLIB_UMKA_FUNCTION(LoadImageAnim)
void umkaLoadImageAnim(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    const char * fileName = (const char *)params[2].ptrVal;
    int * frames = (int *)params[1].ptrVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Image), NULL);
    Image out = LoadImageAnim(fileName, frames);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Image));
}

/**
 * Umka bindings for LoadImageFromMemory().
 *
 * @see LoadImageFromMemory()
 */
RAYLIB_UMKA_FUNCTION(LoadImageFromMemory)
void umkaLoadImageFromMemory(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    const char * fileType = (const char *)params[3].ptrVal;
    const unsigned char * fileData = (const unsigned char *)params[2].ptrVal;
    int dataSize = params[1].intVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Image), NULL);
    Image out = LoadImageFromMemory(fileType, fileData, dataSize);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Image));
}

/**
 * Umka bindings for LoadImageFromTexture().
 *
 * @see LoadImageFromTexture()
 */
RAYLIB_UMKA_FUNCTION(LoadImageFromTexture)
void umkaLoadImageFromTexture(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Texture2D* texture = (Texture2D*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Image), NULL);
    Image out = LoadImageFromTexture(*texture);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Image));
}

/**
 * Umka bindings for LoadImageFromScreen().
 *
 * @see LoadImageFromScreen()
 */
RAYLIB_UMKA_FUNCTION(LoadImageFromScreen)
void umkaLoadImageFromScreen(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Image), NULL);
    Image out = LoadImageFromScreen();
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Image));
}

/**
 * Umka bindings for UnloadImage().
 *
 * @see UnloadImage()
 */
RAYLIB_UMKA_FUNCTION(UnloadImage)
void umkaUnloadImage(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image* image = (Image*)&params[0];
    UnloadImage(*image);
}

/**
 * Umka bindings for ExportImage().
 *
 * @see ExportImage()
 */
RAYLIB_UMKA_FUNCTION(ExportImage)
void umkaExportImage(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image* image = (Image*)&params[1];
    const char * fileName = (const char *)params[0].ptrVal;
    result->intVal = (int)ExportImage(*image, fileName);
}

/**
 * Umka bindings for ExportImageAsCode().
 *
 * @see ExportImageAsCode()
 */
RAYLIB_UMKA_FUNCTION(ExportImageAsCode)
void umkaExportImageAsCode(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image* image = (Image*)&params[1];
    const char * fileName = (const char *)params[0].ptrVal;
    result->intVal = (int)ExportImageAsCode(*image, fileName);
}

/**
 * Umka bindings for GenImageColor().
 *
 * @see GenImageColor()
 */
RAYLIB_UMKA_FUNCTION(GenImageColor)
void umkaGenImageColor(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    int width = params[3].intVal;
    int height = params[2].intVal;
    Color* color = (Color*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Image), NULL);
    Image out = GenImageColor(width, height, *color);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Image));
}

/**
 * Umka bindings for GenImageGradientV().
 *
 * @see GenImageGradientV()
 */
RAYLIB_UMKA_FUNCTION(GenImageGradientV)
void umkaGenImageGradientV(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    int width = params[4].intVal;
    int height = params[3].intVal;
    Color* top = (Color*)&params[2];
    Color* bottom = (Color*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Image), NULL);
    Image out = GenImageGradientV(width, height, *top, *bottom);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Image));
}

/**
 * Umka bindings for GenImageGradientH().
 *
 * @see GenImageGradientH()
 */
RAYLIB_UMKA_FUNCTION(GenImageGradientH)
void umkaGenImageGradientH(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    int width = params[4].intVal;
    int height = params[3].intVal;
    Color* left = (Color*)&params[2];
    Color* right = (Color*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Image), NULL);
    Image out = GenImageGradientH(width, height, *left, *right);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Image));
}

/**
 * Umka bindings for GenImageGradientRadial().
 *
 * @see GenImageGradientRadial()
 */
RAYLIB_UMKA_FUNCTION(GenImageGradientRadial)
void umkaGenImageGradientRadial(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    int width = params[5].intVal;
    int height = params[4].intVal;
    float density = params[3].real32Val;
    Color* inner = (Color*)&params[2];
    Color* outer = (Color*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Image), NULL);
    Image out = GenImageGradientRadial(width, height, density, *inner, *outer);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Image));
}

/**
 * Umka bindings for GenImageChecked().
 *
 * @see GenImageChecked()
 */
RAYLIB_UMKA_FUNCTION(GenImageChecked)
void umkaGenImageChecked(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    int width = params[6].intVal;
    int height = params[5].intVal;
    int checksX = params[4].intVal;
    int checksY = params[3].intVal;
    Color* col1 = (Color*)&params[2];
    Color* col2 = (Color*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Image), NULL);
    Image out = GenImageChecked(width, height, checksX, checksY, *col1, *col2);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Image));
}

/**
 * Umka bindings for GenImageWhiteNoise().
 *
 * @see GenImageWhiteNoise()
 */
RAYLIB_UMKA_FUNCTION(GenImageWhiteNoise)
void umkaGenImageWhiteNoise(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    int width = params[3].intVal;
    int height = params[2].intVal;
    float factor = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Image), NULL);
    Image out = GenImageWhiteNoise(width, height, factor);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Image));
}

/**
 * Umka bindings for GenImageCellular().
 *
 * @see GenImageCellular()
 */
RAYLIB_UMKA_FUNCTION(GenImageCellular)
void umkaGenImageCellular(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    int width = params[3].intVal;
    int height = params[2].intVal;
    int tileSize = params[1].intVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Image), NULL);
    Image out = GenImageCellular(width, height, tileSize);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Image));
}

/**
 * Umka bindings for ImageCopy().
 *
 * @see ImageCopy()
 */
RAYLIB_UMKA_FUNCTION(ImageCopy)
void umkaImageCopy(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Image* image = (Image*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Image), NULL);
    Image out = ImageCopy(*image);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Image));
}

/**
 * Umka bindings for ImageFromImage().
 *
 * @see ImageFromImage()
 */
RAYLIB_UMKA_FUNCTION(ImageFromImage)
void umkaImageFromImage(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Image* image = (Image*)&params[2];
    Rectangle* rec = (Rectangle*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Image), NULL);
    Image out = ImageFromImage(*image, *rec);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Image));
}

/**
 * Umka bindings for ImageText().
 *
 * @see ImageText()
 */
RAYLIB_UMKA_FUNCTION(ImageText)
void umkaImageText(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    const char * text = (const char *)params[3].ptrVal;
    int fontSize = params[2].intVal;
    Color* color = (Color*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Image), NULL);
    Image out = ImageText(text, fontSize, *color);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Image));
}

/**
 * Umka bindings for ImageTextEx().
 *
 * @see ImageTextEx()
 */
RAYLIB_UMKA_FUNCTION(ImageTextEx)
void umkaImageTextEx(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Font* font = (Font*)&params[5];
    const char * text = (const char *)params[4].ptrVal;
    float fontSize = params[3].real32Val;
    float spacing = params[2].real32Val;
    Color* tint = (Color*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Image), NULL);
    Image out = ImageTextEx(*font, text, fontSize, spacing, *tint);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Image));
}

/**
 * Umka bindings for ImageFormat().
 *
 * @see ImageFormat()
 */
RAYLIB_UMKA_FUNCTION(ImageFormat)
void umkaImageFormat(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * image = (Image *)params[1].ptrVal;
    int newFormat = params[0].intVal;
    ImageFormat(image, newFormat);
}

/**
 * Umka bindings for ImageToPOT().
 *
 * @see ImageToPOT()
 */
RAYLIB_UMKA_FUNCTION(ImageToPOT)
void umkaImageToPOT(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * image = (Image *)params[1].ptrVal;
    Color* fill = (Color*)&params[0];
    ImageToPOT(image, *fill);
}

/**
 * Umka bindings for ImageCrop().
 *
 * @see ImageCrop()
 */
RAYLIB_UMKA_FUNCTION(ImageCrop)
void umkaImageCrop(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * image = (Image *)params[1].ptrVal;
    Rectangle* crop = (Rectangle*)&params[0];
    ImageCrop(image, *crop);
}

/**
 * Umka bindings for ImageAlphaCrop().
 *
 * @see ImageAlphaCrop()
 */
RAYLIB_UMKA_FUNCTION(ImageAlphaCrop)
void umkaImageAlphaCrop(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * image = (Image *)params[1].ptrVal;
    float threshold = params[0].real32Val;
    ImageAlphaCrop(image, threshold);
}

/**
 * Umka bindings for ImageAlphaClear().
 *
 * @see ImageAlphaClear()
 */
RAYLIB_UMKA_FUNCTION(ImageAlphaClear)
void umkaImageAlphaClear(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * image = (Image *)params[2].ptrVal;
    Color* color = (Color*)&params[1];
    float threshold = params[0].real32Val;
    ImageAlphaClear(image, *color, threshold);
}

/**
 * Umka bindings for ImageAlphaMask().
 *
 * @see ImageAlphaMask()
 */
RAYLIB_UMKA_FUNCTION(ImageAlphaMask)
void umkaImageAlphaMask(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * image = (Image *)params[1].ptrVal;
    Image* alphaMask = (Image*)&params[0];
    ImageAlphaMask(image, *alphaMask);
}

/**
 * Umka bindings for ImageAlphaPremultiply().
 *
 * @see ImageAlphaPremultiply()
 */
RAYLIB_UMKA_FUNCTION(ImageAlphaPremultiply)
void umkaImageAlphaPremultiply(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * image = (Image *)params[0].ptrVal;
    ImageAlphaPremultiply(image);
}

/**
 * Umka bindings for ImageResize().
 *
 * @see ImageResize()
 */
RAYLIB_UMKA_FUNCTION(ImageResize)
void umkaImageResize(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * image = (Image *)params[2].ptrVal;
    int newWidth = params[1].intVal;
    int newHeight = params[0].intVal;
    ImageResize(image, newWidth, newHeight);
}

/**
 * Umka bindings for ImageResizeNN().
 *
 * @see ImageResizeNN()
 */
RAYLIB_UMKA_FUNCTION(ImageResizeNN)
void umkaImageResizeNN(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * image = (Image *)params[2].ptrVal;
    int newWidth = params[1].intVal;
    int newHeight = params[0].intVal;
    ImageResizeNN(image, newWidth, newHeight);
}

/**
 * Umka bindings for ImageResizeCanvas().
 *
 * @see ImageResizeCanvas()
 */
RAYLIB_UMKA_FUNCTION(ImageResizeCanvas)
void umkaImageResizeCanvas(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * image = (Image *)params[5].ptrVal;
    int newWidth = params[4].intVal;
    int newHeight = params[3].intVal;
    int offsetX = params[2].intVal;
    int offsetY = params[1].intVal;
    Color* fill = (Color*)&params[0];
    ImageResizeCanvas(image, newWidth, newHeight, offsetX, offsetY, *fill);
}

/**
 * Umka bindings for ImageMipmaps().
 *
 * @see ImageMipmaps()
 */
RAYLIB_UMKA_FUNCTION(ImageMipmaps)
void umkaImageMipmaps(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * image = (Image *)params[0].ptrVal;
    ImageMipmaps(image);
}

/**
 * Umka bindings for ImageDither().
 *
 * @see ImageDither()
 */
RAYLIB_UMKA_FUNCTION(ImageDither)
void umkaImageDither(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * image = (Image *)params[4].ptrVal;
    int rBpp = params[3].intVal;
    int gBpp = params[2].intVal;
    int bBpp = params[1].intVal;
    int aBpp = params[0].intVal;
    ImageDither(image, rBpp, gBpp, bBpp, aBpp);
}

/**
 * Umka bindings for ImageFlipVertical().
 *
 * @see ImageFlipVertical()
 */
RAYLIB_UMKA_FUNCTION(ImageFlipVertical)
void umkaImageFlipVertical(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * image = (Image *)params[0].ptrVal;
    ImageFlipVertical(image);
}

/**
 * Umka bindings for ImageFlipHorizontal().
 *
 * @see ImageFlipHorizontal()
 */
RAYLIB_UMKA_FUNCTION(ImageFlipHorizontal)
void umkaImageFlipHorizontal(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * image = (Image *)params[0].ptrVal;
    ImageFlipHorizontal(image);
}

/**
 * Umka bindings for ImageRotateCW().
 *
 * @see ImageRotateCW()
 */
RAYLIB_UMKA_FUNCTION(ImageRotateCW)
void umkaImageRotateCW(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * image = (Image *)params[0].ptrVal;
    ImageRotateCW(image);
}

/**
 * Umka bindings for ImageRotateCCW().
 *
 * @see ImageRotateCCW()
 */
RAYLIB_UMKA_FUNCTION(ImageRotateCCW)
void umkaImageRotateCCW(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * image = (Image *)params[0].ptrVal;
    ImageRotateCCW(image);
}

/**
 * Umka bindings for ImageColorTint().
 *
 * @see ImageColorTint()
 */
RAYLIB_UMKA_FUNCTION(ImageColorTint)
void umkaImageColorTint(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * image = (Image *)params[1].ptrVal;
    Color* color = (Color*)&params[0];
    ImageColorTint(image, *color);
}

/**
 * Umka bindings for ImageColorInvert().
 *
 * @see ImageColorInvert()
 */
RAYLIB_UMKA_FUNCTION(ImageColorInvert)
void umkaImageColorInvert(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * image = (Image *)params[0].ptrVal;
    ImageColorInvert(image);
}

/**
 * Umka bindings for ImageColorGrayscale().
 *
 * @see ImageColorGrayscale()
 */
RAYLIB_UMKA_FUNCTION(ImageColorGrayscale)
void umkaImageColorGrayscale(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * image = (Image *)params[0].ptrVal;
    ImageColorGrayscale(image);
}

/**
 * Umka bindings for ImageColorContrast().
 *
 * @see ImageColorContrast()
 */
RAYLIB_UMKA_FUNCTION(ImageColorContrast)
void umkaImageColorContrast(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * image = (Image *)params[1].ptrVal;
    float contrast = params[0].real32Val;
    ImageColorContrast(image, contrast);
}

/**
 * Umka bindings for ImageColorBrightness().
 *
 * @see ImageColorBrightness()
 */
RAYLIB_UMKA_FUNCTION(ImageColorBrightness)
void umkaImageColorBrightness(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * image = (Image *)params[1].ptrVal;
    int brightness = params[0].intVal;
    ImageColorBrightness(image, brightness);
}

/**
 * Umka bindings for ImageColorReplace().
 *
 * @see ImageColorReplace()
 */
RAYLIB_UMKA_FUNCTION(ImageColorReplace)
void umkaImageColorReplace(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * image = (Image *)params[2].ptrVal;
    Color* color = (Color*)&params[1];
    Color* replace = (Color*)&params[0];
    ImageColorReplace(image, *color, *replace);
}

/**
 * Umka bindings for LoadImageColors().
 *
 * @see LoadImageColors()
 */
RAYLIB_UMKA_FUNCTION(LoadImageColors)
void umkaLoadImageColors(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image* image = (Image*)&params[0];
    result->ptrVal = (void*)LoadImageColors(*image);
}

/**
 * Umka bindings for LoadImagePalette().
 *
 * @see LoadImagePalette()
 */
RAYLIB_UMKA_FUNCTION(LoadImagePalette)
void umkaLoadImagePalette(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image* image = (Image*)&params[2];
    int maxPaletteSize = params[1].intVal;
    int * colorCount = (int *)params[0].ptrVal;
    result->ptrVal = (void*)LoadImagePalette(*image, maxPaletteSize, colorCount);
}

/**
 * Umka bindings for UnloadImageColors().
 *
 * @see UnloadImageColors()
 */
RAYLIB_UMKA_FUNCTION(UnloadImageColors)
void umkaUnloadImageColors(UmkaStackSlot *params, UmkaStackSlot *result) {
    Color * colors = (Color *)params[0].ptrVal;
    UnloadImageColors(colors);
}

/**
 * Umka bindings for UnloadImagePalette().
 *
 * @see UnloadImagePalette()
 */
RAYLIB_UMKA_FUNCTION(UnloadImagePalette)
void umkaUnloadImagePalette(UmkaStackSlot *params, UmkaStackSlot *result) {
    Color * colors = (Color *)params[0].ptrVal;
    UnloadImagePalette(colors);
}

/**
 * Umka bindings for GetImageAlphaBorder().
 *
 * @see GetImageAlphaBorder()
 */
RAYLIB_UMKA_FUNCTION(GetImageAlphaBorder)
void umkaGetImageAlphaBorder(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Image* image = (Image*)&params[2];
    float threshold = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Rectangle), NULL);
    Rectangle out = GetImageAlphaBorder(*image, threshold);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Rectangle));
}

/**
 * Umka bindings for GetImageColor().
 *
 * @see GetImageColor()
 */
RAYLIB_UMKA_FUNCTION(GetImageColor)
void umkaGetImageColor(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Image* image = (Image*)&params[3];
    int x = params[2].intVal;
    int y = params[1].intVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Color), NULL);
    Color out = GetImageColor(*image, x, y);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Color));
}

/**
 * Umka bindings for ImageClearBackground().
 *
 * @see ImageClearBackground()
 */
RAYLIB_UMKA_FUNCTION(ImageClearBackground)
void umkaImageClearBackground(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * dst = (Image *)params[1].ptrVal;
    Color* color = (Color*)&params[0];
    ImageClearBackground(dst, *color);
}

/**
 * Umka bindings for ImageDrawPixel().
 *
 * @see ImageDrawPixel()
 */
RAYLIB_UMKA_FUNCTION(ImageDrawPixel)
void umkaImageDrawPixel(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * dst = (Image *)params[3].ptrVal;
    int posX = params[2].intVal;
    int posY = params[1].intVal;
    Color* color = (Color*)&params[0];
    ImageDrawPixel(dst, posX, posY, *color);
}

/**
 * Umka bindings for ImageDrawPixelV().
 *
 * @see ImageDrawPixelV()
 */
RAYLIB_UMKA_FUNCTION(ImageDrawPixelV)
void umkaImageDrawPixelV(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * dst = (Image *)params[2].ptrVal;
    Vector2* position = (Vector2*)&params[1];
    Color* color = (Color*)&params[0];
    ImageDrawPixelV(dst, *position, *color);
}

/**
 * Umka bindings for ImageDrawLine().
 *
 * @see ImageDrawLine()
 */
RAYLIB_UMKA_FUNCTION(ImageDrawLine)
void umkaImageDrawLine(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * dst = (Image *)params[5].ptrVal;
    int startPosX = params[4].intVal;
    int startPosY = params[3].intVal;
    int endPosX = params[2].intVal;
    int endPosY = params[1].intVal;
    Color* color = (Color*)&params[0];
    ImageDrawLine(dst, startPosX, startPosY, endPosX, endPosY, *color);
}

/**
 * Umka bindings for ImageDrawLineV().
 *
 * @see ImageDrawLineV()
 */
RAYLIB_UMKA_FUNCTION(ImageDrawLineV)
void umkaImageDrawLineV(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * dst = (Image *)params[3].ptrVal;
    Vector2* start = (Vector2*)&params[2];
    Vector2* end = (Vector2*)&params[1];
    Color* color = (Color*)&params[0];
    ImageDrawLineV(dst, *start, *end, *color);
}

/**
 * Umka bindings for ImageDrawCircle().
 *
 * @see ImageDrawCircle()
 */
RAYLIB_UMKA_FUNCTION(ImageDrawCircle)
void umkaImageDrawCircle(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * dst = (Image *)params[4].ptrVal;
    int centerX = params[3].intVal;
    int centerY = params[2].intVal;
    int radius = params[1].intVal;
    Color* color = (Color*)&params[0];
    ImageDrawCircle(dst, centerX, centerY, radius, *color);
}

/**
 * Umka bindings for ImageDrawCircleV().
 *
 * @see ImageDrawCircleV()
 */
RAYLIB_UMKA_FUNCTION(ImageDrawCircleV)
void umkaImageDrawCircleV(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * dst = (Image *)params[3].ptrVal;
    Vector2* center = (Vector2*)&params[2];
    int radius = params[1].intVal;
    Color* color = (Color*)&params[0];
    ImageDrawCircleV(dst, *center, radius, *color);
}

/**
 * Umka bindings for ImageDrawRectangle().
 *
 * @see ImageDrawRectangle()
 */
RAYLIB_UMKA_FUNCTION(ImageDrawRectangle)
void umkaImageDrawRectangle(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * dst = (Image *)params[5].ptrVal;
    int posX = params[4].intVal;
    int posY = params[3].intVal;
    int width = params[2].intVal;
    int height = params[1].intVal;
    Color* color = (Color*)&params[0];
    ImageDrawRectangle(dst, posX, posY, width, height, *color);
}

/**
 * Umka bindings for ImageDrawRectangleV().
 *
 * @see ImageDrawRectangleV()
 */
RAYLIB_UMKA_FUNCTION(ImageDrawRectangleV)
void umkaImageDrawRectangleV(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * dst = (Image *)params[3].ptrVal;
    Vector2* position = (Vector2*)&params[2];
    Vector2* size = (Vector2*)&params[1];
    Color* color = (Color*)&params[0];
    ImageDrawRectangleV(dst, *position, *size, *color);
}

/**
 * Umka bindings for ImageDrawRectangleRec().
 *
 * @see ImageDrawRectangleRec()
 */
RAYLIB_UMKA_FUNCTION(ImageDrawRectangleRec)
void umkaImageDrawRectangleRec(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * dst = (Image *)params[2].ptrVal;
    Rectangle* rec = (Rectangle*)&params[1];
    Color* color = (Color*)&params[0];
    ImageDrawRectangleRec(dst, *rec, *color);
}

/**
 * Umka bindings for ImageDrawRectangleLines().
 *
 * @see ImageDrawRectangleLines()
 */
RAYLIB_UMKA_FUNCTION(ImageDrawRectangleLines)
void umkaImageDrawRectangleLines(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * dst = (Image *)params[3].ptrVal;
    Rectangle* rec = (Rectangle*)&params[2];
    int thick = params[1].intVal;
    Color* color = (Color*)&params[0];
    ImageDrawRectangleLines(dst, *rec, thick, *color);
}

/**
 * Umka bindings for ImageDraw().
 *
 * @see ImageDraw()
 */
RAYLIB_UMKA_FUNCTION(ImageDraw)
void umkaImageDraw(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * dst = (Image *)params[4].ptrVal;
    Image* src = (Image*)&params[3];
    Rectangle* srcRec = (Rectangle*)&params[2];
    Rectangle* dstRec = (Rectangle*)&params[1];
    Color* tint = (Color*)&params[0];
    ImageDraw(dst, *src, *srcRec, *dstRec, *tint);
}

/**
 * Umka bindings for ImageDrawText().
 *
 * @see ImageDrawText()
 */
RAYLIB_UMKA_FUNCTION(ImageDrawText)
void umkaImageDrawText(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * dst = (Image *)params[5].ptrVal;
    const char * text = (const char *)params[4].ptrVal;
    int posX = params[3].intVal;
    int posY = params[2].intVal;
    int fontSize = params[1].intVal;
    Color* color = (Color*)&params[0];
    ImageDrawText(dst, text, posX, posY, fontSize, *color);
}

/**
 * Umka bindings for ImageDrawTextEx().
 *
 * @see ImageDrawTextEx()
 */
RAYLIB_UMKA_FUNCTION(ImageDrawTextEx)
void umkaImageDrawTextEx(UmkaStackSlot *params, UmkaStackSlot *result) {
    Image * dst = (Image *)params[6].ptrVal;
    Font* font = (Font*)&params[5];
    const char * text = (const char *)params[4].ptrVal;
    Vector2* position = (Vector2*)&params[3];
    float fontSize = params[2].real32Val;
    float spacing = params[1].real32Val;
    Color* tint = (Color*)&params[0];
    ImageDrawTextEx(dst, *font, text, *position, fontSize, spacing, *tint);
}

/**
 * Umka bindings for LoadTexture().
 *
 * @see LoadTexture()
 */
RAYLIB_UMKA_FUNCTION(LoadTexture)
void umkaLoadTexture(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    const char * fileName = (const char *)params[1].ptrVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Texture2D), NULL);
    Texture2D out = LoadTexture(fileName);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Texture2D));
}

/**
 * Umka bindings for LoadTextureFromImage().
 *
 * @see LoadTextureFromImage()
 */
RAYLIB_UMKA_FUNCTION(LoadTextureFromImage)
void umkaLoadTextureFromImage(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Image* image = (Image*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Texture2D), NULL);
    Texture2D out = LoadTextureFromImage(*image);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Texture2D));
}

/**
 * Umka bindings for LoadTextureCubemap().
 *
 * @see LoadTextureCubemap()
 */
RAYLIB_UMKA_FUNCTION(LoadTextureCubemap)
void umkaLoadTextureCubemap(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Image* image = (Image*)&params[2];
    int layout = params[1].intVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(TextureCubemap), NULL);
    TextureCubemap out = LoadTextureCubemap(*image, layout);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(TextureCubemap));
}

/**
 * Umka bindings for LoadRenderTexture().
 *
 * @see LoadRenderTexture()
 */
RAYLIB_UMKA_FUNCTION(LoadRenderTexture)
void umkaLoadRenderTexture(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    int width = params[2].intVal;
    int height = params[1].intVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(RenderTexture2D), NULL);
    RenderTexture2D out = LoadRenderTexture(width, height);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(RenderTexture2D));
}

/**
 * Umka bindings for UnloadTexture().
 *
 * @see UnloadTexture()
 */
RAYLIB_UMKA_FUNCTION(UnloadTexture)
void umkaUnloadTexture(UmkaStackSlot *params, UmkaStackSlot *result) {
    Texture2D* texture = (Texture2D*)&params[0];
    UnloadTexture(*texture);
}

/**
 * Umka bindings for UnloadRenderTexture().
 *
 * @see UnloadRenderTexture()
 */
RAYLIB_UMKA_FUNCTION(UnloadRenderTexture)
void umkaUnloadRenderTexture(UmkaStackSlot *params, UmkaStackSlot *result) {
    RenderTexture2D* target = (RenderTexture2D*)&params[0];
    UnloadRenderTexture(*target);
}

/**
 * Umka bindings for UpdateTexture().
 *
 * @see UpdateTexture()
 */
RAYLIB_UMKA_FUNCTION(UpdateTexture)
void umkaUpdateTexture(UmkaStackSlot *params, UmkaStackSlot *result) {
    Texture2D* texture = (Texture2D*)&params[1];
    const void * pixels = (const void *)params[0].ptrVal;
    UpdateTexture(*texture, pixels);
}

/**
 * Umka bindings for UpdateTextureRec().
 *
 * @see UpdateTextureRec()
 */
RAYLIB_UMKA_FUNCTION(UpdateTextureRec)
void umkaUpdateTextureRec(UmkaStackSlot *params, UmkaStackSlot *result) {
    Texture2D* texture = (Texture2D*)&params[2];
    Rectangle* rec = (Rectangle*)&params[1];
    const void * pixels = (const void *)params[0].ptrVal;
    UpdateTextureRec(*texture, *rec, pixels);
}

/**
 * Umka bindings for GenTextureMipmaps().
 *
 * @see GenTextureMipmaps()
 */
RAYLIB_UMKA_FUNCTION(GenTextureMipmaps)
void umkaGenTextureMipmaps(UmkaStackSlot *params, UmkaStackSlot *result) {
    Texture2D * texture = (Texture2D *)params[0].ptrVal;
    GenTextureMipmaps(texture);
}

/**
 * Umka bindings for SetTextureFilter().
 *
 * @see SetTextureFilter()
 */
RAYLIB_UMKA_FUNCTION(SetTextureFilter)
void umkaSetTextureFilter(UmkaStackSlot *params, UmkaStackSlot *result) {
    Texture2D* texture = (Texture2D*)&params[1];
    int filter = params[0].intVal;
    SetTextureFilter(*texture, filter);
}

/**
 * Umka bindings for SetTextureWrap().
 *
 * @see SetTextureWrap()
 */
RAYLIB_UMKA_FUNCTION(SetTextureWrap)
void umkaSetTextureWrap(UmkaStackSlot *params, UmkaStackSlot *result) {
    Texture2D* texture = (Texture2D*)&params[1];
    int wrap = params[0].intVal;
    SetTextureWrap(*texture, wrap);
}

/**
 * Umka bindings for DrawTexture().
 *
 * @see DrawTexture()
 */
RAYLIB_UMKA_FUNCTION(DrawTexture)
void umkaDrawTexture(UmkaStackSlot *params, UmkaStackSlot *result) {
    Texture2D* texture = (Texture2D*)&params[3];
    int posX = params[2].intVal;
    int posY = params[1].intVal;
    Color* tint = (Color*)&params[0];
    DrawTexture(*texture, posX, posY, *tint);
}

/**
 * Umka bindings for DrawTextureV().
 *
 * @see DrawTextureV()
 */
RAYLIB_UMKA_FUNCTION(DrawTextureV)
void umkaDrawTextureV(UmkaStackSlot *params, UmkaStackSlot *result) {
    Texture2D* texture = (Texture2D*)&params[2];
    Vector2* position = (Vector2*)&params[1];
    Color* tint = (Color*)&params[0];
    DrawTextureV(*texture, *position, *tint);
}

/**
 * Umka bindings for DrawTextureEx().
 *
 * @see DrawTextureEx()
 */
RAYLIB_UMKA_FUNCTION(DrawTextureEx)
void umkaDrawTextureEx(UmkaStackSlot *params, UmkaStackSlot *result) {
    Texture2D* texture = (Texture2D*)&params[4];
    Vector2* position = (Vector2*)&params[3];
    float rotation = params[2].real32Val;
    float scale = params[1].real32Val;
    Color* tint = (Color*)&params[0];
    DrawTextureEx(*texture, *position, rotation, scale, *tint);
}

/**
 * Umka bindings for DrawTextureRec().
 *
 * @see DrawTextureRec()
 */
RAYLIB_UMKA_FUNCTION(DrawTextureRec)
void umkaDrawTextureRec(UmkaStackSlot *params, UmkaStackSlot *result) {
    Texture2D* texture = (Texture2D*)&params[3];
    Rectangle* source = (Rectangle*)&params[2];
    Vector2* position = (Vector2*)&params[1];
    Color* tint = (Color*)&params[0];
    DrawTextureRec(*texture, *source, *position, *tint);
}

/**
 * Umka bindings for DrawTextureQuad().
 *
 * @see DrawTextureQuad()
 */
RAYLIB_UMKA_FUNCTION(DrawTextureQuad)
void umkaDrawTextureQuad(UmkaStackSlot *params, UmkaStackSlot *result) {
    Texture2D* texture = (Texture2D*)&params[4];
    Vector2* tiling = (Vector2*)&params[3];
    Vector2* offset = (Vector2*)&params[2];
    Rectangle* quad = (Rectangle*)&params[1];
    Color* tint = (Color*)&params[0];
    DrawTextureQuad(*texture, *tiling, *offset, *quad, *tint);
}

/**
 * Umka bindings for DrawTextureTiled().
 *
 * @see DrawTextureTiled()
 */
RAYLIB_UMKA_FUNCTION(DrawTextureTiled)
void umkaDrawTextureTiled(UmkaStackSlot *params, UmkaStackSlot *result) {
    Texture2D* texture = (Texture2D*)&params[6];
    Rectangle* source = (Rectangle*)&params[5];
    Rectangle* dest = (Rectangle*)&params[4];
    Vector2* origin = (Vector2*)&params[3];
    float rotation = params[2].real32Val;
    float scale = params[1].real32Val;
    Color* tint = (Color*)&params[0];
    DrawTextureTiled(*texture, *source, *dest, *origin, rotation, scale, *tint);
}

/**
 * Umka bindings for DrawTexturePro().
 *
 * @see DrawTexturePro()
 */
RAYLIB_UMKA_FUNCTION(DrawTexturePro)
void umkaDrawTexturePro(UmkaStackSlot *params, UmkaStackSlot *result) {
    Texture2D* texture = (Texture2D*)&params[5];
    Rectangle* source = (Rectangle*)&params[4];
    Rectangle* dest = (Rectangle*)&params[3];
    Vector2* origin = (Vector2*)&params[2];
    float rotation = params[1].real32Val;
    Color* tint = (Color*)&params[0];
    DrawTexturePro(*texture, *source, *dest, *origin, rotation, *tint);
}

/**
 * Umka bindings for DrawTextureNPatch().
 *
 * @see DrawTextureNPatch()
 */
RAYLIB_UMKA_FUNCTION(DrawTextureNPatch)
void umkaDrawTextureNPatch(UmkaStackSlot *params, UmkaStackSlot *result) {
    Texture2D* texture = (Texture2D*)&params[5];
    NPatchInfo* nPatchInfo = (NPatchInfo*)&params[4];
    Rectangle* dest = (Rectangle*)&params[3];
    Vector2* origin = (Vector2*)&params[2];
    float rotation = params[1].real32Val;
    Color* tint = (Color*)&params[0];
    DrawTextureNPatch(*texture, *nPatchInfo, *dest, *origin, rotation, *tint);
}

/**
 * Umka bindings for DrawTexturePoly().
 *
 * @see DrawTexturePoly()
 */
RAYLIB_UMKA_FUNCTION(DrawTexturePoly)
void umkaDrawTexturePoly(UmkaStackSlot *params, UmkaStackSlot *result) {
    Texture2D* texture = (Texture2D*)&params[5];
    Vector2* center = (Vector2*)&params[4];
    Vector2 * points = (Vector2 *)params[3].ptrVal;
    Vector2 * texcoords = (Vector2 *)params[2].ptrVal;
    int pointCount = params[1].intVal;
    Color* tint = (Color*)&params[0];
    DrawTexturePoly(*texture, *center, points, texcoords, pointCount, *tint);
}

/**
 * Umka bindings for Fade().
 *
 * @see Fade()
 */
RAYLIB_UMKA_FUNCTION(Fade)
void umkaFade(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Color* color = (Color*)&params[2];
    float alpha = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Color), NULL);
    Color out = Fade(*color, alpha);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Color));
}

/**
 * Umka bindings for ColorToInt().
 *
 * @see ColorToInt()
 */
RAYLIB_UMKA_FUNCTION(ColorToInt)
void umkaColorToInt(UmkaStackSlot *params, UmkaStackSlot *result) {
    Color* color = (Color*)&params[0];
    result->intVal = ColorToInt(*color);
}

/**
 * Umka bindings for ColorNormalize().
 *
 * @see ColorNormalize()
 */
RAYLIB_UMKA_FUNCTION(ColorNormalize)
void umkaColorNormalize(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Color* color = (Color*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector4), NULL);
    Vector4 out = ColorNormalize(*color);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector4));
}

/**
 * Umka bindings for ColorFromNormalized().
 *
 * @see ColorFromNormalized()
 */
RAYLIB_UMKA_FUNCTION(ColorFromNormalized)
void umkaColorFromNormalized(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector4* normalized = (Vector4*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Color), NULL);
    Color out = ColorFromNormalized(*normalized);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Color));
}

/**
 * Umka bindings for ColorToHSV().
 *
 * @see ColorToHSV()
 */
RAYLIB_UMKA_FUNCTION(ColorToHSV)
void umkaColorToHSV(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Color* color = (Color*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector3), NULL);
    Vector3 out = ColorToHSV(*color);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector3));
}

/**
 * Umka bindings for ColorFromHSV().
 *
 * @see ColorFromHSV()
 */
RAYLIB_UMKA_FUNCTION(ColorFromHSV)
void umkaColorFromHSV(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    float hue = params[3].real32Val;
    float saturation = params[2].real32Val;
    float value = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Color), NULL);
    Color out = ColorFromHSV(hue, saturation, value);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Color));
}

/**
 * Umka bindings for ColorAlpha().
 *
 * @see ColorAlpha()
 */
RAYLIB_UMKA_FUNCTION(ColorAlpha)
void umkaColorAlpha(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Color* color = (Color*)&params[2];
    float alpha = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Color), NULL);
    Color out = ColorAlpha(*color, alpha);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Color));
}

/**
 * Umka bindings for ColorAlphaBlend().
 *
 * @see ColorAlphaBlend()
 */
RAYLIB_UMKA_FUNCTION(ColorAlphaBlend)
void umkaColorAlphaBlend(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Color* dst = (Color*)&params[3];
    Color* src = (Color*)&params[2];
    Color* tint = (Color*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Color), NULL);
    Color out = ColorAlphaBlend(*dst, *src, *tint);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Color));
}

/**
 * Umka bindings for GetColor().
 *
 * @see GetColor()
 */
RAYLIB_UMKA_FUNCTION(GetColor)
void umkaGetColor(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    unsigned int hexValue = params[1].uintVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Color), NULL);
    Color out = GetColor(hexValue);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Color));
}

/**
 * Umka bindings for GetPixelColor().
 *
 * @see GetPixelColor()
 */
RAYLIB_UMKA_FUNCTION(GetPixelColor)
void umkaGetPixelColor(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    void * srcPtr = (void *)params[2].ptrVal;
    int format = params[1].intVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Color), NULL);
    Color out = GetPixelColor(srcPtr, format);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Color));
}

/**
 * Umka bindings for SetPixelColor().
 *
 * @see SetPixelColor()
 */
RAYLIB_UMKA_FUNCTION(SetPixelColor)
void umkaSetPixelColor(UmkaStackSlot *params, UmkaStackSlot *result) {
    void * dstPtr = (void *)params[2].ptrVal;
    Color* color = (Color*)&params[1];
    int format = params[0].intVal;
    SetPixelColor(dstPtr, *color, format);
}

/**
 * Umka bindings for GetPixelDataSize().
 *
 * @see GetPixelDataSize()
 */
RAYLIB_UMKA_FUNCTION(GetPixelDataSize)
void umkaGetPixelDataSize(UmkaStackSlot *params, UmkaStackSlot *result) {
    int width = params[2].intVal;
    int height = params[1].intVal;
    int format = params[0].intVal;
    result->intVal = GetPixelDataSize(width, height, format);
}

/**
 * Umka bindings for GetFontDefault().
 *
 * @see GetFontDefault()
 */
RAYLIB_UMKA_FUNCTION(GetFontDefault)
void umkaGetFontDefault(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Font), NULL);
    Font out = GetFontDefault();
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Font));
}

/**
 * Umka bindings for LoadFont().
 *
 * @see LoadFont()
 */
RAYLIB_UMKA_FUNCTION(LoadFont)
void umkaLoadFont(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    const char * fileName = (const char *)params[1].ptrVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Font), NULL);
    Font out = LoadFont(fileName);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Font));
}

/**
 * Umka bindings for LoadFontEx().
 *
 * @see LoadFontEx()
 */
RAYLIB_UMKA_FUNCTION(LoadFontEx)
void umkaLoadFontEx(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    const char * fileName = (const char *)params[4].ptrVal;
    int fontSize = params[3].intVal;
    int * fontChars = (int *)params[2].ptrVal;
    int glyphCount = params[1].intVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Font), NULL);
    Font out = LoadFontEx(fileName, fontSize, fontChars, glyphCount);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Font));
}

/**
 * Umka bindings for LoadFontFromImage().
 *
 * @see LoadFontFromImage()
 */
RAYLIB_UMKA_FUNCTION(LoadFontFromImage)
void umkaLoadFontFromImage(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Image* image = (Image*)&params[3];
    Color* key = (Color*)&params[2];
    int firstChar = params[1].intVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Font), NULL);
    Font out = LoadFontFromImage(*image, *key, firstChar);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Font));
}

/**
 * Umka bindings for LoadFontFromMemory().
 *
 * @see LoadFontFromMemory()
 */
RAYLIB_UMKA_FUNCTION(LoadFontFromMemory)
void umkaLoadFontFromMemory(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    const char * fileType = (const char *)params[6].ptrVal;
    const unsigned char * fileData = (const unsigned char *)params[5].ptrVal;
    int dataSize = params[4].intVal;
    int fontSize = params[3].intVal;
    int * fontChars = (int *)params[2].ptrVal;
    int glyphCount = params[1].intVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Font), NULL);
    Font out = LoadFontFromMemory(fileType, fileData, dataSize, fontSize, fontChars, glyphCount);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Font));
}

// Function LoadFontData() skipped

/**
 * Umka bindings for GenImageFontAtlas().
 *
 * @see GenImageFontAtlas()
 */
RAYLIB_UMKA_FUNCTION(GenImageFontAtlas)
void umkaGenImageFontAtlas(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    const GlyphInfo * chars = (const GlyphInfo *)params[6].ptrVal;
    Rectangle ** recs = (Rectangle **)params[5].ptrVal;
    int glyphCount = params[4].intVal;
    int fontSize = params[3].intVal;
    int padding = params[2].intVal;
    int packMethod = params[1].intVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Image), NULL);
    Image out = GenImageFontAtlas(chars, recs, glyphCount, fontSize, padding, packMethod);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Image));
}

/**
 * Umka bindings for UnloadFontData().
 *
 * @see UnloadFontData()
 */
RAYLIB_UMKA_FUNCTION(UnloadFontData)
void umkaUnloadFontData(UmkaStackSlot *params, UmkaStackSlot *result) {
    GlyphInfo * chars = (GlyphInfo *)params[1].ptrVal;
    int glyphCount = params[0].intVal;
    UnloadFontData(chars, glyphCount);
}

/**
 * Umka bindings for UnloadFont().
 *
 * @see UnloadFont()
 */
RAYLIB_UMKA_FUNCTION(UnloadFont)
void umkaUnloadFont(UmkaStackSlot *params, UmkaStackSlot *result) {
    Font* font = (Font*)&params[0];
    UnloadFont(*font);
}

/**
 * Umka bindings for ExportFontAsCode().
 *
 * @see ExportFontAsCode()
 */
RAYLIB_UMKA_FUNCTION(ExportFontAsCode)
void umkaExportFontAsCode(UmkaStackSlot *params, UmkaStackSlot *result) {
    Font* font = (Font*)&params[1];
    const char * fileName = (const char *)params[0].ptrVal;
    result->intVal = (int)ExportFontAsCode(*font, fileName);
}

/**
 * Umka bindings for DrawFPS().
 *
 * @see DrawFPS()
 */
RAYLIB_UMKA_FUNCTION(DrawFPS)
void umkaDrawFPS(UmkaStackSlot *params, UmkaStackSlot *result) {
    int posX = params[1].intVal;
    int posY = params[0].intVal;
    DrawFPS(posX, posY);
}

/**
 * Umka bindings for DrawText().
 *
 * @see DrawText()
 */
RAYLIB_UMKA_FUNCTION(DrawText)
void umkaDrawText(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * text = (const char *)params[4].ptrVal;
    int posX = params[3].intVal;
    int posY = params[2].intVal;
    int fontSize = params[1].intVal;
    Color* color = (Color*)&params[0];
    DrawText(text, posX, posY, fontSize, *color);
}

/**
 * Umka bindings for DrawTextEx().
 *
 * @see DrawTextEx()
 */
RAYLIB_UMKA_FUNCTION(DrawTextEx)
void umkaDrawTextEx(UmkaStackSlot *params, UmkaStackSlot *result) {
    Font* font = (Font*)&params[5];
    const char * text = (const char *)params[4].ptrVal;
    Vector2* position = (Vector2*)&params[3];
    float fontSize = params[2].real32Val;
    float spacing = params[1].real32Val;
    Color* tint = (Color*)&params[0];
    DrawTextEx(*font, text, *position, fontSize, spacing, *tint);
}

/**
 * Umka bindings for DrawTextPro().
 *
 * @see DrawTextPro()
 */
RAYLIB_UMKA_FUNCTION(DrawTextPro)
void umkaDrawTextPro(UmkaStackSlot *params, UmkaStackSlot *result) {
    Font* font = (Font*)&params[7];
    const char * text = (const char *)params[6].ptrVal;
    Vector2* position = (Vector2*)&params[5];
    Vector2* origin = (Vector2*)&params[4];
    float rotation = params[3].real32Val;
    float fontSize = params[2].real32Val;
    float spacing = params[1].real32Val;
    Color* tint = (Color*)&params[0];
    DrawTextPro(*font, text, *position, *origin, rotation, fontSize, spacing, *tint);
}

/**
 * Umka bindings for DrawTextCodepoint().
 *
 * @see DrawTextCodepoint()
 */
RAYLIB_UMKA_FUNCTION(DrawTextCodepoint)
void umkaDrawTextCodepoint(UmkaStackSlot *params, UmkaStackSlot *result) {
    Font* font = (Font*)&params[4];
    int codepoint = params[3].intVal;
    Vector2* position = (Vector2*)&params[2];
    float fontSize = params[1].real32Val;
    Color* tint = (Color*)&params[0];
    DrawTextCodepoint(*font, codepoint, *position, fontSize, *tint);
}

/**
 * Umka bindings for DrawTextCodepoints().
 *
 * @see DrawTextCodepoints()
 */
RAYLIB_UMKA_FUNCTION(DrawTextCodepoints)
void umkaDrawTextCodepoints(UmkaStackSlot *params, UmkaStackSlot *result) {
    Font* font = (Font*)&params[6];
    const int * codepoints = (const int *)params[5].ptrVal;
    int count = params[4].intVal;
    Vector2* position = (Vector2*)&params[3];
    float fontSize = params[2].real32Val;
    float spacing = params[1].real32Val;
    Color* tint = (Color*)&params[0];
    DrawTextCodepoints(*font, codepoints, count, *position, fontSize, spacing, *tint);
}

/**
 * Umka bindings for MeasureText().
 *
 * @see MeasureText()
 */
RAYLIB_UMKA_FUNCTION(MeasureText)
void umkaMeasureText(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * text = (const char *)params[1].ptrVal;
    int fontSize = params[0].intVal;
    result->intVal = MeasureText(text, fontSize);
}

/**
 * Umka bindings for MeasureTextEx().
 *
 * @see MeasureTextEx()
 */
RAYLIB_UMKA_FUNCTION(MeasureTextEx)
void umkaMeasureTextEx(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Font* font = (Font*)&params[4];
    const char * text = (const char *)params[3].ptrVal;
    float fontSize = params[2].real32Val;
    float spacing = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector2), NULL);
    Vector2 out = MeasureTextEx(*font, text, fontSize, spacing);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector2));
}

/**
 * Umka bindings for GetGlyphIndex().
 *
 * @see GetGlyphIndex()
 */
RAYLIB_UMKA_FUNCTION(GetGlyphIndex)
void umkaGetGlyphIndex(UmkaStackSlot *params, UmkaStackSlot *result) {
    Font* font = (Font*)&params[1];
    int codepoint = params[0].intVal;
    result->intVal = GetGlyphIndex(*font, codepoint);
}

/**
 * Umka bindings for GetGlyphInfo().
 *
 * @see GetGlyphInfo()
 */
RAYLIB_UMKA_FUNCTION(GetGlyphInfo)
void umkaGetGlyphInfo(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Font* font = (Font*)&params[2];
    int codepoint = params[1].intVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(GlyphInfo), NULL);
    GlyphInfo out = GetGlyphInfo(*font, codepoint);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(GlyphInfo));
}

/**
 * Umka bindings for GetGlyphAtlasRec().
 *
 * @see GetGlyphAtlasRec()
 */
RAYLIB_UMKA_FUNCTION(GetGlyphAtlasRec)
void umkaGetGlyphAtlasRec(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Font* font = (Font*)&params[2];
    int codepoint = params[1].intVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Rectangle), NULL);
    Rectangle out = GetGlyphAtlasRec(*font, codepoint);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Rectangle));
}

/**
 * Umka bindings for LoadCodepoints().
 *
 * @see LoadCodepoints()
 */
RAYLIB_UMKA_FUNCTION(LoadCodepoints)
void umkaLoadCodepoints(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * text = (const char *)params[1].ptrVal;
    int * count = (int *)params[0].ptrVal;
    result->ptrVal = (void*)LoadCodepoints(text, count);
}

/**
 * Umka bindings for UnloadCodepoints().
 *
 * @see UnloadCodepoints()
 */
RAYLIB_UMKA_FUNCTION(UnloadCodepoints)
void umkaUnloadCodepoints(UmkaStackSlot *params, UmkaStackSlot *result) {
    int * codepoints = (int *)params[0].ptrVal;
    UnloadCodepoints(codepoints);
}

/**
 * Umka bindings for GetCodepointCount().
 *
 * @see GetCodepointCount()
 */
RAYLIB_UMKA_FUNCTION(GetCodepointCount)
void umkaGetCodepointCount(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * text = (const char *)params[0].ptrVal;
    result->intVal = GetCodepointCount(text);
}

/**
 * Umka bindings for GetCodepoint().
 *
 * @see GetCodepoint()
 */
RAYLIB_UMKA_FUNCTION(GetCodepoint)
void umkaGetCodepoint(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * text = (const char *)params[1].ptrVal;
    int * bytesProcessed = (int *)params[0].ptrVal;
    result->intVal = GetCodepoint(text, bytesProcessed);
}

/**
 * Umka bindings for CodepointToUTF8().
 *
 * @see CodepointToUTF8()
 */
RAYLIB_UMKA_FUNCTION(CodepointToUTF8)
void umkaCodepointToUTF8(UmkaStackSlot *params, UmkaStackSlot *result) {
    int codepoint = params[1].intVal;
    int * byteSize = (int *)params[0].ptrVal;
    result->ptrVal = (void*)CodepointToUTF8(codepoint, byteSize);
}

/**
 * Umka bindings for TextCodepointsToUTF8().
 *
 * @see TextCodepointsToUTF8()
 */
RAYLIB_UMKA_FUNCTION(TextCodepointsToUTF8)
void umkaTextCodepointsToUTF8(UmkaStackSlot *params, UmkaStackSlot *result) {
    const int * codepoints = (const int *)params[1].ptrVal;
    int length = params[0].intVal;
    result->ptrVal = (void*)TextCodepointsToUTF8(codepoints, length);
}

/**
 * Umka bindings for TextCopy().
 *
 * @see TextCopy()
 */
RAYLIB_UMKA_FUNCTION(TextCopy)
void umkaTextCopy(UmkaStackSlot *params, UmkaStackSlot *result) {
    char * dst = (char *)params[1].ptrVal;
    const char * src = (const char *)params[0].ptrVal;
    result->intVal = TextCopy(dst, src);
}

/**
 * Umka bindings for TextIsEqual().
 *
 * @see TextIsEqual()
 */
RAYLIB_UMKA_FUNCTION(TextIsEqual)
void umkaTextIsEqual(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * text1 = (const char *)params[1].ptrVal;
    const char * text2 = (const char *)params[0].ptrVal;
    result->intVal = (int)TextIsEqual(text1, text2);
}

/**
 * Umka bindings for TextLength().
 *
 * @see TextLength()
 */
RAYLIB_UMKA_FUNCTION(TextLength)
void umkaTextLength(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * text = (const char *)params[0].ptrVal;
    result->uintVal = TextLength(text);
}

// Function TextFormat() skipped

/**
 * Umka bindings for TextSubtext().
 *
 * @see TextSubtext()
 */
RAYLIB_UMKA_FUNCTION(TextSubtext)
void umkaTextSubtext(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * text = (const char *)params[2].ptrVal;
    int position = params[1].intVal;
    int length = params[0].intVal;
    result->ptrVal = (void*)TextSubtext(text, position, length);
}

/**
 * Umka bindings for TextReplace().
 *
 * @see TextReplace()
 */
RAYLIB_UMKA_FUNCTION(TextReplace)
void umkaTextReplace(UmkaStackSlot *params, UmkaStackSlot *result) {
    char * text = (char *)params[2].ptrVal;
    const char * replace = (const char *)params[1].ptrVal;
    const char * by = (const char *)params[0].ptrVal;
    result->ptrVal = (void*)TextReplace(text, replace, by);
}

/**
 * Umka bindings for TextInsert().
 *
 * @see TextInsert()
 */
RAYLIB_UMKA_FUNCTION(TextInsert)
void umkaTextInsert(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * text = (const char *)params[2].ptrVal;
    const char * insert = (const char *)params[1].ptrVal;
    int position = params[0].intVal;
    result->ptrVal = (void*)TextInsert(text, insert, position);
}

/**
 * Umka bindings for TextJoin().
 *
 * @see TextJoin()
 */
RAYLIB_UMKA_FUNCTION(TextJoin)
void umkaTextJoin(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char ** textList = (const char **)params[2].ptrVal;
    int count = params[1].intVal;
    const char * delimiter = (const char *)params[0].ptrVal;
    result->ptrVal = (void*)TextJoin(textList, count, delimiter);
}

/**
 * Umka bindings for TextSplit().
 *
 * @see TextSplit()
 */
RAYLIB_UMKA_FUNCTION(TextSplit)
void umkaTextSplit(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * text = (const char *)params[2].ptrVal;
    char delimiter = params[1].uintVal;
    int * count = (int *)params[0].ptrVal;
    result->ptrVal = (void*)TextSplit(text, delimiter, count);
}

/**
 * Umka bindings for TextAppend().
 *
 * @see TextAppend()
 */
RAYLIB_UMKA_FUNCTION(TextAppend)
void umkaTextAppend(UmkaStackSlot *params, UmkaStackSlot *result) {
    char * text = (char *)params[2].ptrVal;
    const char * append = (const char *)params[1].ptrVal;
    int * position = (int *)params[0].ptrVal;
    TextAppend(text, append, position);
}

/**
 * Umka bindings for TextFindIndex().
 *
 * @see TextFindIndex()
 */
RAYLIB_UMKA_FUNCTION(TextFindIndex)
void umkaTextFindIndex(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * text = (const char *)params[1].ptrVal;
    const char * find = (const char *)params[0].ptrVal;
    result->intVal = TextFindIndex(text, find);
}

/**
 * Umka bindings for TextToUpper().
 *
 * @see TextToUpper()
 */
RAYLIB_UMKA_FUNCTION(TextToUpper)
void umkaTextToUpper(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * text = (const char *)params[0].ptrVal;
    result->ptrVal = (void*)TextToUpper(text);
}

/**
 * Umka bindings for TextToLower().
 *
 * @see TextToLower()
 */
RAYLIB_UMKA_FUNCTION(TextToLower)
void umkaTextToLower(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * text = (const char *)params[0].ptrVal;
    result->ptrVal = (void*)TextToLower(text);
}

/**
 * Umka bindings for TextToPascal().
 *
 * @see TextToPascal()
 */
RAYLIB_UMKA_FUNCTION(TextToPascal)
void umkaTextToPascal(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * text = (const char *)params[0].ptrVal;
    result->ptrVal = (void*)TextToPascal(text);
}

/**
 * Umka bindings for TextToInteger().
 *
 * @see TextToInteger()
 */
RAYLIB_UMKA_FUNCTION(TextToInteger)
void umkaTextToInteger(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * text = (const char *)params[0].ptrVal;
    result->intVal = TextToInteger(text);
}

/**
 * Umka bindings for DrawLine3D().
 *
 * @see DrawLine3D()
 */
RAYLIB_UMKA_FUNCTION(DrawLine3D)
void umkaDrawLine3D(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector3* startPos = (Vector3*)&params[2];
    Vector3* endPos = (Vector3*)&params[1];
    Color* color = (Color*)&params[0];
    DrawLine3D(*startPos, *endPos, *color);
}

/**
 * Umka bindings for DrawPoint3D().
 *
 * @see DrawPoint3D()
 */
RAYLIB_UMKA_FUNCTION(DrawPoint3D)
void umkaDrawPoint3D(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector3* position = (Vector3*)&params[1];
    Color* color = (Color*)&params[0];
    DrawPoint3D(*position, *color);
}

/**
 * Umka bindings for DrawCircle3D().
 *
 * @see DrawCircle3D()
 */
RAYLIB_UMKA_FUNCTION(DrawCircle3D)
void umkaDrawCircle3D(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector3* center = (Vector3*)&params[4];
    float radius = params[3].real32Val;
    Vector3* rotationAxis = (Vector3*)&params[2];
    float rotationAngle = params[1].real32Val;
    Color* color = (Color*)&params[0];
    DrawCircle3D(*center, radius, *rotationAxis, rotationAngle, *color);
}

/**
 * Umka bindings for DrawTriangle3D().
 *
 * @see DrawTriangle3D()
 */
RAYLIB_UMKA_FUNCTION(DrawTriangle3D)
void umkaDrawTriangle3D(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector3* v1 = (Vector3*)&params[3];
    Vector3* v2 = (Vector3*)&params[2];
    Vector3* v3 = (Vector3*)&params[1];
    Color* color = (Color*)&params[0];
    DrawTriangle3D(*v1, *v2, *v3, *color);
}

/**
 * Umka bindings for DrawTriangleStrip3D().
 *
 * @see DrawTriangleStrip3D()
 */
RAYLIB_UMKA_FUNCTION(DrawTriangleStrip3D)
void umkaDrawTriangleStrip3D(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector3 * points = (Vector3 *)params[2].ptrVal;
    int pointCount = params[1].intVal;
    Color* color = (Color*)&params[0];
    DrawTriangleStrip3D(points, pointCount, *color);
}

/**
 * Umka bindings for DrawCube().
 *
 * @see DrawCube()
 */
RAYLIB_UMKA_FUNCTION(DrawCube)
void umkaDrawCube(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector3* position = (Vector3*)&params[4];
    float width = params[3].real32Val;
    float height = params[2].real32Val;
    float length = params[1].real32Val;
    Color* color = (Color*)&params[0];
    DrawCube(*position, width, height, length, *color);
}

/**
 * Umka bindings for DrawCubeV().
 *
 * @see DrawCubeV()
 */
RAYLIB_UMKA_FUNCTION(DrawCubeV)
void umkaDrawCubeV(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector3* position = (Vector3*)&params[2];
    Vector3* size = (Vector3*)&params[1];
    Color* color = (Color*)&params[0];
    DrawCubeV(*position, *size, *color);
}

/**
 * Umka bindings for DrawCubeWires().
 *
 * @see DrawCubeWires()
 */
RAYLIB_UMKA_FUNCTION(DrawCubeWires)
void umkaDrawCubeWires(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector3* position = (Vector3*)&params[4];
    float width = params[3].real32Val;
    float height = params[2].real32Val;
    float length = params[1].real32Val;
    Color* color = (Color*)&params[0];
    DrawCubeWires(*position, width, height, length, *color);
}

/**
 * Umka bindings for DrawCubeWiresV().
 *
 * @see DrawCubeWiresV()
 */
RAYLIB_UMKA_FUNCTION(DrawCubeWiresV)
void umkaDrawCubeWiresV(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector3* position = (Vector3*)&params[2];
    Vector3* size = (Vector3*)&params[1];
    Color* color = (Color*)&params[0];
    DrawCubeWiresV(*position, *size, *color);
}

/**
 * Umka bindings for DrawCubeTexture().
 *
 * @see DrawCubeTexture()
 */
RAYLIB_UMKA_FUNCTION(DrawCubeTexture)
void umkaDrawCubeTexture(UmkaStackSlot *params, UmkaStackSlot *result) {
    Texture2D* texture = (Texture2D*)&params[5];
    Vector3* position = (Vector3*)&params[4];
    float width = params[3].real32Val;
    float height = params[2].real32Val;
    float length = params[1].real32Val;
    Color* color = (Color*)&params[0];
    DrawCubeTexture(*texture, *position, width, height, length, *color);
}

/**
 * Umka bindings for DrawCubeTextureRec().
 *
 * @see DrawCubeTextureRec()
 */
RAYLIB_UMKA_FUNCTION(DrawCubeTextureRec)
void umkaDrawCubeTextureRec(UmkaStackSlot *params, UmkaStackSlot *result) {
    Texture2D* texture = (Texture2D*)&params[6];
    Rectangle* source = (Rectangle*)&params[5];
    Vector3* position = (Vector3*)&params[4];
    float width = params[3].real32Val;
    float height = params[2].real32Val;
    float length = params[1].real32Val;
    Color* color = (Color*)&params[0];
    DrawCubeTextureRec(*texture, *source, *position, width, height, length, *color);
}

/**
 * Umka bindings for DrawSphere().
 *
 * @see DrawSphere()
 */
RAYLIB_UMKA_FUNCTION(DrawSphere)
void umkaDrawSphere(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector3* centerPos = (Vector3*)&params[2];
    float radius = params[1].real32Val;
    Color* color = (Color*)&params[0];
    DrawSphere(*centerPos, radius, *color);
}

/**
 * Umka bindings for DrawSphereEx().
 *
 * @see DrawSphereEx()
 */
RAYLIB_UMKA_FUNCTION(DrawSphereEx)
void umkaDrawSphereEx(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector3* centerPos = (Vector3*)&params[4];
    float radius = params[3].real32Val;
    int rings = params[2].intVal;
    int slices = params[1].intVal;
    Color* color = (Color*)&params[0];
    DrawSphereEx(*centerPos, radius, rings, slices, *color);
}

/**
 * Umka bindings for DrawSphereWires().
 *
 * @see DrawSphereWires()
 */
RAYLIB_UMKA_FUNCTION(DrawSphereWires)
void umkaDrawSphereWires(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector3* centerPos = (Vector3*)&params[4];
    float radius = params[3].real32Val;
    int rings = params[2].intVal;
    int slices = params[1].intVal;
    Color* color = (Color*)&params[0];
    DrawSphereWires(*centerPos, radius, rings, slices, *color);
}

/**
 * Umka bindings for DrawCylinder().
 *
 * @see DrawCylinder()
 */
RAYLIB_UMKA_FUNCTION(DrawCylinder)
void umkaDrawCylinder(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector3* position = (Vector3*)&params[5];
    float radiusTop = params[4].real32Val;
    float radiusBottom = params[3].real32Val;
    float height = params[2].real32Val;
    int slices = params[1].intVal;
    Color* color = (Color*)&params[0];
    DrawCylinder(*position, radiusTop, radiusBottom, height, slices, *color);
}

/**
 * Umka bindings for DrawCylinderEx().
 *
 * @see DrawCylinderEx()
 */
RAYLIB_UMKA_FUNCTION(DrawCylinderEx)
void umkaDrawCylinderEx(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector3* startPos = (Vector3*)&params[5];
    Vector3* endPos = (Vector3*)&params[4];
    float startRadius = params[3].real32Val;
    float endRadius = params[2].real32Val;
    int sides = params[1].intVal;
    Color* color = (Color*)&params[0];
    DrawCylinderEx(*startPos, *endPos, startRadius, endRadius, sides, *color);
}

/**
 * Umka bindings for DrawCylinderWires().
 *
 * @see DrawCylinderWires()
 */
RAYLIB_UMKA_FUNCTION(DrawCylinderWires)
void umkaDrawCylinderWires(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector3* position = (Vector3*)&params[5];
    float radiusTop = params[4].real32Val;
    float radiusBottom = params[3].real32Val;
    float height = params[2].real32Val;
    int slices = params[1].intVal;
    Color* color = (Color*)&params[0];
    DrawCylinderWires(*position, radiusTop, radiusBottom, height, slices, *color);
}

/**
 * Umka bindings for DrawCylinderWiresEx().
 *
 * @see DrawCylinderWiresEx()
 */
RAYLIB_UMKA_FUNCTION(DrawCylinderWiresEx)
void umkaDrawCylinderWiresEx(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector3* startPos = (Vector3*)&params[5];
    Vector3* endPos = (Vector3*)&params[4];
    float startRadius = params[3].real32Val;
    float endRadius = params[2].real32Val;
    int sides = params[1].intVal;
    Color* color = (Color*)&params[0];
    DrawCylinderWiresEx(*startPos, *endPos, startRadius, endRadius, sides, *color);
}

/**
 * Umka bindings for DrawPlane().
 *
 * @see DrawPlane()
 */
RAYLIB_UMKA_FUNCTION(DrawPlane)
void umkaDrawPlane(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector3* centerPos = (Vector3*)&params[2];
    Vector2* size = (Vector2*)&params[1];
    Color* color = (Color*)&params[0];
    DrawPlane(*centerPos, *size, *color);
}

/**
 * Umka bindings for DrawRay().
 *
 * @see DrawRay()
 */
RAYLIB_UMKA_FUNCTION(DrawRay)
void umkaDrawRay(UmkaStackSlot *params, UmkaStackSlot *result) {
    Ray* ray = (Ray*)&params[1];
    Color* color = (Color*)&params[0];
    DrawRay(*ray, *color);
}

/**
 * Umka bindings for DrawGrid().
 *
 * @see DrawGrid()
 */
RAYLIB_UMKA_FUNCTION(DrawGrid)
void umkaDrawGrid(UmkaStackSlot *params, UmkaStackSlot *result) {
    int slices = params[1].intVal;
    float spacing = params[0].real32Val;
    DrawGrid(slices, spacing);
}

/**
 * Umka bindings for LoadModel().
 *
 * @see LoadModel()
 */
RAYLIB_UMKA_FUNCTION(LoadModel)
void umkaLoadModel(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    const char * fileName = (const char *)params[1].ptrVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Model), NULL);
    Model out = LoadModel(fileName);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Model));
}

/**
 * Umka bindings for LoadModelFromMesh().
 *
 * @see LoadModelFromMesh()
 */
RAYLIB_UMKA_FUNCTION(LoadModelFromMesh)
void umkaLoadModelFromMesh(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Mesh* mesh = (Mesh*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Model), NULL);
    Model out = LoadModelFromMesh(*mesh);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Model));
}

/**
 * Umka bindings for UnloadModel().
 *
 * @see UnloadModel()
 */
RAYLIB_UMKA_FUNCTION(UnloadModel)
void umkaUnloadModel(UmkaStackSlot *params, UmkaStackSlot *result) {
    Model* model = (Model*)&params[0];
    UnloadModel(*model);
}

/**
 * Umka bindings for UnloadModelKeepMeshes().
 *
 * @see UnloadModelKeepMeshes()
 */
RAYLIB_UMKA_FUNCTION(UnloadModelKeepMeshes)
void umkaUnloadModelKeepMeshes(UmkaStackSlot *params, UmkaStackSlot *result) {
    Model* model = (Model*)&params[0];
    UnloadModelKeepMeshes(*model);
}

/**
 * Umka bindings for GetModelBoundingBox().
 *
 * @see GetModelBoundingBox()
 */
RAYLIB_UMKA_FUNCTION(GetModelBoundingBox)
void umkaGetModelBoundingBox(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Model* model = (Model*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(BoundingBox), NULL);
    BoundingBox out = GetModelBoundingBox(*model);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(BoundingBox));
}

/**
 * Umka bindings for DrawModel().
 *
 * @see DrawModel()
 */
RAYLIB_UMKA_FUNCTION(DrawModel)
void umkaDrawModel(UmkaStackSlot *params, UmkaStackSlot *result) {
    Model* model = (Model*)&params[3];
    Vector3* position = (Vector3*)&params[2];
    float scale = params[1].real32Val;
    Color* tint = (Color*)&params[0];
    DrawModel(*model, *position, scale, *tint);
}

/**
 * Umka bindings for DrawModelEx().
 *
 * @see DrawModelEx()
 */
RAYLIB_UMKA_FUNCTION(DrawModelEx)
void umkaDrawModelEx(UmkaStackSlot *params, UmkaStackSlot *result) {
    Model* model = (Model*)&params[5];
    Vector3* position = (Vector3*)&params[4];
    Vector3* rotationAxis = (Vector3*)&params[3];
    float rotationAngle = params[2].real32Val;
    Vector3* scale = (Vector3*)&params[1];
    Color* tint = (Color*)&params[0];
    DrawModelEx(*model, *position, *rotationAxis, rotationAngle, *scale, *tint);
}

/**
 * Umka bindings for DrawModelWires().
 *
 * @see DrawModelWires()
 */
RAYLIB_UMKA_FUNCTION(DrawModelWires)
void umkaDrawModelWires(UmkaStackSlot *params, UmkaStackSlot *result) {
    Model* model = (Model*)&params[3];
    Vector3* position = (Vector3*)&params[2];
    float scale = params[1].real32Val;
    Color* tint = (Color*)&params[0];
    DrawModelWires(*model, *position, scale, *tint);
}

/**
 * Umka bindings for DrawModelWiresEx().
 *
 * @see DrawModelWiresEx()
 */
RAYLIB_UMKA_FUNCTION(DrawModelWiresEx)
void umkaDrawModelWiresEx(UmkaStackSlot *params, UmkaStackSlot *result) {
    Model* model = (Model*)&params[5];
    Vector3* position = (Vector3*)&params[4];
    Vector3* rotationAxis = (Vector3*)&params[3];
    float rotationAngle = params[2].real32Val;
    Vector3* scale = (Vector3*)&params[1];
    Color* tint = (Color*)&params[0];
    DrawModelWiresEx(*model, *position, *rotationAxis, rotationAngle, *scale, *tint);
}

/**
 * Umka bindings for DrawBoundingBox().
 *
 * @see DrawBoundingBox()
 */
RAYLIB_UMKA_FUNCTION(DrawBoundingBox)
void umkaDrawBoundingBox(UmkaStackSlot *params, UmkaStackSlot *result) {
    BoundingBox* box = (BoundingBox*)&params[1];
    Color* color = (Color*)&params[0];
    DrawBoundingBox(*box, *color);
}

/**
 * Umka bindings for DrawBillboard().
 *
 * @see DrawBillboard()
 */
RAYLIB_UMKA_FUNCTION(DrawBillboard)
void umkaDrawBillboard(UmkaStackSlot *params, UmkaStackSlot *result) {
    Camera* camera = (Camera*)&params[4];
    Texture2D* texture = (Texture2D*)&params[3];
    Vector3* position = (Vector3*)&params[2];
    float size = params[1].real32Val;
    Color* tint = (Color*)&params[0];
    DrawBillboard(*camera, *texture, *position, size, *tint);
}

/**
 * Umka bindings for DrawBillboardRec().
 *
 * @see DrawBillboardRec()
 */
RAYLIB_UMKA_FUNCTION(DrawBillboardRec)
void umkaDrawBillboardRec(UmkaStackSlot *params, UmkaStackSlot *result) {
    Camera* camera = (Camera*)&params[5];
    Texture2D* texture = (Texture2D*)&params[4];
    Rectangle* source = (Rectangle*)&params[3];
    Vector3* position = (Vector3*)&params[2];
    Vector2* size = (Vector2*)&params[1];
    Color* tint = (Color*)&params[0];
    DrawBillboardRec(*camera, *texture, *source, *position, *size, *tint);
}

/**
 * Umka bindings for DrawBillboardPro().
 *
 * @see DrawBillboardPro()
 */
RAYLIB_UMKA_FUNCTION(DrawBillboardPro)
void umkaDrawBillboardPro(UmkaStackSlot *params, UmkaStackSlot *result) {
    Camera* camera = (Camera*)&params[8];
    Texture2D* texture = (Texture2D*)&params[7];
    Rectangle* source = (Rectangle*)&params[6];
    Vector3* position = (Vector3*)&params[5];
    Vector3* up = (Vector3*)&params[4];
    Vector2* size = (Vector2*)&params[3];
    Vector2* origin = (Vector2*)&params[2];
    float rotation = params[1].real32Val;
    Color* tint = (Color*)&params[0];
    DrawBillboardPro(*camera, *texture, *source, *position, *up, *size, *origin, rotation, *tint);
}

/**
 * Umka bindings for UploadMesh().
 *
 * @see UploadMesh()
 */
RAYLIB_UMKA_FUNCTION(UploadMesh)
void umkaUploadMesh(UmkaStackSlot *params, UmkaStackSlot *result) {
    Mesh * mesh = (Mesh *)params[1].ptrVal;
    bool dynamic = (bool)params[0].intVal;
    UploadMesh(mesh, dynamic);
}

/**
 * Umka bindings for UpdateMeshBuffer().
 *
 * @see UpdateMeshBuffer()
 */
RAYLIB_UMKA_FUNCTION(UpdateMeshBuffer)
void umkaUpdateMeshBuffer(UmkaStackSlot *params, UmkaStackSlot *result) {
    Mesh* mesh = (Mesh*)&params[4];
    int index = params[3].intVal;
    const void * data = (const void *)params[2].ptrVal;
    int dataSize = params[1].intVal;
    int offset = params[0].intVal;
    UpdateMeshBuffer(*mesh, index, data, dataSize, offset);
}

/**
 * Umka bindings for UnloadMesh().
 *
 * @see UnloadMesh()
 */
RAYLIB_UMKA_FUNCTION(UnloadMesh)
void umkaUnloadMesh(UmkaStackSlot *params, UmkaStackSlot *result) {
    Mesh* mesh = (Mesh*)&params[0];
    UnloadMesh(*mesh);
}

/**
 * Umka bindings for DrawMesh().
 *
 * @see DrawMesh()
 */
RAYLIB_UMKA_FUNCTION(DrawMesh)
void umkaDrawMesh(UmkaStackSlot *params, UmkaStackSlot *result) {
    Mesh* mesh = (Mesh*)&params[2];
    Material* material = (Material*)&params[1];
    Matrix* transform = (Matrix*)&params[0];
    DrawMesh(*mesh, *material, *transform);
}

/**
 * Umka bindings for DrawMeshInstanced().
 *
 * @see DrawMeshInstanced()
 */
RAYLIB_UMKA_FUNCTION(DrawMeshInstanced)
void umkaDrawMeshInstanced(UmkaStackSlot *params, UmkaStackSlot *result) {
    Mesh* mesh = (Mesh*)&params[3];
    Material* material = (Material*)&params[2];
    const Matrix * transforms = (const Matrix *)params[1].ptrVal;
    int instances = params[0].intVal;
    DrawMeshInstanced(*mesh, *material, transforms, instances);
}

/**
 * Umka bindings for ExportMesh().
 *
 * @see ExportMesh()
 */
RAYLIB_UMKA_FUNCTION(ExportMesh)
void umkaExportMesh(UmkaStackSlot *params, UmkaStackSlot *result) {
    Mesh* mesh = (Mesh*)&params[1];
    const char * fileName = (const char *)params[0].ptrVal;
    result->intVal = (int)ExportMesh(*mesh, fileName);
}

/**
 * Umka bindings for GetMeshBoundingBox().
 *
 * @see GetMeshBoundingBox()
 */
RAYLIB_UMKA_FUNCTION(GetMeshBoundingBox)
void umkaGetMeshBoundingBox(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Mesh* mesh = (Mesh*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(BoundingBox), NULL);
    BoundingBox out = GetMeshBoundingBox(*mesh);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(BoundingBox));
}

/**
 * Umka bindings for GenMeshTangents().
 *
 * @see GenMeshTangents()
 */
RAYLIB_UMKA_FUNCTION(GenMeshTangents)
void umkaGenMeshTangents(UmkaStackSlot *params, UmkaStackSlot *result) {
    Mesh * mesh = (Mesh *)params[0].ptrVal;
    GenMeshTangents(mesh);
}

/**
 * Umka bindings for GenMeshPoly().
 *
 * @see GenMeshPoly()
 */
RAYLIB_UMKA_FUNCTION(GenMeshPoly)
void umkaGenMeshPoly(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    int sides = params[2].intVal;
    float radius = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Mesh), NULL);
    Mesh out = GenMeshPoly(sides, radius);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Mesh));
}

/**
 * Umka bindings for GenMeshPlane().
 *
 * @see GenMeshPlane()
 */
RAYLIB_UMKA_FUNCTION(GenMeshPlane)
void umkaGenMeshPlane(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    float width = params[4].real32Val;
    float length = params[3].real32Val;
    int resX = params[2].intVal;
    int resZ = params[1].intVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Mesh), NULL);
    Mesh out = GenMeshPlane(width, length, resX, resZ);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Mesh));
}

/**
 * Umka bindings for GenMeshCube().
 *
 * @see GenMeshCube()
 */
RAYLIB_UMKA_FUNCTION(GenMeshCube)
void umkaGenMeshCube(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    float width = params[3].real32Val;
    float height = params[2].real32Val;
    float length = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Mesh), NULL);
    Mesh out = GenMeshCube(width, height, length);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Mesh));
}

/**
 * Umka bindings for GenMeshSphere().
 *
 * @see GenMeshSphere()
 */
RAYLIB_UMKA_FUNCTION(GenMeshSphere)
void umkaGenMeshSphere(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    float radius = params[3].real32Val;
    int rings = params[2].intVal;
    int slices = params[1].intVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Mesh), NULL);
    Mesh out = GenMeshSphere(radius, rings, slices);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Mesh));
}

/**
 * Umka bindings for GenMeshHemiSphere().
 *
 * @see GenMeshHemiSphere()
 */
RAYLIB_UMKA_FUNCTION(GenMeshHemiSphere)
void umkaGenMeshHemiSphere(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    float radius = params[3].real32Val;
    int rings = params[2].intVal;
    int slices = params[1].intVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Mesh), NULL);
    Mesh out = GenMeshHemiSphere(radius, rings, slices);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Mesh));
}

/**
 * Umka bindings for GenMeshCylinder().
 *
 * @see GenMeshCylinder()
 */
RAYLIB_UMKA_FUNCTION(GenMeshCylinder)
void umkaGenMeshCylinder(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    float radius = params[3].real32Val;
    float height = params[2].real32Val;
    int slices = params[1].intVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Mesh), NULL);
    Mesh out = GenMeshCylinder(radius, height, slices);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Mesh));
}

/**
 * Umka bindings for GenMeshCone().
 *
 * @see GenMeshCone()
 */
RAYLIB_UMKA_FUNCTION(GenMeshCone)
void umkaGenMeshCone(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    float radius = params[3].real32Val;
    float height = params[2].real32Val;
    int slices = params[1].intVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Mesh), NULL);
    Mesh out = GenMeshCone(radius, height, slices);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Mesh));
}

/**
 * Umka bindings for GenMeshTorus().
 *
 * @see GenMeshTorus()
 */
RAYLIB_UMKA_FUNCTION(GenMeshTorus)
void umkaGenMeshTorus(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    float radius = params[4].real32Val;
    float size = params[3].real32Val;
    int radSeg = params[2].intVal;
    int sides = params[1].intVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Mesh), NULL);
    Mesh out = GenMeshTorus(radius, size, radSeg, sides);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Mesh));
}

/**
 * Umka bindings for GenMeshKnot().
 *
 * @see GenMeshKnot()
 */
RAYLIB_UMKA_FUNCTION(GenMeshKnot)
void umkaGenMeshKnot(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    float radius = params[4].real32Val;
    float size = params[3].real32Val;
    int radSeg = params[2].intVal;
    int sides = params[1].intVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Mesh), NULL);
    Mesh out = GenMeshKnot(radius, size, radSeg, sides);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Mesh));
}

/**
 * Umka bindings for GenMeshHeightmap().
 *
 * @see GenMeshHeightmap()
 */
RAYLIB_UMKA_FUNCTION(GenMeshHeightmap)
void umkaGenMeshHeightmap(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Image* heightmap = (Image*)&params[2];
    Vector3* size = (Vector3*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Mesh), NULL);
    Mesh out = GenMeshHeightmap(*heightmap, *size);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Mesh));
}

/**
 * Umka bindings for GenMeshCubicmap().
 *
 * @see GenMeshCubicmap()
 */
RAYLIB_UMKA_FUNCTION(GenMeshCubicmap)
void umkaGenMeshCubicmap(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Image* cubicmap = (Image*)&params[2];
    Vector3* cubeSize = (Vector3*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Mesh), NULL);
    Mesh out = GenMeshCubicmap(*cubicmap, *cubeSize);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Mesh));
}

/**
 * Umka bindings for LoadMaterials().
 *
 * @see LoadMaterials()
 */
RAYLIB_UMKA_FUNCTION(LoadMaterials)
void umkaLoadMaterials(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * fileName = (const char *)params[1].ptrVal;
    int * materialCount = (int *)params[0].ptrVal;
    result->ptrVal = (void*)LoadMaterials(fileName, materialCount);
}

/**
 * Umka bindings for LoadMaterialDefault().
 *
 * @see LoadMaterialDefault()
 */
RAYLIB_UMKA_FUNCTION(LoadMaterialDefault)
void umkaLoadMaterialDefault(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Material), NULL);
    Material out = LoadMaterialDefault();
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Material));
}

/**
 * Umka bindings for UnloadMaterial().
 *
 * @see UnloadMaterial()
 */
RAYLIB_UMKA_FUNCTION(UnloadMaterial)
void umkaUnloadMaterial(UmkaStackSlot *params, UmkaStackSlot *result) {
    Material* material = (Material*)&params[0];
    UnloadMaterial(*material);
}

/**
 * Umka bindings for SetMaterialTexture().
 *
 * @see SetMaterialTexture()
 */
RAYLIB_UMKA_FUNCTION(SetMaterialTexture)
void umkaSetMaterialTexture(UmkaStackSlot *params, UmkaStackSlot *result) {
    Material * material = (Material *)params[2].ptrVal;
    int mapType = params[1].intVal;
    Texture2D* texture = (Texture2D*)&params[0];
    SetMaterialTexture(material, mapType, *texture);
}

/**
 * Umka bindings for SetModelMeshMaterial().
 *
 * @see SetModelMeshMaterial()
 */
RAYLIB_UMKA_FUNCTION(SetModelMeshMaterial)
void umkaSetModelMeshMaterial(UmkaStackSlot *params, UmkaStackSlot *result) {
    Model * model = (Model *)params[2].ptrVal;
    int meshId = params[1].intVal;
    int materialId = params[0].intVal;
    SetModelMeshMaterial(model, meshId, materialId);
}

/**
 * Umka bindings for LoadModelAnimations().
 *
 * @see LoadModelAnimations()
 */
RAYLIB_UMKA_FUNCTION(LoadModelAnimations)
void umkaLoadModelAnimations(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * fileName = (const char *)params[1].ptrVal;
    unsigned int * animCount = (unsigned int *)params[0].ptrVal;
    result->ptrVal = (void*)LoadModelAnimations(fileName, animCount);
}

/**
 * Umka bindings for UpdateModelAnimation().
 *
 * @see UpdateModelAnimation()
 */
RAYLIB_UMKA_FUNCTION(UpdateModelAnimation)
void umkaUpdateModelAnimation(UmkaStackSlot *params, UmkaStackSlot *result) {
    Model* model = (Model*)&params[2];
    ModelAnimation* anim = (ModelAnimation*)&params[1];
    int frame = params[0].intVal;
    UpdateModelAnimation(*model, *anim, frame);
}

/**
 * Umka bindings for UnloadModelAnimation().
 *
 * @see UnloadModelAnimation()
 */
RAYLIB_UMKA_FUNCTION(UnloadModelAnimation)
void umkaUnloadModelAnimation(UmkaStackSlot *params, UmkaStackSlot *result) {
    ModelAnimation* anim = (ModelAnimation*)&params[0];
    UnloadModelAnimation(*anim);
}

/**
 * Umka bindings for UnloadModelAnimations().
 *
 * @see UnloadModelAnimations()
 */
RAYLIB_UMKA_FUNCTION(UnloadModelAnimations)
void umkaUnloadModelAnimations(UmkaStackSlot *params, UmkaStackSlot *result) {
    ModelAnimation * animations = (ModelAnimation *)params[1].ptrVal;
    unsigned int count = params[0].uintVal;
    UnloadModelAnimations(animations, count);
}

/**
 * Umka bindings for IsModelAnimationValid().
 *
 * @see IsModelAnimationValid()
 */
RAYLIB_UMKA_FUNCTION(IsModelAnimationValid)
void umkaIsModelAnimationValid(UmkaStackSlot *params, UmkaStackSlot *result) {
    Model* model = (Model*)&params[1];
    ModelAnimation* anim = (ModelAnimation*)&params[0];
    result->intVal = (int)IsModelAnimationValid(*model, *anim);
}

/**
 * Umka bindings for CheckCollisionSpheres().
 *
 * @see CheckCollisionSpheres()
 */
RAYLIB_UMKA_FUNCTION(CheckCollisionSpheres)
void umkaCheckCollisionSpheres(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector3* center1 = (Vector3*)&params[3];
    float radius1 = params[2].real32Val;
    Vector3* center2 = (Vector3*)&params[1];
    float radius2 = params[0].real32Val;
    result->intVal = (int)CheckCollisionSpheres(*center1, radius1, *center2, radius2);
}

/**
 * Umka bindings for CheckCollisionBoxes().
 *
 * @see CheckCollisionBoxes()
 */
RAYLIB_UMKA_FUNCTION(CheckCollisionBoxes)
void umkaCheckCollisionBoxes(UmkaStackSlot *params, UmkaStackSlot *result) {
    BoundingBox* box1 = (BoundingBox*)&params[1];
    BoundingBox* box2 = (BoundingBox*)&params[0];
    result->intVal = (int)CheckCollisionBoxes(*box1, *box2);
}

/**
 * Umka bindings for CheckCollisionBoxSphere().
 *
 * @see CheckCollisionBoxSphere()
 */
RAYLIB_UMKA_FUNCTION(CheckCollisionBoxSphere)
void umkaCheckCollisionBoxSphere(UmkaStackSlot *params, UmkaStackSlot *result) {
    BoundingBox* box = (BoundingBox*)&params[2];
    Vector3* center = (Vector3*)&params[1];
    float radius = params[0].real32Val;
    result->intVal = (int)CheckCollisionBoxSphere(*box, *center, radius);
}

/**
 * Umka bindings for GetRayCollisionSphere().
 *
 * @see GetRayCollisionSphere()
 */
RAYLIB_UMKA_FUNCTION(GetRayCollisionSphere)
void umkaGetRayCollisionSphere(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Ray* ray = (Ray*)&params[3];
    Vector3* center = (Vector3*)&params[2];
    float radius = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(RayCollision), NULL);
    RayCollision out = GetRayCollisionSphere(*ray, *center, radius);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(RayCollision));
}

/**
 * Umka bindings for GetRayCollisionBox().
 *
 * @see GetRayCollisionBox()
 */
RAYLIB_UMKA_FUNCTION(GetRayCollisionBox)
void umkaGetRayCollisionBox(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Ray* ray = (Ray*)&params[2];
    BoundingBox* box = (BoundingBox*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(RayCollision), NULL);
    RayCollision out = GetRayCollisionBox(*ray, *box);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(RayCollision));
}

/**
 * Umka bindings for GetRayCollisionMesh().
 *
 * @see GetRayCollisionMesh()
 */
RAYLIB_UMKA_FUNCTION(GetRayCollisionMesh)
void umkaGetRayCollisionMesh(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Ray* ray = (Ray*)&params[3];
    Mesh* mesh = (Mesh*)&params[2];
    Matrix* transform = (Matrix*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(RayCollision), NULL);
    RayCollision out = GetRayCollisionMesh(*ray, *mesh, *transform);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(RayCollision));
}

/**
 * Umka bindings for GetRayCollisionTriangle().
 *
 * @see GetRayCollisionTriangle()
 */
RAYLIB_UMKA_FUNCTION(GetRayCollisionTriangle)
void umkaGetRayCollisionTriangle(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Ray* ray = (Ray*)&params[4];
    Vector3* p1 = (Vector3*)&params[3];
    Vector3* p2 = (Vector3*)&params[2];
    Vector3* p3 = (Vector3*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(RayCollision), NULL);
    RayCollision out = GetRayCollisionTriangle(*ray, *p1, *p2, *p3);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(RayCollision));
}

/**
 * Umka bindings for GetRayCollisionQuad().
 *
 * @see GetRayCollisionQuad()
 */
RAYLIB_UMKA_FUNCTION(GetRayCollisionQuad)
void umkaGetRayCollisionQuad(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Ray* ray = (Ray*)&params[5];
    Vector3* p1 = (Vector3*)&params[4];
    Vector3* p2 = (Vector3*)&params[3];
    Vector3* p3 = (Vector3*)&params[2];
    Vector3* p4 = (Vector3*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(RayCollision), NULL);
    RayCollision out = GetRayCollisionQuad(*ray, *p1, *p2, *p3, *p4);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(RayCollision));
}

/**
 * Umka bindings for InitAudioDevice().
 *
 * @see InitAudioDevice()
 */
RAYLIB_UMKA_FUNCTION(InitAudioDevice)
void umkaInitAudioDevice(UmkaStackSlot *params, UmkaStackSlot *result) {
    InitAudioDevice();
}

/**
 * Umka bindings for CloseAudioDevice().
 *
 * @see CloseAudioDevice()
 */
RAYLIB_UMKA_FUNCTION(CloseAudioDevice)
void umkaCloseAudioDevice(UmkaStackSlot *params, UmkaStackSlot *result) {
    CloseAudioDevice();
}

/**
 * Umka bindings for IsAudioDeviceReady().
 *
 * @see IsAudioDeviceReady()
 */
RAYLIB_UMKA_FUNCTION(IsAudioDeviceReady)
void umkaIsAudioDeviceReady(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->intVal = (int)IsAudioDeviceReady();
}

/**
 * Umka bindings for SetMasterVolume().
 *
 * @see SetMasterVolume()
 */
RAYLIB_UMKA_FUNCTION(SetMasterVolume)
void umkaSetMasterVolume(UmkaStackSlot *params, UmkaStackSlot *result) {
    float volume = params[0].real32Val;
    SetMasterVolume(volume);
}

/**
 * Umka bindings for LoadWave().
 *
 * @see LoadWave()
 */
RAYLIB_UMKA_FUNCTION(LoadWave)
void umkaLoadWave(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    const char * fileName = (const char *)params[1].ptrVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Wave), NULL);
    Wave out = LoadWave(fileName);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Wave));
}

/**
 * Umka bindings for LoadWaveFromMemory().
 *
 * @see LoadWaveFromMemory()
 */
RAYLIB_UMKA_FUNCTION(LoadWaveFromMemory)
void umkaLoadWaveFromMemory(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    const char * fileType = (const char *)params[3].ptrVal;
    const unsigned char * fileData = (const unsigned char *)params[2].ptrVal;
    int dataSize = params[1].intVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Wave), NULL);
    Wave out = LoadWaveFromMemory(fileType, fileData, dataSize);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Wave));
}

/**
 * Umka bindings for LoadSound().
 *
 * @see LoadSound()
 */
RAYLIB_UMKA_FUNCTION(LoadSound)
void umkaLoadSound(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    const char * fileName = (const char *)params[1].ptrVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Sound), NULL);
    Sound out = LoadSound(fileName);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Sound));
}

/**
 * Umka bindings for LoadSoundFromWave().
 *
 * @see LoadSoundFromWave()
 */
RAYLIB_UMKA_FUNCTION(LoadSoundFromWave)
void umkaLoadSoundFromWave(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Wave* wave = (Wave*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Sound), NULL);
    Sound out = LoadSoundFromWave(*wave);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Sound));
}

/**
 * Umka bindings for UpdateSound().
 *
 * @see UpdateSound()
 */
RAYLIB_UMKA_FUNCTION(UpdateSound)
void umkaUpdateSound(UmkaStackSlot *params, UmkaStackSlot *result) {
    Sound* sound = (Sound*)&params[2];
    const void * data = (const void *)params[1].ptrVal;
    int sampleCount = params[0].intVal;
    UpdateSound(*sound, data, sampleCount);
}

/**
 * Umka bindings for UnloadWave().
 *
 * @see UnloadWave()
 */
RAYLIB_UMKA_FUNCTION(UnloadWave)
void umkaUnloadWave(UmkaStackSlot *params, UmkaStackSlot *result) {
    Wave* wave = (Wave*)&params[0];
    UnloadWave(*wave);
}

/**
 * Umka bindings for UnloadSound().
 *
 * @see UnloadSound()
 */
RAYLIB_UMKA_FUNCTION(UnloadSound)
void umkaUnloadSound(UmkaStackSlot *params, UmkaStackSlot *result) {
    Sound* sound = (Sound*)&params[0];
    UnloadSound(*sound);
}

/**
 * Umka bindings for ExportWave().
 *
 * @see ExportWave()
 */
RAYLIB_UMKA_FUNCTION(ExportWave)
void umkaExportWave(UmkaStackSlot *params, UmkaStackSlot *result) {
    Wave* wave = (Wave*)&params[1];
    const char * fileName = (const char *)params[0].ptrVal;
    result->intVal = (int)ExportWave(*wave, fileName);
}

/**
 * Umka bindings for ExportWaveAsCode().
 *
 * @see ExportWaveAsCode()
 */
RAYLIB_UMKA_FUNCTION(ExportWaveAsCode)
void umkaExportWaveAsCode(UmkaStackSlot *params, UmkaStackSlot *result) {
    Wave* wave = (Wave*)&params[1];
    const char * fileName = (const char *)params[0].ptrVal;
    result->intVal = (int)ExportWaveAsCode(*wave, fileName);
}

/**
 * Umka bindings for PlaySound().
 *
 * @see PlaySound()
 */
RAYLIB_UMKA_FUNCTION(PlaySound)
void umkaPlaySound(UmkaStackSlot *params, UmkaStackSlot *result) {
    Sound* sound = (Sound*)&params[0];
    PlaySound(*sound);
}

/**
 * Umka bindings for StopSound().
 *
 * @see StopSound()
 */
RAYLIB_UMKA_FUNCTION(StopSound)
void umkaStopSound(UmkaStackSlot *params, UmkaStackSlot *result) {
    Sound* sound = (Sound*)&params[0];
    StopSound(*sound);
}

/**
 * Umka bindings for PauseSound().
 *
 * @see PauseSound()
 */
RAYLIB_UMKA_FUNCTION(PauseSound)
void umkaPauseSound(UmkaStackSlot *params, UmkaStackSlot *result) {
    Sound* sound = (Sound*)&params[0];
    PauseSound(*sound);
}

/**
 * Umka bindings for ResumeSound().
 *
 * @see ResumeSound()
 */
RAYLIB_UMKA_FUNCTION(ResumeSound)
void umkaResumeSound(UmkaStackSlot *params, UmkaStackSlot *result) {
    Sound* sound = (Sound*)&params[0];
    ResumeSound(*sound);
}

/**
 * Umka bindings for PlaySoundMulti().
 *
 * @see PlaySoundMulti()
 */
RAYLIB_UMKA_FUNCTION(PlaySoundMulti)
void umkaPlaySoundMulti(UmkaStackSlot *params, UmkaStackSlot *result) {
    Sound* sound = (Sound*)&params[0];
    PlaySoundMulti(*sound);
}

/**
 * Umka bindings for StopSoundMulti().
 *
 * @see StopSoundMulti()
 */
RAYLIB_UMKA_FUNCTION(StopSoundMulti)
void umkaStopSoundMulti(UmkaStackSlot *params, UmkaStackSlot *result) {
    StopSoundMulti();
}

/**
 * Umka bindings for GetSoundsPlaying().
 *
 * @see GetSoundsPlaying()
 */
RAYLIB_UMKA_FUNCTION(GetSoundsPlaying)
void umkaGetSoundsPlaying(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->intVal = GetSoundsPlaying();
}

/**
 * Umka bindings for IsSoundPlaying().
 *
 * @see IsSoundPlaying()
 */
RAYLIB_UMKA_FUNCTION(IsSoundPlaying)
void umkaIsSoundPlaying(UmkaStackSlot *params, UmkaStackSlot *result) {
    Sound* sound = (Sound*)&params[0];
    result->intVal = (int)IsSoundPlaying(*sound);
}

/**
 * Umka bindings for SetSoundVolume().
 *
 * @see SetSoundVolume()
 */
RAYLIB_UMKA_FUNCTION(SetSoundVolume)
void umkaSetSoundVolume(UmkaStackSlot *params, UmkaStackSlot *result) {
    Sound* sound = (Sound*)&params[1];
    float volume = params[0].real32Val;
    SetSoundVolume(*sound, volume);
}

/**
 * Umka bindings for SetSoundPitch().
 *
 * @see SetSoundPitch()
 */
RAYLIB_UMKA_FUNCTION(SetSoundPitch)
void umkaSetSoundPitch(UmkaStackSlot *params, UmkaStackSlot *result) {
    Sound* sound = (Sound*)&params[1];
    float pitch = params[0].real32Val;
    SetSoundPitch(*sound, pitch);
}

/**
 * Umka bindings for SetSoundPan().
 *
 * @see SetSoundPan()
 */
RAYLIB_UMKA_FUNCTION(SetSoundPan)
void umkaSetSoundPan(UmkaStackSlot *params, UmkaStackSlot *result) {
    Sound* sound = (Sound*)&params[1];
    float pan = params[0].real32Val;
    SetSoundPan(*sound, pan);
}

/**
 * Umka bindings for WaveCopy().
 *
 * @see WaveCopy()
 */
RAYLIB_UMKA_FUNCTION(WaveCopy)
void umkaWaveCopy(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Wave* wave = (Wave*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Wave), NULL);
    Wave out = WaveCopy(*wave);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Wave));
}

/**
 * Umka bindings for WaveCrop().
 *
 * @see WaveCrop()
 */
RAYLIB_UMKA_FUNCTION(WaveCrop)
void umkaWaveCrop(UmkaStackSlot *params, UmkaStackSlot *result) {
    Wave * wave = (Wave *)params[2].ptrVal;
    int initSample = params[1].intVal;
    int finalSample = params[0].intVal;
    WaveCrop(wave, initSample, finalSample);
}

/**
 * Umka bindings for WaveFormat().
 *
 * @see WaveFormat()
 */
RAYLIB_UMKA_FUNCTION(WaveFormat)
void umkaWaveFormat(UmkaStackSlot *params, UmkaStackSlot *result) {
    Wave * wave = (Wave *)params[3].ptrVal;
    int sampleRate = params[2].intVal;
    int sampleSize = params[1].intVal;
    int channels = params[0].intVal;
    WaveFormat(wave, sampleRate, sampleSize, channels);
}

/**
 * Umka bindings for LoadWaveSamples().
 *
 * @see LoadWaveSamples()
 */
RAYLIB_UMKA_FUNCTION(LoadWaveSamples)
void umkaLoadWaveSamples(UmkaStackSlot *params, UmkaStackSlot *result) {
    Wave* wave = (Wave*)&params[0];
    result->ptrVal = (void*)LoadWaveSamples(*wave);
}

/**
 * Umka bindings for UnloadWaveSamples().
 *
 * @see UnloadWaveSamples()
 */
RAYLIB_UMKA_FUNCTION(UnloadWaveSamples)
void umkaUnloadWaveSamples(UmkaStackSlot *params, UmkaStackSlot *result) {
    float * samples = (float *)params[0].ptrVal;
    UnloadWaveSamples(samples);
}

/**
 * Umka bindings for LoadMusicStream().
 *
 * @see LoadMusicStream()
 */
RAYLIB_UMKA_FUNCTION(LoadMusicStream)
void umkaLoadMusicStream(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    const char * fileName = (const char *)params[1].ptrVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Music), NULL);
    Music out = LoadMusicStream(fileName);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Music));
}

/**
 * Umka bindings for LoadMusicStreamFromMemory().
 *
 * @see LoadMusicStreamFromMemory()
 */
RAYLIB_UMKA_FUNCTION(LoadMusicStreamFromMemory)
void umkaLoadMusicStreamFromMemory(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    const char * fileType = (const char *)params[3].ptrVal;
    const unsigned char * data = (const unsigned char *)params[2].ptrVal;
    int dataSize = params[1].intVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Music), NULL);
    Music out = LoadMusicStreamFromMemory(fileType, data, dataSize);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Music));
}

/**
 * Umka bindings for UnloadMusicStream().
 *
 * @see UnloadMusicStream()
 */
RAYLIB_UMKA_FUNCTION(UnloadMusicStream)
void umkaUnloadMusicStream(UmkaStackSlot *params, UmkaStackSlot *result) {
    Music* music = (Music*)&params[0];
    UnloadMusicStream(*music);
}

/**
 * Umka bindings for PlayMusicStream().
 *
 * @see PlayMusicStream()
 */
RAYLIB_UMKA_FUNCTION(PlayMusicStream)
void umkaPlayMusicStream(UmkaStackSlot *params, UmkaStackSlot *result) {
    Music* music = (Music*)&params[0];
    PlayMusicStream(*music);
}

/**
 * Umka bindings for IsMusicStreamPlaying().
 *
 * @see IsMusicStreamPlaying()
 */
RAYLIB_UMKA_FUNCTION(IsMusicStreamPlaying)
void umkaIsMusicStreamPlaying(UmkaStackSlot *params, UmkaStackSlot *result) {
    Music* music = (Music*)&params[0];
    result->intVal = (int)IsMusicStreamPlaying(*music);
}

/**
 * Umka bindings for UpdateMusicStream().
 *
 * @see UpdateMusicStream()
 */
RAYLIB_UMKA_FUNCTION(UpdateMusicStream)
void umkaUpdateMusicStream(UmkaStackSlot *params, UmkaStackSlot *result) {
    Music* music = (Music*)&params[0];
    UpdateMusicStream(*music);
}

/**
 * Umka bindings for StopMusicStream().
 *
 * @see StopMusicStream()
 */
RAYLIB_UMKA_FUNCTION(StopMusicStream)
void umkaStopMusicStream(UmkaStackSlot *params, UmkaStackSlot *result) {
    Music* music = (Music*)&params[0];
    StopMusicStream(*music);
}

/**
 * Umka bindings for PauseMusicStream().
 *
 * @see PauseMusicStream()
 */
RAYLIB_UMKA_FUNCTION(PauseMusicStream)
void umkaPauseMusicStream(UmkaStackSlot *params, UmkaStackSlot *result) {
    Music* music = (Music*)&params[0];
    PauseMusicStream(*music);
}

/**
 * Umka bindings for ResumeMusicStream().
 *
 * @see ResumeMusicStream()
 */
RAYLIB_UMKA_FUNCTION(ResumeMusicStream)
void umkaResumeMusicStream(UmkaStackSlot *params, UmkaStackSlot *result) {
    Music* music = (Music*)&params[0];
    ResumeMusicStream(*music);
}

/**
 * Umka bindings for SeekMusicStream().
 *
 * @see SeekMusicStream()
 */
RAYLIB_UMKA_FUNCTION(SeekMusicStream)
void umkaSeekMusicStream(UmkaStackSlot *params, UmkaStackSlot *result) {
    Music* music = (Music*)&params[1];
    float position = params[0].real32Val;
    SeekMusicStream(*music, position);
}

/**
 * Umka bindings for SetMusicVolume().
 *
 * @see SetMusicVolume()
 */
RAYLIB_UMKA_FUNCTION(SetMusicVolume)
void umkaSetMusicVolume(UmkaStackSlot *params, UmkaStackSlot *result) {
    Music* music = (Music*)&params[1];
    float volume = params[0].real32Val;
    SetMusicVolume(*music, volume);
}

/**
 * Umka bindings for SetMusicPitch().
 *
 * @see SetMusicPitch()
 */
RAYLIB_UMKA_FUNCTION(SetMusicPitch)
void umkaSetMusicPitch(UmkaStackSlot *params, UmkaStackSlot *result) {
    Music* music = (Music*)&params[1];
    float pitch = params[0].real32Val;
    SetMusicPitch(*music, pitch);
}

/**
 * Umka bindings for SetMusicPan().
 *
 * @see SetMusicPan()
 */
RAYLIB_UMKA_FUNCTION(SetMusicPan)
void umkaSetMusicPan(UmkaStackSlot *params, UmkaStackSlot *result) {
    Music* music = (Music*)&params[1];
    float pan = params[0].real32Val;
    SetMusicPan(*music, pan);
}

/**
 * Umka bindings for GetMusicTimeLength().
 *
 * @see GetMusicTimeLength()
 */
RAYLIB_UMKA_FUNCTION(GetMusicTimeLength)
void umkaGetMusicTimeLength(UmkaStackSlot *params, UmkaStackSlot *result) {
    Music* music = (Music*)&params[0];
    result->realVal = GetMusicTimeLength(*music);
}

/**
 * Umka bindings for GetMusicTimePlayed().
 *
 * @see GetMusicTimePlayed()
 */
RAYLIB_UMKA_FUNCTION(GetMusicTimePlayed)
void umkaGetMusicTimePlayed(UmkaStackSlot *params, UmkaStackSlot *result) {
    Music* music = (Music*)&params[0];
    result->realVal = GetMusicTimePlayed(*music);
}

/**
 * Umka bindings for LoadAudioStream().
 *
 * @see LoadAudioStream()
 */
RAYLIB_UMKA_FUNCTION(LoadAudioStream)
void umkaLoadAudioStream(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    unsigned int sampleRate = params[3].uintVal;
    unsigned int sampleSize = params[2].uintVal;
    unsigned int channels = params[1].uintVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(AudioStream), NULL);
    AudioStream out = LoadAudioStream(sampleRate, sampleSize, channels);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(AudioStream));
}

/**
 * Umka bindings for UnloadAudioStream().
 *
 * @see UnloadAudioStream()
 */
RAYLIB_UMKA_FUNCTION(UnloadAudioStream)
void umkaUnloadAudioStream(UmkaStackSlot *params, UmkaStackSlot *result) {
    AudioStream* stream = (AudioStream*)&params[0];
    UnloadAudioStream(*stream);
}

/**
 * Umka bindings for UpdateAudioStream().
 *
 * @see UpdateAudioStream()
 */
RAYLIB_UMKA_FUNCTION(UpdateAudioStream)
void umkaUpdateAudioStream(UmkaStackSlot *params, UmkaStackSlot *result) {
    AudioStream* stream = (AudioStream*)&params[2];
    const void * data = (const void *)params[1].ptrVal;
    int frameCount = params[0].intVal;
    UpdateAudioStream(*stream, data, frameCount);
}

/**
 * Umka bindings for IsAudioStreamProcessed().
 *
 * @see IsAudioStreamProcessed()
 */
RAYLIB_UMKA_FUNCTION(IsAudioStreamProcessed)
void umkaIsAudioStreamProcessed(UmkaStackSlot *params, UmkaStackSlot *result) {
    AudioStream* stream = (AudioStream*)&params[0];
    result->intVal = (int)IsAudioStreamProcessed(*stream);
}

/**
 * Umka bindings for PlayAudioStream().
 *
 * @see PlayAudioStream()
 */
RAYLIB_UMKA_FUNCTION(PlayAudioStream)
void umkaPlayAudioStream(UmkaStackSlot *params, UmkaStackSlot *result) {
    AudioStream* stream = (AudioStream*)&params[0];
    PlayAudioStream(*stream);
}

/**
 * Umka bindings for PauseAudioStream().
 *
 * @see PauseAudioStream()
 */
RAYLIB_UMKA_FUNCTION(PauseAudioStream)
void umkaPauseAudioStream(UmkaStackSlot *params, UmkaStackSlot *result) {
    AudioStream* stream = (AudioStream*)&params[0];
    PauseAudioStream(*stream);
}

/**
 * Umka bindings for ResumeAudioStream().
 *
 * @see ResumeAudioStream()
 */
RAYLIB_UMKA_FUNCTION(ResumeAudioStream)
void umkaResumeAudioStream(UmkaStackSlot *params, UmkaStackSlot *result) {
    AudioStream* stream = (AudioStream*)&params[0];
    ResumeAudioStream(*stream);
}

/**
 * Umka bindings for IsAudioStreamPlaying().
 *
 * @see IsAudioStreamPlaying()
 */
RAYLIB_UMKA_FUNCTION(IsAudioStreamPlaying)
void umkaIsAudioStreamPlaying(UmkaStackSlot *params, UmkaStackSlot *result) {
    AudioStream* stream = (AudioStream*)&params[0];
    result->intVal = (int)IsAudioStreamPlaying(*stream);
}

/**
 * Umka bindings for StopAudioStream().
 *
 * @see StopAudioStream()
 */
RAYLIB_UMKA_FUNCTION(StopAudioStream)
void umkaStopAudioStream(UmkaStackSlot *params, UmkaStackSlot *result) {
    AudioStream* stream = (AudioStream*)&params[0];
    StopAudioStream(*stream);
}

/**
 * Umka bindings for SetAudioStreamVolume().
 *
 * @see SetAudioStreamVolume()
 */
RAYLIB_UMKA_FUNCTION(SetAudioStreamVolume)
void umkaSetAudioStreamVolume(UmkaStackSlot *params, UmkaStackSlot *result) {
    AudioStream* stream = (AudioStream*)&params[1];
    float volume = params[0].real32Val;
    SetAudioStreamVolume(*stream, volume);
}

/**
 * Umka bindings for SetAudioStreamPitch().
 *
 * @see SetAudioStreamPitch()
 */
RAYLIB_UMKA_FUNCTION(SetAudioStreamPitch)
void umkaSetAudioStreamPitch(UmkaStackSlot *params, UmkaStackSlot *result) {
    AudioStream* stream = (AudioStream*)&params[1];
    float pitch = params[0].real32Val;
    SetAudioStreamPitch(*stream, pitch);
}

/**
 * Umka bindings for SetAudioStreamPan().
 *
 * @see SetAudioStreamPan()
 */
RAYLIB_UMKA_FUNCTION(SetAudioStreamPan)
void umkaSetAudioStreamPan(UmkaStackSlot *params, UmkaStackSlot *result) {
    AudioStream* stream = (AudioStream*)&params[1];
    float pan = params[0].real32Val;
    SetAudioStreamPan(*stream, pan);
}

/**
 * Umka bindings for SetAudioStreamBufferSizeDefault().
 *
 * @see SetAudioStreamBufferSizeDefault()
 */
RAYLIB_UMKA_FUNCTION(SetAudioStreamBufferSizeDefault)
void umkaSetAudioStreamBufferSizeDefault(UmkaStackSlot *params, UmkaStackSlot *result) {
    int size = params[0].intVal;
    SetAudioStreamBufferSizeDefault(size);
}

// Function SetAudioStreamCallback() skipped

// Function AttachAudioStreamProcessor() skipped

// Function DetachAudioStreamProcessor() skipped

/**
 * Umka bindings for Clamp().
 *
 * @see Clamp()
 */
RAYLIB_UMKA_FUNCTION(Clamp)
void umkaClamp(UmkaStackSlot *params, UmkaStackSlot *result) {
    float value = params[2].real32Val;
    float min = params[1].real32Val;
    float max = params[0].real32Val;
    result->realVal = Clamp(value, min, max);
}

/**
 * Umka bindings for Lerp().
 *
 * @see Lerp()
 */
RAYLIB_UMKA_FUNCTION(Lerp)
void umkaLerp(UmkaStackSlot *params, UmkaStackSlot *result) {
    float start = params[2].real32Val;
    float end = params[1].real32Val;
    float amount = params[0].real32Val;
    result->realVal = Lerp(start, end, amount);
}

/**
 * Umka bindings for Normalize().
 *
 * @see Normalize()
 */
RAYLIB_UMKA_FUNCTION(Normalize)
void umkaNormalize(UmkaStackSlot *params, UmkaStackSlot *result) {
    float value = params[2].real32Val;
    float start = params[1].real32Val;
    float end = params[0].real32Val;
    result->realVal = Normalize(value, start, end);
}

/**
 * Umka bindings for Remap().
 *
 * @see Remap()
 */
RAYLIB_UMKA_FUNCTION(Remap)
void umkaRemap(UmkaStackSlot *params, UmkaStackSlot *result) {
    float value = params[4].real32Val;
    float inputStart = params[3].real32Val;
    float inputEnd = params[2].real32Val;
    float outputStart = params[1].real32Val;
    float outputEnd = params[0].real32Val;
    result->realVal = Remap(value, inputStart, inputEnd, outputStart, outputEnd);
}

/**
 * Umka bindings for Wrap().
 *
 * @see Wrap()
 */
RAYLIB_UMKA_FUNCTION(Wrap)
void umkaWrap(UmkaStackSlot *params, UmkaStackSlot *result) {
    float value = params[2].real32Val;
    float min = params[1].real32Val;
    float max = params[0].real32Val;
    result->realVal = Wrap(value, min, max);
}

/**
 * Umka bindings for FloatEquals().
 *
 * @see FloatEquals()
 */
RAYLIB_UMKA_FUNCTION(FloatEquals)
void umkaFloatEquals(UmkaStackSlot *params, UmkaStackSlot *result) {
    float x = params[1].real32Val;
    float y = params[0].real32Val;
    result->intVal = FloatEquals(x, y);
}

/**
 * Umka bindings for Vector2Zero().
 *
 * @see Vector2Zero()
 */
RAYLIB_UMKA_FUNCTION(Vector2Zero)
void umkaVector2Zero(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector2), NULL);
    Vector2 out = Vector2Zero();
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector2));
}

/**
 * Umka bindings for Vector2One().
 *
 * @see Vector2One()
 */
RAYLIB_UMKA_FUNCTION(Vector2One)
void umkaVector2One(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector2), NULL);
    Vector2 out = Vector2One();
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector2));
}

/**
 * Umka bindings for Vector2Add().
 *
 * @see Vector2Add()
 */
RAYLIB_UMKA_FUNCTION(Vector2Add)
void umkaVector2Add(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector2* v1 = (Vector2*)&params[2];
    Vector2* v2 = (Vector2*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector2), NULL);
    Vector2 out = Vector2Add(*v1, *v2);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector2));
}

/**
 * Umka bindings for Vector2AddValue().
 *
 * @see Vector2AddValue()
 */
RAYLIB_UMKA_FUNCTION(Vector2AddValue)
void umkaVector2AddValue(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector2* v = (Vector2*)&params[2];
    float add = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector2), NULL);
    Vector2 out = Vector2AddValue(*v, add);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector2));
}

/**
 * Umka bindings for Vector2Subtract().
 *
 * @see Vector2Subtract()
 */
RAYLIB_UMKA_FUNCTION(Vector2Subtract)
void umkaVector2Subtract(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector2* v1 = (Vector2*)&params[2];
    Vector2* v2 = (Vector2*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector2), NULL);
    Vector2 out = Vector2Subtract(*v1, *v2);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector2));
}

/**
 * Umka bindings for Vector2SubtractValue().
 *
 * @see Vector2SubtractValue()
 */
RAYLIB_UMKA_FUNCTION(Vector2SubtractValue)
void umkaVector2SubtractValue(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector2* v = (Vector2*)&params[2];
    float sub = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector2), NULL);
    Vector2 out = Vector2SubtractValue(*v, sub);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector2));
}

/**
 * Umka bindings for Vector2Length().
 *
 * @see Vector2Length()
 */
RAYLIB_UMKA_FUNCTION(Vector2Length)
void umkaVector2Length(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2* v = (Vector2*)&params[0];
    result->realVal = Vector2Length(*v);
}

/**
 * Umka bindings for Vector2LengthSqr().
 *
 * @see Vector2LengthSqr()
 */
RAYLIB_UMKA_FUNCTION(Vector2LengthSqr)
void umkaVector2LengthSqr(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2* v = (Vector2*)&params[0];
    result->realVal = Vector2LengthSqr(*v);
}

/**
 * Umka bindings for Vector2DotProduct().
 *
 * @see Vector2DotProduct()
 */
RAYLIB_UMKA_FUNCTION(Vector2DotProduct)
void umkaVector2DotProduct(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2* v1 = (Vector2*)&params[1];
    Vector2* v2 = (Vector2*)&params[0];
    result->realVal = Vector2DotProduct(*v1, *v2);
}

/**
 * Umka bindings for Vector2Distance().
 *
 * @see Vector2Distance()
 */
RAYLIB_UMKA_FUNCTION(Vector2Distance)
void umkaVector2Distance(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2* v1 = (Vector2*)&params[1];
    Vector2* v2 = (Vector2*)&params[0];
    result->realVal = Vector2Distance(*v1, *v2);
}

/**
 * Umka bindings for Vector2DistanceSqr().
 *
 * @see Vector2DistanceSqr()
 */
RAYLIB_UMKA_FUNCTION(Vector2DistanceSqr)
void umkaVector2DistanceSqr(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2* v1 = (Vector2*)&params[1];
    Vector2* v2 = (Vector2*)&params[0];
    result->realVal = Vector2DistanceSqr(*v1, *v2);
}

/**
 * Umka bindings for Vector2Angle().
 *
 * @see Vector2Angle()
 */
RAYLIB_UMKA_FUNCTION(Vector2Angle)
void umkaVector2Angle(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2* v1 = (Vector2*)&params[1];
    Vector2* v2 = (Vector2*)&params[0];
    result->realVal = Vector2Angle(*v1, *v2);
}

/**
 * Umka bindings for Vector2Scale().
 *
 * @see Vector2Scale()
 */
RAYLIB_UMKA_FUNCTION(Vector2Scale)
void umkaVector2Scale(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector2* v = (Vector2*)&params[2];
    float scale = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector2), NULL);
    Vector2 out = Vector2Scale(*v, scale);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector2));
}

/**
 * Umka bindings for Vector2Multiply().
 *
 * @see Vector2Multiply()
 */
RAYLIB_UMKA_FUNCTION(Vector2Multiply)
void umkaVector2Multiply(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector2* v1 = (Vector2*)&params[2];
    Vector2* v2 = (Vector2*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector2), NULL);
    Vector2 out = Vector2Multiply(*v1, *v2);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector2));
}

/**
 * Umka bindings for Vector2Negate().
 *
 * @see Vector2Negate()
 */
RAYLIB_UMKA_FUNCTION(Vector2Negate)
void umkaVector2Negate(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector2* v = (Vector2*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector2), NULL);
    Vector2 out = Vector2Negate(*v);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector2));
}

/**
 * Umka bindings for Vector2Divide().
 *
 * @see Vector2Divide()
 */
RAYLIB_UMKA_FUNCTION(Vector2Divide)
void umkaVector2Divide(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector2* v1 = (Vector2*)&params[2];
    Vector2* v2 = (Vector2*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector2), NULL);
    Vector2 out = Vector2Divide(*v1, *v2);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector2));
}

/**
 * Umka bindings for Vector2Normalize().
 *
 * @see Vector2Normalize()
 */
RAYLIB_UMKA_FUNCTION(Vector2Normalize)
void umkaVector2Normalize(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector2* v = (Vector2*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector2), NULL);
    Vector2 out = Vector2Normalize(*v);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector2));
}

/**
 * Umka bindings for Vector2Transform().
 *
 * @see Vector2Transform()
 */
RAYLIB_UMKA_FUNCTION(Vector2Transform)
void umkaVector2Transform(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector2* v = (Vector2*)&params[2];
    Matrix* mat = (Matrix*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector2), NULL);
    Vector2 out = Vector2Transform(*v, *mat);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector2));
}

/**
 * Umka bindings for Vector2Lerp().
 *
 * @see Vector2Lerp()
 */
RAYLIB_UMKA_FUNCTION(Vector2Lerp)
void umkaVector2Lerp(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector2* v1 = (Vector2*)&params[3];
    Vector2* v2 = (Vector2*)&params[2];
    float amount = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector2), NULL);
    Vector2 out = Vector2Lerp(*v1, *v2, amount);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector2));
}

/**
 * Umka bindings for Vector2Reflect().
 *
 * @see Vector2Reflect()
 */
RAYLIB_UMKA_FUNCTION(Vector2Reflect)
void umkaVector2Reflect(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector2* v = (Vector2*)&params[2];
    Vector2* normal = (Vector2*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector2), NULL);
    Vector2 out = Vector2Reflect(*v, *normal);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector2));
}

/**
 * Umka bindings for Vector2Rotate().
 *
 * @see Vector2Rotate()
 */
RAYLIB_UMKA_FUNCTION(Vector2Rotate)
void umkaVector2Rotate(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector2* v = (Vector2*)&params[2];
    float angle = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector2), NULL);
    Vector2 out = Vector2Rotate(*v, angle);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector2));
}

/**
 * Umka bindings for Vector2MoveTowards().
 *
 * @see Vector2MoveTowards()
 */
RAYLIB_UMKA_FUNCTION(Vector2MoveTowards)
void umkaVector2MoveTowards(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector2* v = (Vector2*)&params[3];
    Vector2* target = (Vector2*)&params[2];
    float maxDistance = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector2), NULL);
    Vector2 out = Vector2MoveTowards(*v, *target, maxDistance);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector2));
}

/**
 * Umka bindings for Vector2Invert().
 *
 * @see Vector2Invert()
 */
RAYLIB_UMKA_FUNCTION(Vector2Invert)
void umkaVector2Invert(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector2* v = (Vector2*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector2), NULL);
    Vector2 out = Vector2Invert(*v);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector2));
}

/**
 * Umka bindings for Vector2Clamp().
 *
 * @see Vector2Clamp()
 */
RAYLIB_UMKA_FUNCTION(Vector2Clamp)
void umkaVector2Clamp(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector2* v = (Vector2*)&params[3];
    Vector2* min = (Vector2*)&params[2];
    Vector2* max = (Vector2*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector2), NULL);
    Vector2 out = Vector2Clamp(*v, *min, *max);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector2));
}

/**
 * Umka bindings for Vector2ClampValue().
 *
 * @see Vector2ClampValue()
 */
RAYLIB_UMKA_FUNCTION(Vector2ClampValue)
void umkaVector2ClampValue(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector2* v = (Vector2*)&params[3];
    float min = params[2].real32Val;
    float max = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector2), NULL);
    Vector2 out = Vector2ClampValue(*v, min, max);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector2));
}

/**
 * Umka bindings for Vector2Equals().
 *
 * @see Vector2Equals()
 */
RAYLIB_UMKA_FUNCTION(Vector2Equals)
void umkaVector2Equals(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector2* p = (Vector2*)&params[1];
    Vector2* q = (Vector2*)&params[0];
    result->intVal = Vector2Equals(*p, *q);
}

/**
 * Umka bindings for Vector3Zero().
 *
 * @see Vector3Zero()
 */
RAYLIB_UMKA_FUNCTION(Vector3Zero)
void umkaVector3Zero(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector3), NULL);
    Vector3 out = Vector3Zero();
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector3));
}

/**
 * Umka bindings for Vector3One().
 *
 * @see Vector3One()
 */
RAYLIB_UMKA_FUNCTION(Vector3One)
void umkaVector3One(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector3), NULL);
    Vector3 out = Vector3One();
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector3));
}

/**
 * Umka bindings for Vector3Add().
 *
 * @see Vector3Add()
 */
RAYLIB_UMKA_FUNCTION(Vector3Add)
void umkaVector3Add(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector3* v1 = (Vector3*)&params[2];
    Vector3* v2 = (Vector3*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector3), NULL);
    Vector3 out = Vector3Add(*v1, *v2);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector3));
}

/**
 * Umka bindings for Vector3AddValue().
 *
 * @see Vector3AddValue()
 */
RAYLIB_UMKA_FUNCTION(Vector3AddValue)
void umkaVector3AddValue(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector3* v = (Vector3*)&params[2];
    float add = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector3), NULL);
    Vector3 out = Vector3AddValue(*v, add);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector3));
}

/**
 * Umka bindings for Vector3Subtract().
 *
 * @see Vector3Subtract()
 */
RAYLIB_UMKA_FUNCTION(Vector3Subtract)
void umkaVector3Subtract(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector3* v1 = (Vector3*)&params[2];
    Vector3* v2 = (Vector3*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector3), NULL);
    Vector3 out = Vector3Subtract(*v1, *v2);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector3));
}

/**
 * Umka bindings for Vector3SubtractValue().
 *
 * @see Vector3SubtractValue()
 */
RAYLIB_UMKA_FUNCTION(Vector3SubtractValue)
void umkaVector3SubtractValue(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector3* v = (Vector3*)&params[2];
    float sub = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector3), NULL);
    Vector3 out = Vector3SubtractValue(*v, sub);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector3));
}

/**
 * Umka bindings for Vector3Scale().
 *
 * @see Vector3Scale()
 */
RAYLIB_UMKA_FUNCTION(Vector3Scale)
void umkaVector3Scale(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector3* v = (Vector3*)&params[2];
    float scalar = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector3), NULL);
    Vector3 out = Vector3Scale(*v, scalar);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector3));
}

/**
 * Umka bindings for Vector3Multiply().
 *
 * @see Vector3Multiply()
 */
RAYLIB_UMKA_FUNCTION(Vector3Multiply)
void umkaVector3Multiply(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector3* v1 = (Vector3*)&params[2];
    Vector3* v2 = (Vector3*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector3), NULL);
    Vector3 out = Vector3Multiply(*v1, *v2);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector3));
}

/**
 * Umka bindings for Vector3CrossProduct().
 *
 * @see Vector3CrossProduct()
 */
RAYLIB_UMKA_FUNCTION(Vector3CrossProduct)
void umkaVector3CrossProduct(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector3* v1 = (Vector3*)&params[2];
    Vector3* v2 = (Vector3*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector3), NULL);
    Vector3 out = Vector3CrossProduct(*v1, *v2);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector3));
}

/**
 * Umka bindings for Vector3Perpendicular().
 *
 * @see Vector3Perpendicular()
 */
RAYLIB_UMKA_FUNCTION(Vector3Perpendicular)
void umkaVector3Perpendicular(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector3* v = (Vector3*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector3), NULL);
    Vector3 out = Vector3Perpendicular(*v);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector3));
}

/**
 * Umka bindings for Vector3Length().
 *
 * @see Vector3Length()
 */
RAYLIB_UMKA_FUNCTION(Vector3Length)
void umkaVector3Length(UmkaStackSlot *params, UmkaStackSlot *result) {
    const Vector3* v = (const Vector3*)&params[0];
    result->realVal = Vector3Length(*v);
}

/**
 * Umka bindings for Vector3LengthSqr().
 *
 * @see Vector3LengthSqr()
 */
RAYLIB_UMKA_FUNCTION(Vector3LengthSqr)
void umkaVector3LengthSqr(UmkaStackSlot *params, UmkaStackSlot *result) {
    const Vector3* v = (const Vector3*)&params[0];
    result->realVal = Vector3LengthSqr(*v);
}

/**
 * Umka bindings for Vector3DotProduct().
 *
 * @see Vector3DotProduct()
 */
RAYLIB_UMKA_FUNCTION(Vector3DotProduct)
void umkaVector3DotProduct(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector3* v1 = (Vector3*)&params[1];
    Vector3* v2 = (Vector3*)&params[0];
    result->realVal = Vector3DotProduct(*v1, *v2);
}

/**
 * Umka bindings for Vector3Distance().
 *
 * @see Vector3Distance()
 */
RAYLIB_UMKA_FUNCTION(Vector3Distance)
void umkaVector3Distance(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector3* v1 = (Vector3*)&params[1];
    Vector3* v2 = (Vector3*)&params[0];
    result->realVal = Vector3Distance(*v1, *v2);
}

/**
 * Umka bindings for Vector3DistanceSqr().
 *
 * @see Vector3DistanceSqr()
 */
RAYLIB_UMKA_FUNCTION(Vector3DistanceSqr)
void umkaVector3DistanceSqr(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector3* v1 = (Vector3*)&params[1];
    Vector3* v2 = (Vector3*)&params[0];
    result->realVal = Vector3DistanceSqr(*v1, *v2);
}

/**
 * Umka bindings for Vector3Angle().
 *
 * @see Vector3Angle()
 */
RAYLIB_UMKA_FUNCTION(Vector3Angle)
void umkaVector3Angle(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector3* v1 = (Vector3*)&params[1];
    Vector3* v2 = (Vector3*)&params[0];
    result->realVal = Vector3Angle(*v1, *v2);
}

/**
 * Umka bindings for Vector3Negate().
 *
 * @see Vector3Negate()
 */
RAYLIB_UMKA_FUNCTION(Vector3Negate)
void umkaVector3Negate(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector3* v = (Vector3*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector3), NULL);
    Vector3 out = Vector3Negate(*v);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector3));
}

/**
 * Umka bindings for Vector3Divide().
 *
 * @see Vector3Divide()
 */
RAYLIB_UMKA_FUNCTION(Vector3Divide)
void umkaVector3Divide(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector3* v1 = (Vector3*)&params[2];
    Vector3* v2 = (Vector3*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector3), NULL);
    Vector3 out = Vector3Divide(*v1, *v2);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector3));
}

/**
 * Umka bindings for Vector3Normalize().
 *
 * @see Vector3Normalize()
 */
RAYLIB_UMKA_FUNCTION(Vector3Normalize)
void umkaVector3Normalize(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector3* v = (Vector3*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector3), NULL);
    Vector3 out = Vector3Normalize(*v);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector3));
}

/**
 * Umka bindings for Vector3OrthoNormalize().
 *
 * @see Vector3OrthoNormalize()
 */
RAYLIB_UMKA_FUNCTION(Vector3OrthoNormalize)
void umkaVector3OrthoNormalize(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector3 * v1 = (Vector3 *)params[1].ptrVal;
    Vector3 * v2 = (Vector3 *)params[0].ptrVal;
    Vector3OrthoNormalize(v1, v2);
}

/**
 * Umka bindings for Vector3Transform().
 *
 * @see Vector3Transform()
 */
RAYLIB_UMKA_FUNCTION(Vector3Transform)
void umkaVector3Transform(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector3* v = (Vector3*)&params[2];
    Matrix* mat = (Matrix*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector3), NULL);
    Vector3 out = Vector3Transform(*v, *mat);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector3));
}

/**
 * Umka bindings for Vector3RotateByQuaternion().
 *
 * @see Vector3RotateByQuaternion()
 */
RAYLIB_UMKA_FUNCTION(Vector3RotateByQuaternion)
void umkaVector3RotateByQuaternion(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector3* v = (Vector3*)&params[2];
    Quaternion* q = (Quaternion*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector3), NULL);
    Vector3 out = Vector3RotateByQuaternion(*v, *q);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector3));
}

/**
 * Umka bindings for Vector3RotateByAxisAngle().
 *
 * @see Vector3RotateByAxisAngle()
 */
RAYLIB_UMKA_FUNCTION(Vector3RotateByAxisAngle)
void umkaVector3RotateByAxisAngle(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector3* v = (Vector3*)&params[3];
    Vector3* axis = (Vector3*)&params[2];
    float angle = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector3), NULL);
    Vector3 out = Vector3RotateByAxisAngle(*v, *axis, angle);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector3));
}

/**
 * Umka bindings for Vector3Lerp().
 *
 * @see Vector3Lerp()
 */
RAYLIB_UMKA_FUNCTION(Vector3Lerp)
void umkaVector3Lerp(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector3* v1 = (Vector3*)&params[3];
    Vector3* v2 = (Vector3*)&params[2];
    float amount = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector3), NULL);
    Vector3 out = Vector3Lerp(*v1, *v2, amount);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector3));
}

/**
 * Umka bindings for Vector3Reflect().
 *
 * @see Vector3Reflect()
 */
RAYLIB_UMKA_FUNCTION(Vector3Reflect)
void umkaVector3Reflect(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector3* v = (Vector3*)&params[2];
    Vector3* normal = (Vector3*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector3), NULL);
    Vector3 out = Vector3Reflect(*v, *normal);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector3));
}

/**
 * Umka bindings for Vector3Min().
 *
 * @see Vector3Min()
 */
RAYLIB_UMKA_FUNCTION(Vector3Min)
void umkaVector3Min(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector3* v1 = (Vector3*)&params[2];
    Vector3* v2 = (Vector3*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector3), NULL);
    Vector3 out = Vector3Min(*v1, *v2);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector3));
}

/**
 * Umka bindings for Vector3Max().
 *
 * @see Vector3Max()
 */
RAYLIB_UMKA_FUNCTION(Vector3Max)
void umkaVector3Max(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector3* v1 = (Vector3*)&params[2];
    Vector3* v2 = (Vector3*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector3), NULL);
    Vector3 out = Vector3Max(*v1, *v2);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector3));
}

/**
 * Umka bindings for Vector3Barycenter().
 *
 * @see Vector3Barycenter()
 */
RAYLIB_UMKA_FUNCTION(Vector3Barycenter)
void umkaVector3Barycenter(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector3* p = (Vector3*)&params[4];
    Vector3* a = (Vector3*)&params[3];
    Vector3* b = (Vector3*)&params[2];
    Vector3* c = (Vector3*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector3), NULL);
    Vector3 out = Vector3Barycenter(*p, *a, *b, *c);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector3));
}

/**
 * Umka bindings for Vector3Unproject().
 *
 * @see Vector3Unproject()
 */
RAYLIB_UMKA_FUNCTION(Vector3Unproject)
void umkaVector3Unproject(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector3* source = (Vector3*)&params[3];
    Matrix* projection = (Matrix*)&params[2];
    Matrix* view = (Matrix*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector3), NULL);
    Vector3 out = Vector3Unproject(*source, *projection, *view);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector3));
}

/**
 * Umka bindings for Vector3ToFloatV().
 *
 * @see Vector3ToFloatV()
 */
RAYLIB_UMKA_FUNCTION(Vector3ToFloatV)
void umkaVector3ToFloatV(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector3* v = (Vector3*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(float3), NULL);
    float3 out = Vector3ToFloatV(*v);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(float3));
}

/**
 * Umka bindings for Vector3Invert().
 *
 * @see Vector3Invert()
 */
RAYLIB_UMKA_FUNCTION(Vector3Invert)
void umkaVector3Invert(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector3* v = (Vector3*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector3), NULL);
    Vector3 out = Vector3Invert(*v);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector3));
}

/**
 * Umka bindings for Vector3Clamp().
 *
 * @see Vector3Clamp()
 */
RAYLIB_UMKA_FUNCTION(Vector3Clamp)
void umkaVector3Clamp(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector3* v = (Vector3*)&params[3];
    Vector3* min = (Vector3*)&params[2];
    Vector3* max = (Vector3*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector3), NULL);
    Vector3 out = Vector3Clamp(*v, *min, *max);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector3));
}

/**
 * Umka bindings for Vector3ClampValue().
 *
 * @see Vector3ClampValue()
 */
RAYLIB_UMKA_FUNCTION(Vector3ClampValue)
void umkaVector3ClampValue(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector3* v = (Vector3*)&params[3];
    float min = params[2].real32Val;
    float max = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector3), NULL);
    Vector3 out = Vector3ClampValue(*v, min, max);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector3));
}

/**
 * Umka bindings for Vector3Equals().
 *
 * @see Vector3Equals()
 */
RAYLIB_UMKA_FUNCTION(Vector3Equals)
void umkaVector3Equals(UmkaStackSlot *params, UmkaStackSlot *result) {
    Vector3* p = (Vector3*)&params[1];
    Vector3* q = (Vector3*)&params[0];
    result->intVal = Vector3Equals(*p, *q);
}

/**
 * Umka bindings for Vector3Refract().
 *
 * @see Vector3Refract()
 */
RAYLIB_UMKA_FUNCTION(Vector3Refract)
void umkaVector3Refract(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector3* v = (Vector3*)&params[3];
    Vector3* n = (Vector3*)&params[2];
    float r = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector3), NULL);
    Vector3 out = Vector3Refract(*v, *n, r);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector3));
}

/**
 * Umka bindings for MatrixDeterminant().
 *
 * @see MatrixDeterminant()
 */
RAYLIB_UMKA_FUNCTION(MatrixDeterminant)
void umkaMatrixDeterminant(UmkaStackSlot *params, UmkaStackSlot *result) {
    Matrix* mat = (Matrix*)&params[0];
    result->realVal = MatrixDeterminant(*mat);
}

/**
 * Umka bindings for MatrixTrace().
 *
 * @see MatrixTrace()
 */
RAYLIB_UMKA_FUNCTION(MatrixTrace)
void umkaMatrixTrace(UmkaStackSlot *params, UmkaStackSlot *result) {
    Matrix* mat = (Matrix*)&params[0];
    result->realVal = MatrixTrace(*mat);
}

/**
 * Umka bindings for MatrixTranspose().
 *
 * @see MatrixTranspose()
 */
RAYLIB_UMKA_FUNCTION(MatrixTranspose)
void umkaMatrixTranspose(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Matrix* mat = (Matrix*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Matrix), NULL);
    Matrix out = MatrixTranspose(*mat);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Matrix));
}

/**
 * Umka bindings for MatrixInvert().
 *
 * @see MatrixInvert()
 */
RAYLIB_UMKA_FUNCTION(MatrixInvert)
void umkaMatrixInvert(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Matrix* mat = (Matrix*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Matrix), NULL);
    Matrix out = MatrixInvert(*mat);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Matrix));
}

/**
 * Umka bindings for MatrixIdentity().
 *
 * @see MatrixIdentity()
 */
RAYLIB_UMKA_FUNCTION(MatrixIdentity)
void umkaMatrixIdentity(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Matrix), NULL);
    Matrix out = MatrixIdentity();
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Matrix));
}

/**
 * Umka bindings for MatrixAdd().
 *
 * @see MatrixAdd()
 */
RAYLIB_UMKA_FUNCTION(MatrixAdd)
void umkaMatrixAdd(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Matrix* left = (Matrix*)&params[2];
    Matrix* right = (Matrix*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Matrix), NULL);
    Matrix out = MatrixAdd(*left, *right);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Matrix));
}

/**
 * Umka bindings for MatrixSubtract().
 *
 * @see MatrixSubtract()
 */
RAYLIB_UMKA_FUNCTION(MatrixSubtract)
void umkaMatrixSubtract(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Matrix* left = (Matrix*)&params[2];
    Matrix* right = (Matrix*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Matrix), NULL);
    Matrix out = MatrixSubtract(*left, *right);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Matrix));
}

/**
 * Umka bindings for MatrixMultiply().
 *
 * @see MatrixMultiply()
 */
RAYLIB_UMKA_FUNCTION(MatrixMultiply)
void umkaMatrixMultiply(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Matrix* left = (Matrix*)&params[2];
    Matrix* right = (Matrix*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Matrix), NULL);
    Matrix out = MatrixMultiply(*left, *right);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Matrix));
}

/**
 * Umka bindings for MatrixTranslate().
 *
 * @see MatrixTranslate()
 */
RAYLIB_UMKA_FUNCTION(MatrixTranslate)
void umkaMatrixTranslate(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    float x = params[3].real32Val;
    float y = params[2].real32Val;
    float z = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Matrix), NULL);
    Matrix out = MatrixTranslate(x, y, z);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Matrix));
}

/**
 * Umka bindings for MatrixRotate().
 *
 * @see MatrixRotate()
 */
RAYLIB_UMKA_FUNCTION(MatrixRotate)
void umkaMatrixRotate(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector3* axis = (Vector3*)&params[2];
    float angle = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Matrix), NULL);
    Matrix out = MatrixRotate(*axis, angle);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Matrix));
}

/**
 * Umka bindings for MatrixRotateX().
 *
 * @see MatrixRotateX()
 */
RAYLIB_UMKA_FUNCTION(MatrixRotateX)
void umkaMatrixRotateX(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    float angle = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Matrix), NULL);
    Matrix out = MatrixRotateX(angle);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Matrix));
}

/**
 * Umka bindings for MatrixRotateY().
 *
 * @see MatrixRotateY()
 */
RAYLIB_UMKA_FUNCTION(MatrixRotateY)
void umkaMatrixRotateY(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    float angle = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Matrix), NULL);
    Matrix out = MatrixRotateY(angle);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Matrix));
}

/**
 * Umka bindings for MatrixRotateZ().
 *
 * @see MatrixRotateZ()
 */
RAYLIB_UMKA_FUNCTION(MatrixRotateZ)
void umkaMatrixRotateZ(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    float angle = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Matrix), NULL);
    Matrix out = MatrixRotateZ(angle);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Matrix));
}

/**
 * Umka bindings for MatrixRotateXYZ().
 *
 * @see MatrixRotateXYZ()
 */
RAYLIB_UMKA_FUNCTION(MatrixRotateXYZ)
void umkaMatrixRotateXYZ(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector3* angle = (Vector3*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Matrix), NULL);
    Matrix out = MatrixRotateXYZ(*angle);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Matrix));
}

/**
 * Umka bindings for MatrixRotateZYX().
 *
 * @see MatrixRotateZYX()
 */
RAYLIB_UMKA_FUNCTION(MatrixRotateZYX)
void umkaMatrixRotateZYX(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector3* angle = (Vector3*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Matrix), NULL);
    Matrix out = MatrixRotateZYX(*angle);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Matrix));
}

/**
 * Umka bindings for MatrixScale().
 *
 * @see MatrixScale()
 */
RAYLIB_UMKA_FUNCTION(MatrixScale)
void umkaMatrixScale(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    float x = params[3].real32Val;
    float y = params[2].real32Val;
    float z = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Matrix), NULL);
    Matrix out = MatrixScale(x, y, z);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Matrix));
}

/**
 * Umka bindings for MatrixFrustum().
 *
 * @see MatrixFrustum()
 */
RAYLIB_UMKA_FUNCTION(MatrixFrustum)
void umkaMatrixFrustum(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    double left = params[6].realVal;
    double right = params[5].realVal;
    double bottom = params[4].realVal;
    double top = params[3].realVal;
    double near = params[2].realVal;
    double far = params[1].realVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Matrix), NULL);
    Matrix out = MatrixFrustum(left, right, bottom, top, near, far);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Matrix));
}

/**
 * Umka bindings for MatrixPerspective().
 *
 * @see MatrixPerspective()
 */
RAYLIB_UMKA_FUNCTION(MatrixPerspective)
void umkaMatrixPerspective(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    double fovy = params[4].realVal;
    double aspect = params[3].realVal;
    double near = params[2].realVal;
    double far = params[1].realVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Matrix), NULL);
    Matrix out = MatrixPerspective(fovy, aspect, near, far);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Matrix));
}

/**
 * Umka bindings for MatrixOrtho().
 *
 * @see MatrixOrtho()
 */
RAYLIB_UMKA_FUNCTION(MatrixOrtho)
void umkaMatrixOrtho(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    double left = params[6].realVal;
    double right = params[5].realVal;
    double bottom = params[4].realVal;
    double top = params[3].realVal;
    double near = params[2].realVal;
    double far = params[1].realVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Matrix), NULL);
    Matrix out = MatrixOrtho(left, right, bottom, top, near, far);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Matrix));
}

/**
 * Umka bindings for MatrixLookAt().
 *
 * @see MatrixLookAt()
 */
RAYLIB_UMKA_FUNCTION(MatrixLookAt)
void umkaMatrixLookAt(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector3* eye = (Vector3*)&params[3];
    Vector3* target = (Vector3*)&params[2];
    Vector3* up = (Vector3*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Matrix), NULL);
    Matrix out = MatrixLookAt(*eye, *target, *up);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Matrix));
}

/**
 * Umka bindings for MatrixToFloatV().
 *
 * @see MatrixToFloatV()
 */
RAYLIB_UMKA_FUNCTION(MatrixToFloatV)
void umkaMatrixToFloatV(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Matrix* mat = (Matrix*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(float16), NULL);
    float16 out = MatrixToFloatV(*mat);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(float16));
}

/**
 * Umka bindings for QuaternionAdd().
 *
 * @see QuaternionAdd()
 */
RAYLIB_UMKA_FUNCTION(QuaternionAdd)
void umkaQuaternionAdd(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Quaternion* q1 = (Quaternion*)&params[2];
    Quaternion* q2 = (Quaternion*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Quaternion), NULL);
    Quaternion out = QuaternionAdd(*q1, *q2);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Quaternion));
}

/**
 * Umka bindings for QuaternionAddValue().
 *
 * @see QuaternionAddValue()
 */
RAYLIB_UMKA_FUNCTION(QuaternionAddValue)
void umkaQuaternionAddValue(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Quaternion* q = (Quaternion*)&params[2];
    float add = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Quaternion), NULL);
    Quaternion out = QuaternionAddValue(*q, add);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Quaternion));
}

/**
 * Umka bindings for QuaternionSubtract().
 *
 * @see QuaternionSubtract()
 */
RAYLIB_UMKA_FUNCTION(QuaternionSubtract)
void umkaQuaternionSubtract(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Quaternion* q1 = (Quaternion*)&params[2];
    Quaternion* q2 = (Quaternion*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Quaternion), NULL);
    Quaternion out = QuaternionSubtract(*q1, *q2);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Quaternion));
}

/**
 * Umka bindings for QuaternionSubtractValue().
 *
 * @see QuaternionSubtractValue()
 */
RAYLIB_UMKA_FUNCTION(QuaternionSubtractValue)
void umkaQuaternionSubtractValue(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Quaternion* q = (Quaternion*)&params[2];
    float sub = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Quaternion), NULL);
    Quaternion out = QuaternionSubtractValue(*q, sub);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Quaternion));
}

/**
 * Umka bindings for QuaternionIdentity().
 *
 * @see QuaternionIdentity()
 */
RAYLIB_UMKA_FUNCTION(QuaternionIdentity)
void umkaQuaternionIdentity(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Quaternion), NULL);
    Quaternion out = QuaternionIdentity();
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Quaternion));
}

/**
 * Umka bindings for QuaternionLength().
 *
 * @see QuaternionLength()
 */
RAYLIB_UMKA_FUNCTION(QuaternionLength)
void umkaQuaternionLength(UmkaStackSlot *params, UmkaStackSlot *result) {
    Quaternion* q = (Quaternion*)&params[0];
    result->realVal = QuaternionLength(*q);
}

/**
 * Umka bindings for QuaternionNormalize().
 *
 * @see QuaternionNormalize()
 */
RAYLIB_UMKA_FUNCTION(QuaternionNormalize)
void umkaQuaternionNormalize(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Quaternion* q = (Quaternion*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Quaternion), NULL);
    Quaternion out = QuaternionNormalize(*q);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Quaternion));
}

/**
 * Umka bindings for QuaternionInvert().
 *
 * @see QuaternionInvert()
 */
RAYLIB_UMKA_FUNCTION(QuaternionInvert)
void umkaQuaternionInvert(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Quaternion* q = (Quaternion*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Quaternion), NULL);
    Quaternion out = QuaternionInvert(*q);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Quaternion));
}

/**
 * Umka bindings for QuaternionMultiply().
 *
 * @see QuaternionMultiply()
 */
RAYLIB_UMKA_FUNCTION(QuaternionMultiply)
void umkaQuaternionMultiply(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Quaternion* q1 = (Quaternion*)&params[2];
    Quaternion* q2 = (Quaternion*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Quaternion), NULL);
    Quaternion out = QuaternionMultiply(*q1, *q2);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Quaternion));
}

/**
 * Umka bindings for QuaternionScale().
 *
 * @see QuaternionScale()
 */
RAYLIB_UMKA_FUNCTION(QuaternionScale)
void umkaQuaternionScale(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Quaternion* q = (Quaternion*)&params[2];
    float mul = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Quaternion), NULL);
    Quaternion out = QuaternionScale(*q, mul);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Quaternion));
}

/**
 * Umka bindings for QuaternionDivide().
 *
 * @see QuaternionDivide()
 */
RAYLIB_UMKA_FUNCTION(QuaternionDivide)
void umkaQuaternionDivide(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Quaternion* q1 = (Quaternion*)&params[2];
    Quaternion* q2 = (Quaternion*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Quaternion), NULL);
    Quaternion out = QuaternionDivide(*q1, *q2);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Quaternion));
}

/**
 * Umka bindings for QuaternionLerp().
 *
 * @see QuaternionLerp()
 */
RAYLIB_UMKA_FUNCTION(QuaternionLerp)
void umkaQuaternionLerp(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Quaternion* q1 = (Quaternion*)&params[3];
    Quaternion* q2 = (Quaternion*)&params[2];
    float amount = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Quaternion), NULL);
    Quaternion out = QuaternionLerp(*q1, *q2, amount);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Quaternion));
}

/**
 * Umka bindings for QuaternionNlerp().
 *
 * @see QuaternionNlerp()
 */
RAYLIB_UMKA_FUNCTION(QuaternionNlerp)
void umkaQuaternionNlerp(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Quaternion* q1 = (Quaternion*)&params[3];
    Quaternion* q2 = (Quaternion*)&params[2];
    float amount = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Quaternion), NULL);
    Quaternion out = QuaternionNlerp(*q1, *q2, amount);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Quaternion));
}

/**
 * Umka bindings for QuaternionSlerp().
 *
 * @see QuaternionSlerp()
 */
RAYLIB_UMKA_FUNCTION(QuaternionSlerp)
void umkaQuaternionSlerp(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Quaternion* q1 = (Quaternion*)&params[3];
    Quaternion* q2 = (Quaternion*)&params[2];
    float amount = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Quaternion), NULL);
    Quaternion out = QuaternionSlerp(*q1, *q2, amount);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Quaternion));
}

/**
 * Umka bindings for QuaternionFromVector3ToVector3().
 *
 * @see QuaternionFromVector3ToVector3()
 */
RAYLIB_UMKA_FUNCTION(QuaternionFromVector3ToVector3)
void umkaQuaternionFromVector3ToVector3(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector3* from = (Vector3*)&params[2];
    Vector3* to = (Vector3*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Quaternion), NULL);
    Quaternion out = QuaternionFromVector3ToVector3(*from, *to);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Quaternion));
}

/**
 * Umka bindings for QuaternionFromMatrix().
 *
 * @see QuaternionFromMatrix()
 */
RAYLIB_UMKA_FUNCTION(QuaternionFromMatrix)
void umkaQuaternionFromMatrix(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Matrix* mat = (Matrix*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Quaternion), NULL);
    Quaternion out = QuaternionFromMatrix(*mat);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Quaternion));
}

/**
 * Umka bindings for QuaternionToMatrix().
 *
 * @see QuaternionToMatrix()
 */
RAYLIB_UMKA_FUNCTION(QuaternionToMatrix)
void umkaQuaternionToMatrix(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Quaternion* q = (Quaternion*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Matrix), NULL);
    Matrix out = QuaternionToMatrix(*q);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Matrix));
}

/**
 * Umka bindings for QuaternionFromAxisAngle().
 *
 * @see QuaternionFromAxisAngle()
 */
RAYLIB_UMKA_FUNCTION(QuaternionFromAxisAngle)
void umkaQuaternionFromAxisAngle(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Vector3* axis = (Vector3*)&params[2];
    float angle = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Quaternion), NULL);
    Quaternion out = QuaternionFromAxisAngle(*axis, angle);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Quaternion));
}

/**
 * Umka bindings for QuaternionToAxisAngle().
 *
 * @see QuaternionToAxisAngle()
 */
RAYLIB_UMKA_FUNCTION(QuaternionToAxisAngle)
void umkaQuaternionToAxisAngle(UmkaStackSlot *params, UmkaStackSlot *result) {
    Quaternion* q = (Quaternion*)&params[2];
    Vector3 * outAxis = (Vector3 *)params[1].ptrVal;
    float * outAngle = (float *)params[0].ptrVal;
    QuaternionToAxisAngle(*q, outAxis, outAngle);
}

/**
 * Umka bindings for QuaternionFromEuler().
 *
 * @see QuaternionFromEuler()
 */
RAYLIB_UMKA_FUNCTION(QuaternionFromEuler)
void umkaQuaternionFromEuler(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    float pitch = params[3].real32Val;
    float yaw = params[2].real32Val;
    float roll = params[1].real32Val;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Quaternion), NULL);
    Quaternion out = QuaternionFromEuler(pitch, yaw, roll);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Quaternion));
}

/**
 * Umka bindings for QuaternionToEuler().
 *
 * @see QuaternionToEuler()
 */
RAYLIB_UMKA_FUNCTION(QuaternionToEuler)
void umkaQuaternionToEuler(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Quaternion* q = (Quaternion*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Vector3), NULL);
    Vector3 out = QuaternionToEuler(*q);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Vector3));
}

/**
 * Umka bindings for QuaternionTransform().
 *
 * @see QuaternionTransform()
 */
RAYLIB_UMKA_FUNCTION(QuaternionTransform)
void umkaQuaternionTransform(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    Quaternion* q = (Quaternion*)&params[2];
    Matrix* mat = (Matrix*)&params[1];
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Quaternion), NULL);
    Quaternion out = QuaternionTransform(*q, *mat);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Quaternion));
}

/**
 * Umka bindings for QuaternionEquals().
 *
 * @see QuaternionEquals()
 */
RAYLIB_UMKA_FUNCTION(QuaternionEquals)
void umkaQuaternionEquals(UmkaStackSlot *params, UmkaStackSlot *result) {
    Quaternion* p = (Quaternion*)&params[1];
    Quaternion* q = (Quaternion*)&params[0];
    result->intVal = QuaternionEquals(*p, *q);
}

/**
 * Umka bindings for rlMatrixMode().
 *
 * @see rlMatrixMode()
 */
RAYLIB_UMKA_FUNCTION(rlMatrixMode)
void umkarlMatrixMode(UmkaStackSlot *params, UmkaStackSlot *result) {
    int mode = params[0].intVal;
    rlMatrixMode(mode);
}

/**
 * Umka bindings for rlPushMatrix().
 *
 * @see rlPushMatrix()
 */
RAYLIB_UMKA_FUNCTION(rlPushMatrix)
void umkarlPushMatrix(UmkaStackSlot *params, UmkaStackSlot *result) {
    rlPushMatrix();
}

/**
 * Umka bindings for rlPopMatrix().
 *
 * @see rlPopMatrix()
 */
RAYLIB_UMKA_FUNCTION(rlPopMatrix)
void umkarlPopMatrix(UmkaStackSlot *params, UmkaStackSlot *result) {
    rlPopMatrix();
}

/**
 * Umka bindings for rlLoadIdentity().
 *
 * @see rlLoadIdentity()
 */
RAYLIB_UMKA_FUNCTION(rlLoadIdentity)
void umkarlLoadIdentity(UmkaStackSlot *params, UmkaStackSlot *result) {
    rlLoadIdentity();
}

/**
 * Umka bindings for rlTranslatef().
 *
 * @see rlTranslatef()
 */
RAYLIB_UMKA_FUNCTION(rlTranslatef)
void umkarlTranslatef(UmkaStackSlot *params, UmkaStackSlot *result) {
    float x = params[2].real32Val;
    float y = params[1].real32Val;
    float z = params[0].real32Val;
    rlTranslatef(x, y, z);
}

/**
 * Umka bindings for rlRotatef().
 *
 * @see rlRotatef()
 */
RAYLIB_UMKA_FUNCTION(rlRotatef)
void umkarlRotatef(UmkaStackSlot *params, UmkaStackSlot *result) {
    float angle = params[3].real32Val;
    float x = params[2].real32Val;
    float y = params[1].real32Val;
    float z = params[0].real32Val;
    rlRotatef(angle, x, y, z);
}

/**
 * Umka bindings for rlScalef().
 *
 * @see rlScalef()
 */
RAYLIB_UMKA_FUNCTION(rlScalef)
void umkarlScalef(UmkaStackSlot *params, UmkaStackSlot *result) {
    float x = params[2].real32Val;
    float y = params[1].real32Val;
    float z = params[0].real32Val;
    rlScalef(x, y, z);
}

/**
 * Umka bindings for rlMultMatrixf().
 *
 * @see rlMultMatrixf()
 */
RAYLIB_UMKA_FUNCTION(rlMultMatrixf)
void umkarlMultMatrixf(UmkaStackSlot *params, UmkaStackSlot *result) {
    float * matf = (float *)params[0].ptrVal;
    rlMultMatrixf(matf);
}

/**
 * Umka bindings for rlFrustum().
 *
 * @see rlFrustum()
 */
RAYLIB_UMKA_FUNCTION(rlFrustum)
void umkarlFrustum(UmkaStackSlot *params, UmkaStackSlot *result) {
    double left = params[5].realVal;
    double right = params[4].realVal;
    double bottom = params[3].realVal;
    double top = params[2].realVal;
    double znear = params[1].realVal;
    double zfar = params[0].realVal;
    rlFrustum(left, right, bottom, top, znear, zfar);
}

/**
 * Umka bindings for rlOrtho().
 *
 * @see rlOrtho()
 */
RAYLIB_UMKA_FUNCTION(rlOrtho)
void umkarlOrtho(UmkaStackSlot *params, UmkaStackSlot *result) {
    double left = params[5].realVal;
    double right = params[4].realVal;
    double bottom = params[3].realVal;
    double top = params[2].realVal;
    double znear = params[1].realVal;
    double zfar = params[0].realVal;
    rlOrtho(left, right, bottom, top, znear, zfar);
}

/**
 * Umka bindings for rlViewport().
 *
 * @see rlViewport()
 */
RAYLIB_UMKA_FUNCTION(rlViewport)
void umkarlViewport(UmkaStackSlot *params, UmkaStackSlot *result) {
    int x = params[3].intVal;
    int y = params[2].intVal;
    int width = params[1].intVal;
    int height = params[0].intVal;
    rlViewport(x, y, width, height);
}

/**
 * Umka bindings for rlBegin().
 *
 * @see rlBegin()
 */
RAYLIB_UMKA_FUNCTION(rlBegin)
void umkarlBegin(UmkaStackSlot *params, UmkaStackSlot *result) {
    int mode = params[0].intVal;
    rlBegin(mode);
}

/**
 * Umka bindings for rlEnd().
 *
 * @see rlEnd()
 */
RAYLIB_UMKA_FUNCTION(rlEnd)
void umkarlEnd(UmkaStackSlot *params, UmkaStackSlot *result) {
    rlEnd();
}

/**
 * Umka bindings for rlVertex2i().
 *
 * @see rlVertex2i()
 */
RAYLIB_UMKA_FUNCTION(rlVertex2i)
void umkarlVertex2i(UmkaStackSlot *params, UmkaStackSlot *result) {
    int x = params[1].intVal;
    int y = params[0].intVal;
    rlVertex2i(x, y);
}

/**
 * Umka bindings for rlVertex2f().
 *
 * @see rlVertex2f()
 */
RAYLIB_UMKA_FUNCTION(rlVertex2f)
void umkarlVertex2f(UmkaStackSlot *params, UmkaStackSlot *result) {
    float x = params[1].real32Val;
    float y = params[0].real32Val;
    rlVertex2f(x, y);
}

/**
 * Umka bindings for rlVertex3f().
 *
 * @see rlVertex3f()
 */
RAYLIB_UMKA_FUNCTION(rlVertex3f)
void umkarlVertex3f(UmkaStackSlot *params, UmkaStackSlot *result) {
    float x = params[2].real32Val;
    float y = params[1].real32Val;
    float z = params[0].real32Val;
    rlVertex3f(x, y, z);
}

/**
 * Umka bindings for rlTexCoord2f().
 *
 * @see rlTexCoord2f()
 */
RAYLIB_UMKA_FUNCTION(rlTexCoord2f)
void umkarlTexCoord2f(UmkaStackSlot *params, UmkaStackSlot *result) {
    float x = params[1].real32Val;
    float y = params[0].real32Val;
    rlTexCoord2f(x, y);
}

/**
 * Umka bindings for rlNormal3f().
 *
 * @see rlNormal3f()
 */
RAYLIB_UMKA_FUNCTION(rlNormal3f)
void umkarlNormal3f(UmkaStackSlot *params, UmkaStackSlot *result) {
    float x = params[2].real32Val;
    float y = params[1].real32Val;
    float z = params[0].real32Val;
    rlNormal3f(x, y, z);
}

/**
 * Umka bindings for rlColor4ub().
 *
 * @see rlColor4ub()
 */
RAYLIB_UMKA_FUNCTION(rlColor4ub)
void umkarlColor4ub(UmkaStackSlot *params, UmkaStackSlot *result) {
    unsigned char r = params[3].uintVal;
    unsigned char g = params[2].uintVal;
    unsigned char b = params[1].uintVal;
    unsigned char a = params[0].uintVal;
    rlColor4ub(r, g, b, a);
}

/**
 * Umka bindings for rlColor3f().
 *
 * @see rlColor3f()
 */
RAYLIB_UMKA_FUNCTION(rlColor3f)
void umkarlColor3f(UmkaStackSlot *params, UmkaStackSlot *result) {
    float x = params[2].real32Val;
    float y = params[1].real32Val;
    float z = params[0].real32Val;
    rlColor3f(x, y, z);
}

/**
 * Umka bindings for rlColor4f().
 *
 * @see rlColor4f()
 */
RAYLIB_UMKA_FUNCTION(rlColor4f)
void umkarlColor4f(UmkaStackSlot *params, UmkaStackSlot *result) {
    float x = params[3].real32Val;
    float y = params[2].real32Val;
    float z = params[1].real32Val;
    float w = params[0].real32Val;
    rlColor4f(x, y, z, w);
}

/**
 * Umka bindings for rlEnableVertexArray().
 *
 * @see rlEnableVertexArray()
 */
RAYLIB_UMKA_FUNCTION(rlEnableVertexArray)
void umkarlEnableVertexArray(UmkaStackSlot *params, UmkaStackSlot *result) {
    unsigned int vaoId = params[0].uintVal;
    result->intVal = (int)rlEnableVertexArray(vaoId);
}

/**
 * Umka bindings for rlDisableVertexArray().
 *
 * @see rlDisableVertexArray()
 */
RAYLIB_UMKA_FUNCTION(rlDisableVertexArray)
void umkarlDisableVertexArray(UmkaStackSlot *params, UmkaStackSlot *result) {
    rlDisableVertexArray();
}

/**
 * Umka bindings for rlEnableVertexBuffer().
 *
 * @see rlEnableVertexBuffer()
 */
RAYLIB_UMKA_FUNCTION(rlEnableVertexBuffer)
void umkarlEnableVertexBuffer(UmkaStackSlot *params, UmkaStackSlot *result) {
    unsigned int id = params[0].uintVal;
    rlEnableVertexBuffer(id);
}

/**
 * Umka bindings for rlDisableVertexBuffer().
 *
 * @see rlDisableVertexBuffer()
 */
RAYLIB_UMKA_FUNCTION(rlDisableVertexBuffer)
void umkarlDisableVertexBuffer(UmkaStackSlot *params, UmkaStackSlot *result) {
    rlDisableVertexBuffer();
}

/**
 * Umka bindings for rlEnableVertexBufferElement().
 *
 * @see rlEnableVertexBufferElement()
 */
RAYLIB_UMKA_FUNCTION(rlEnableVertexBufferElement)
void umkarlEnableVertexBufferElement(UmkaStackSlot *params, UmkaStackSlot *result) {
    unsigned int id = params[0].uintVal;
    rlEnableVertexBufferElement(id);
}

/**
 * Umka bindings for rlDisableVertexBufferElement().
 *
 * @see rlDisableVertexBufferElement()
 */
RAYLIB_UMKA_FUNCTION(rlDisableVertexBufferElement)
void umkarlDisableVertexBufferElement(UmkaStackSlot *params, UmkaStackSlot *result) {
    rlDisableVertexBufferElement();
}

/**
 * Umka bindings for rlEnableVertexAttribute().
 *
 * @see rlEnableVertexAttribute()
 */
RAYLIB_UMKA_FUNCTION(rlEnableVertexAttribute)
void umkarlEnableVertexAttribute(UmkaStackSlot *params, UmkaStackSlot *result) {
    unsigned int index = params[0].uintVal;
    rlEnableVertexAttribute(index);
}

/**
 * Umka bindings for rlDisableVertexAttribute().
 *
 * @see rlDisableVertexAttribute()
 */
RAYLIB_UMKA_FUNCTION(rlDisableVertexAttribute)
void umkarlDisableVertexAttribute(UmkaStackSlot *params, UmkaStackSlot *result) {
    unsigned int index = params[0].uintVal;
    rlDisableVertexAttribute(index);
}

// Function rlEnableStatePointer() skipped

// Function rlDisableStatePointer() skipped

/**
 * Umka bindings for rlActiveTextureSlot().
 *
 * @see rlActiveTextureSlot()
 */
RAYLIB_UMKA_FUNCTION(rlActiveTextureSlot)
void umkarlActiveTextureSlot(UmkaStackSlot *params, UmkaStackSlot *result) {
    int slot = params[0].intVal;
    rlActiveTextureSlot(slot);
}

/**
 * Umka bindings for rlEnableTexture().
 *
 * @see rlEnableTexture()
 */
RAYLIB_UMKA_FUNCTION(rlEnableTexture)
void umkarlEnableTexture(UmkaStackSlot *params, UmkaStackSlot *result) {
    unsigned int id = params[0].uintVal;
    rlEnableTexture(id);
}

/**
 * Umka bindings for rlDisableTexture().
 *
 * @see rlDisableTexture()
 */
RAYLIB_UMKA_FUNCTION(rlDisableTexture)
void umkarlDisableTexture(UmkaStackSlot *params, UmkaStackSlot *result) {
    rlDisableTexture();
}

/**
 * Umka bindings for rlEnableTextureCubemap().
 *
 * @see rlEnableTextureCubemap()
 */
RAYLIB_UMKA_FUNCTION(rlEnableTextureCubemap)
void umkarlEnableTextureCubemap(UmkaStackSlot *params, UmkaStackSlot *result) {
    unsigned int id = params[0].uintVal;
    rlEnableTextureCubemap(id);
}

/**
 * Umka bindings for rlDisableTextureCubemap().
 *
 * @see rlDisableTextureCubemap()
 */
RAYLIB_UMKA_FUNCTION(rlDisableTextureCubemap)
void umkarlDisableTextureCubemap(UmkaStackSlot *params, UmkaStackSlot *result) {
    rlDisableTextureCubemap();
}

/**
 * Umka bindings for rlTextureParameters().
 *
 * @see rlTextureParameters()
 */
RAYLIB_UMKA_FUNCTION(rlTextureParameters)
void umkarlTextureParameters(UmkaStackSlot *params, UmkaStackSlot *result) {
    unsigned int id = params[2].uintVal;
    int param = params[1].intVal;
    int value = params[0].intVal;
    rlTextureParameters(id, param, value);
}

/**
 * Umka bindings for rlEnableShader().
 *
 * @see rlEnableShader()
 */
RAYLIB_UMKA_FUNCTION(rlEnableShader)
void umkarlEnableShader(UmkaStackSlot *params, UmkaStackSlot *result) {
    unsigned int id = params[0].uintVal;
    rlEnableShader(id);
}

/**
 * Umka bindings for rlDisableShader().
 *
 * @see rlDisableShader()
 */
RAYLIB_UMKA_FUNCTION(rlDisableShader)
void umkarlDisableShader(UmkaStackSlot *params, UmkaStackSlot *result) {
    rlDisableShader();
}

/**
 * Umka bindings for rlEnableFramebuffer().
 *
 * @see rlEnableFramebuffer()
 */
RAYLIB_UMKA_FUNCTION(rlEnableFramebuffer)
void umkarlEnableFramebuffer(UmkaStackSlot *params, UmkaStackSlot *result) {
    unsigned int id = params[0].uintVal;
    rlEnableFramebuffer(id);
}

/**
 * Umka bindings for rlDisableFramebuffer().
 *
 * @see rlDisableFramebuffer()
 */
RAYLIB_UMKA_FUNCTION(rlDisableFramebuffer)
void umkarlDisableFramebuffer(UmkaStackSlot *params, UmkaStackSlot *result) {
    rlDisableFramebuffer();
}

/**
 * Umka bindings for rlActiveDrawBuffers().
 *
 * @see rlActiveDrawBuffers()
 */
RAYLIB_UMKA_FUNCTION(rlActiveDrawBuffers)
void umkarlActiveDrawBuffers(UmkaStackSlot *params, UmkaStackSlot *result) {
    int count = params[0].intVal;
    rlActiveDrawBuffers(count);
}

/**
 * Umka bindings for rlEnableColorBlend().
 *
 * @see rlEnableColorBlend()
 */
RAYLIB_UMKA_FUNCTION(rlEnableColorBlend)
void umkarlEnableColorBlend(UmkaStackSlot *params, UmkaStackSlot *result) {
    rlEnableColorBlend();
}

/**
 * Umka bindings for rlDisableColorBlend().
 *
 * @see rlDisableColorBlend()
 */
RAYLIB_UMKA_FUNCTION(rlDisableColorBlend)
void umkarlDisableColorBlend(UmkaStackSlot *params, UmkaStackSlot *result) {
    rlDisableColorBlend();
}

/**
 * Umka bindings for rlEnableDepthTest().
 *
 * @see rlEnableDepthTest()
 */
RAYLIB_UMKA_FUNCTION(rlEnableDepthTest)
void umkarlEnableDepthTest(UmkaStackSlot *params, UmkaStackSlot *result) {
    rlEnableDepthTest();
}

/**
 * Umka bindings for rlDisableDepthTest().
 *
 * @see rlDisableDepthTest()
 */
RAYLIB_UMKA_FUNCTION(rlDisableDepthTest)
void umkarlDisableDepthTest(UmkaStackSlot *params, UmkaStackSlot *result) {
    rlDisableDepthTest();
}

/**
 * Umka bindings for rlEnableDepthMask().
 *
 * @see rlEnableDepthMask()
 */
RAYLIB_UMKA_FUNCTION(rlEnableDepthMask)
void umkarlEnableDepthMask(UmkaStackSlot *params, UmkaStackSlot *result) {
    rlEnableDepthMask();
}

/**
 * Umka bindings for rlDisableDepthMask().
 *
 * @see rlDisableDepthMask()
 */
RAYLIB_UMKA_FUNCTION(rlDisableDepthMask)
void umkarlDisableDepthMask(UmkaStackSlot *params, UmkaStackSlot *result) {
    rlDisableDepthMask();
}

/**
 * Umka bindings for rlEnableBackfaceCulling().
 *
 * @see rlEnableBackfaceCulling()
 */
RAYLIB_UMKA_FUNCTION(rlEnableBackfaceCulling)
void umkarlEnableBackfaceCulling(UmkaStackSlot *params, UmkaStackSlot *result) {
    rlEnableBackfaceCulling();
}

/**
 * Umka bindings for rlDisableBackfaceCulling().
 *
 * @see rlDisableBackfaceCulling()
 */
RAYLIB_UMKA_FUNCTION(rlDisableBackfaceCulling)
void umkarlDisableBackfaceCulling(UmkaStackSlot *params, UmkaStackSlot *result) {
    rlDisableBackfaceCulling();
}

/**
 * Umka bindings for rlEnableScissorTest().
 *
 * @see rlEnableScissorTest()
 */
RAYLIB_UMKA_FUNCTION(rlEnableScissorTest)
void umkarlEnableScissorTest(UmkaStackSlot *params, UmkaStackSlot *result) {
    rlEnableScissorTest();
}

/**
 * Umka bindings for rlDisableScissorTest().
 *
 * @see rlDisableScissorTest()
 */
RAYLIB_UMKA_FUNCTION(rlDisableScissorTest)
void umkarlDisableScissorTest(UmkaStackSlot *params, UmkaStackSlot *result) {
    rlDisableScissorTest();
}

/**
 * Umka bindings for rlScissor().
 *
 * @see rlScissor()
 */
RAYLIB_UMKA_FUNCTION(rlScissor)
void umkarlScissor(UmkaStackSlot *params, UmkaStackSlot *result) {
    int x = params[3].intVal;
    int y = params[2].intVal;
    int width = params[1].intVal;
    int height = params[0].intVal;
    rlScissor(x, y, width, height);
}

/**
 * Umka bindings for rlEnableWireMode().
 *
 * @see rlEnableWireMode()
 */
RAYLIB_UMKA_FUNCTION(rlEnableWireMode)
void umkarlEnableWireMode(UmkaStackSlot *params, UmkaStackSlot *result) {
    rlEnableWireMode();
}

/**
 * Umka bindings for rlDisableWireMode().
 *
 * @see rlDisableWireMode()
 */
RAYLIB_UMKA_FUNCTION(rlDisableWireMode)
void umkarlDisableWireMode(UmkaStackSlot *params, UmkaStackSlot *result) {
    rlDisableWireMode();
}

/**
 * Umka bindings for rlSetLineWidth().
 *
 * @see rlSetLineWidth()
 */
RAYLIB_UMKA_FUNCTION(rlSetLineWidth)
void umkarlSetLineWidth(UmkaStackSlot *params, UmkaStackSlot *result) {
    float width = params[0].real32Val;
    rlSetLineWidth(width);
}

/**
 * Umka bindings for rlGetLineWidth().
 *
 * @see rlGetLineWidth()
 */
RAYLIB_UMKA_FUNCTION(rlGetLineWidth)
void umkarlGetLineWidth(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->realVal = rlGetLineWidth();
}

/**
 * Umka bindings for rlEnableSmoothLines().
 *
 * @see rlEnableSmoothLines()
 */
RAYLIB_UMKA_FUNCTION(rlEnableSmoothLines)
void umkarlEnableSmoothLines(UmkaStackSlot *params, UmkaStackSlot *result) {
    rlEnableSmoothLines();
}

/**
 * Umka bindings for rlDisableSmoothLines().
 *
 * @see rlDisableSmoothLines()
 */
RAYLIB_UMKA_FUNCTION(rlDisableSmoothLines)
void umkarlDisableSmoothLines(UmkaStackSlot *params, UmkaStackSlot *result) {
    rlDisableSmoothLines();
}

/**
 * Umka bindings for rlEnableStereoRender().
 *
 * @see rlEnableStereoRender()
 */
RAYLIB_UMKA_FUNCTION(rlEnableStereoRender)
void umkarlEnableStereoRender(UmkaStackSlot *params, UmkaStackSlot *result) {
    rlEnableStereoRender();
}

/**
 * Umka bindings for rlDisableStereoRender().
 *
 * @see rlDisableStereoRender()
 */
RAYLIB_UMKA_FUNCTION(rlDisableStereoRender)
void umkarlDisableStereoRender(UmkaStackSlot *params, UmkaStackSlot *result) {
    rlDisableStereoRender();
}

/**
 * Umka bindings for rlIsStereoRenderEnabled().
 *
 * @see rlIsStereoRenderEnabled()
 */
RAYLIB_UMKA_FUNCTION(rlIsStereoRenderEnabled)
void umkarlIsStereoRenderEnabled(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->intVal = (int)rlIsStereoRenderEnabled();
}

/**
 * Umka bindings for rlClearColor().
 *
 * @see rlClearColor()
 */
RAYLIB_UMKA_FUNCTION(rlClearColor)
void umkarlClearColor(UmkaStackSlot *params, UmkaStackSlot *result) {
    unsigned char r = params[3].uintVal;
    unsigned char g = params[2].uintVal;
    unsigned char b = params[1].uintVal;
    unsigned char a = params[0].uintVal;
    rlClearColor(r, g, b, a);
}

/**
 * Umka bindings for rlClearScreenBuffers().
 *
 * @see rlClearScreenBuffers()
 */
RAYLIB_UMKA_FUNCTION(rlClearScreenBuffers)
void umkarlClearScreenBuffers(UmkaStackSlot *params, UmkaStackSlot *result) {
    rlClearScreenBuffers();
}

/**
 * Umka bindings for rlCheckErrors().
 *
 * @see rlCheckErrors()
 */
RAYLIB_UMKA_FUNCTION(rlCheckErrors)
void umkarlCheckErrors(UmkaStackSlot *params, UmkaStackSlot *result) {
    rlCheckErrors();
}

/**
 * Umka bindings for rlSetBlendMode().
 *
 * @see rlSetBlendMode()
 */
RAYLIB_UMKA_FUNCTION(rlSetBlendMode)
void umkarlSetBlendMode(UmkaStackSlot *params, UmkaStackSlot *result) {
    int mode = params[0].intVal;
    rlSetBlendMode(mode);
}

/**
 * Umka bindings for rlSetBlendFactors().
 *
 * @see rlSetBlendFactors()
 */
RAYLIB_UMKA_FUNCTION(rlSetBlendFactors)
void umkarlSetBlendFactors(UmkaStackSlot *params, UmkaStackSlot *result) {
    int glSrcFactor = params[2].intVal;
    int glDstFactor = params[1].intVal;
    int glEquation = params[0].intVal;
    rlSetBlendFactors(glSrcFactor, glDstFactor, glEquation);
}

/**
 * Umka bindings for rlglInit().
 *
 * @see rlglInit()
 */
RAYLIB_UMKA_FUNCTION(rlglInit)
void umkarlglInit(UmkaStackSlot *params, UmkaStackSlot *result) {
    int width = params[1].intVal;
    int height = params[0].intVal;
    rlglInit(width, height);
}

/**
 * Umka bindings for rlglClose().
 *
 * @see rlglClose()
 */
RAYLIB_UMKA_FUNCTION(rlglClose)
void umkarlglClose(UmkaStackSlot *params, UmkaStackSlot *result) {
    rlglClose();
}

/**
 * Umka bindings for rlLoadExtensions().
 *
 * @see rlLoadExtensions()
 */
RAYLIB_UMKA_FUNCTION(rlLoadExtensions)
void umkarlLoadExtensions(UmkaStackSlot *params, UmkaStackSlot *result) {
    void * loader = (void *)params[0].ptrVal;
    rlLoadExtensions(loader);
}

/**
 * Umka bindings for rlGetVersion().
 *
 * @see rlGetVersion()
 */
RAYLIB_UMKA_FUNCTION(rlGetVersion)
void umkarlGetVersion(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->intVal = rlGetVersion();
}

/**
 * Umka bindings for rlSetFramebufferWidth().
 *
 * @see rlSetFramebufferWidth()
 */
RAYLIB_UMKA_FUNCTION(rlSetFramebufferWidth)
void umkarlSetFramebufferWidth(UmkaStackSlot *params, UmkaStackSlot *result) {
    int width = params[0].intVal;
    rlSetFramebufferWidth(width);
}

/**
 * Umka bindings for rlGetFramebufferWidth().
 *
 * @see rlGetFramebufferWidth()
 */
RAYLIB_UMKA_FUNCTION(rlGetFramebufferWidth)
void umkarlGetFramebufferWidth(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->intVal = rlGetFramebufferWidth();
}

/**
 * Umka bindings for rlSetFramebufferHeight().
 *
 * @see rlSetFramebufferHeight()
 */
RAYLIB_UMKA_FUNCTION(rlSetFramebufferHeight)
void umkarlSetFramebufferHeight(UmkaStackSlot *params, UmkaStackSlot *result) {
    int height = params[0].intVal;
    rlSetFramebufferHeight(height);
}

/**
 * Umka bindings for rlGetFramebufferHeight().
 *
 * @see rlGetFramebufferHeight()
 */
RAYLIB_UMKA_FUNCTION(rlGetFramebufferHeight)
void umkarlGetFramebufferHeight(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->intVal = rlGetFramebufferHeight();
}

/**
 * Umka bindings for rlGetTextureIdDefault().
 *
 * @see rlGetTextureIdDefault()
 */
RAYLIB_UMKA_FUNCTION(rlGetTextureIdDefault)
void umkarlGetTextureIdDefault(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->uintVal = rlGetTextureIdDefault();
}

/**
 * Umka bindings for rlGetShaderIdDefault().
 *
 * @see rlGetShaderIdDefault()
 */
RAYLIB_UMKA_FUNCTION(rlGetShaderIdDefault)
void umkarlGetShaderIdDefault(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->uintVal = rlGetShaderIdDefault();
}

/**
 * Umka bindings for rlGetShaderLocsDefault().
 *
 * @see rlGetShaderLocsDefault()
 */
RAYLIB_UMKA_FUNCTION(rlGetShaderLocsDefault)
void umkarlGetShaderLocsDefault(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->ptrVal = (void*)rlGetShaderLocsDefault();
}

// Function rlLoadRenderBatch() skipped

// Function rlUnloadRenderBatch() skipped

// Function rlDrawRenderBatch() skipped

// Function rlSetRenderBatchActive() skipped

/**
 * Umka bindings for rlDrawRenderBatchActive().
 *
 * @see rlDrawRenderBatchActive()
 */
RAYLIB_UMKA_FUNCTION(rlDrawRenderBatchActive)
void umkarlDrawRenderBatchActive(UmkaStackSlot *params, UmkaStackSlot *result) {
    rlDrawRenderBatchActive();
}

/**
 * Umka bindings for rlCheckRenderBatchLimit().
 *
 * @see rlCheckRenderBatchLimit()
 */
RAYLIB_UMKA_FUNCTION(rlCheckRenderBatchLimit)
void umkarlCheckRenderBatchLimit(UmkaStackSlot *params, UmkaStackSlot *result) {
    int vCount = params[0].intVal;
    result->intVal = (int)rlCheckRenderBatchLimit(vCount);
}

/**
 * Umka bindings for rlSetTexture().
 *
 * @see rlSetTexture()
 */
RAYLIB_UMKA_FUNCTION(rlSetTexture)
void umkarlSetTexture(UmkaStackSlot *params, UmkaStackSlot *result) {
    unsigned int id = params[0].uintVal;
    rlSetTexture(id);
}

/**
 * Umka bindings for rlLoadVertexArray().
 *
 * @see rlLoadVertexArray()
 */
RAYLIB_UMKA_FUNCTION(rlLoadVertexArray)
void umkarlLoadVertexArray(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->uintVal = rlLoadVertexArray();
}

/**
 * Umka bindings for rlLoadVertexBuffer().
 *
 * @see rlLoadVertexBuffer()
 */
RAYLIB_UMKA_FUNCTION(rlLoadVertexBuffer)
void umkarlLoadVertexBuffer(UmkaStackSlot *params, UmkaStackSlot *result) {
    const void * buffer = (const void *)params[2].ptrVal;
    int size = params[1].intVal;
    bool dynamic = (bool)params[0].intVal;
    result->uintVal = rlLoadVertexBuffer(buffer, size, dynamic);
}

/**
 * Umka bindings for rlLoadVertexBufferElement().
 *
 * @see rlLoadVertexBufferElement()
 */
RAYLIB_UMKA_FUNCTION(rlLoadVertexBufferElement)
void umkarlLoadVertexBufferElement(UmkaStackSlot *params, UmkaStackSlot *result) {
    const void * buffer = (const void *)params[2].ptrVal;
    int size = params[1].intVal;
    bool dynamic = (bool)params[0].intVal;
    result->uintVal = rlLoadVertexBufferElement(buffer, size, dynamic);
}

/**
 * Umka bindings for rlUpdateVertexBuffer().
 *
 * @see rlUpdateVertexBuffer()
 */
RAYLIB_UMKA_FUNCTION(rlUpdateVertexBuffer)
void umkarlUpdateVertexBuffer(UmkaStackSlot *params, UmkaStackSlot *result) {
    unsigned int bufferId = params[3].uintVal;
    const void * data = (const void *)params[2].ptrVal;
    int dataSize = params[1].intVal;
    int offset = params[0].intVal;
    rlUpdateVertexBuffer(bufferId, data, dataSize, offset);
}

/**
 * Umka bindings for rlUpdateVertexBufferElements().
 *
 * @see rlUpdateVertexBufferElements()
 */
RAYLIB_UMKA_FUNCTION(rlUpdateVertexBufferElements)
void umkarlUpdateVertexBufferElements(UmkaStackSlot *params, UmkaStackSlot *result) {
    unsigned int id = params[3].uintVal;
    const void * data = (const void *)params[2].ptrVal;
    int dataSize = params[1].intVal;
    int offset = params[0].intVal;
    rlUpdateVertexBufferElements(id, data, dataSize, offset);
}

/**
 * Umka bindings for rlUnloadVertexArray().
 *
 * @see rlUnloadVertexArray()
 */
RAYLIB_UMKA_FUNCTION(rlUnloadVertexArray)
void umkarlUnloadVertexArray(UmkaStackSlot *params, UmkaStackSlot *result) {
    unsigned int vaoId = params[0].uintVal;
    rlUnloadVertexArray(vaoId);
}

/**
 * Umka bindings for rlUnloadVertexBuffer().
 *
 * @see rlUnloadVertexBuffer()
 */
RAYLIB_UMKA_FUNCTION(rlUnloadVertexBuffer)
void umkarlUnloadVertexBuffer(UmkaStackSlot *params, UmkaStackSlot *result) {
    unsigned int vboId = params[0].uintVal;
    rlUnloadVertexBuffer(vboId);
}

/**
 * Umka bindings for rlSetVertexAttribute().
 *
 * @see rlSetVertexAttribute()
 */
RAYLIB_UMKA_FUNCTION(rlSetVertexAttribute)
void umkarlSetVertexAttribute(UmkaStackSlot *params, UmkaStackSlot *result) {
    unsigned int index = params[5].uintVal;
    int compSize = params[4].intVal;
    int type = params[3].intVal;
    bool normalized = (bool)params[2].intVal;
    int stride = params[1].intVal;
    const void * pointer = (const void *)params[0].ptrVal;
    rlSetVertexAttribute(index, compSize, type, normalized, stride, pointer);
}

/**
 * Umka bindings for rlSetVertexAttributeDivisor().
 *
 * @see rlSetVertexAttributeDivisor()
 */
RAYLIB_UMKA_FUNCTION(rlSetVertexAttributeDivisor)
void umkarlSetVertexAttributeDivisor(UmkaStackSlot *params, UmkaStackSlot *result) {
    unsigned int index = params[1].uintVal;
    int divisor = params[0].intVal;
    rlSetVertexAttributeDivisor(index, divisor);
}

/**
 * Umka bindings for rlSetVertexAttributeDefault().
 *
 * @see rlSetVertexAttributeDefault()
 */
RAYLIB_UMKA_FUNCTION(rlSetVertexAttributeDefault)
void umkarlSetVertexAttributeDefault(UmkaStackSlot *params, UmkaStackSlot *result) {
    int locIndex = params[3].intVal;
    const void * value = (const void *)params[2].ptrVal;
    int attribType = params[1].intVal;
    int count = params[0].intVal;
    rlSetVertexAttributeDefault(locIndex, value, attribType, count);
}

/**
 * Umka bindings for rlDrawVertexArray().
 *
 * @see rlDrawVertexArray()
 */
RAYLIB_UMKA_FUNCTION(rlDrawVertexArray)
void umkarlDrawVertexArray(UmkaStackSlot *params, UmkaStackSlot *result) {
    int offset = params[1].intVal;
    int count = params[0].intVal;
    rlDrawVertexArray(offset, count);
}

/**
 * Umka bindings for rlDrawVertexArrayElements().
 *
 * @see rlDrawVertexArrayElements()
 */
RAYLIB_UMKA_FUNCTION(rlDrawVertexArrayElements)
void umkarlDrawVertexArrayElements(UmkaStackSlot *params, UmkaStackSlot *result) {
    int offset = params[2].intVal;
    int count = params[1].intVal;
    const void * buffer = (const void *)params[0].ptrVal;
    rlDrawVertexArrayElements(offset, count, buffer);
}

/**
 * Umka bindings for rlDrawVertexArrayInstanced().
 *
 * @see rlDrawVertexArrayInstanced()
 */
RAYLIB_UMKA_FUNCTION(rlDrawVertexArrayInstanced)
void umkarlDrawVertexArrayInstanced(UmkaStackSlot *params, UmkaStackSlot *result) {
    int offset = params[2].intVal;
    int count = params[1].intVal;
    int instances = params[0].intVal;
    rlDrawVertexArrayInstanced(offset, count, instances);
}

/**
 * Umka bindings for rlDrawVertexArrayElementsInstanced().
 *
 * @see rlDrawVertexArrayElementsInstanced()
 */
RAYLIB_UMKA_FUNCTION(rlDrawVertexArrayElementsInstanced)
void umkarlDrawVertexArrayElementsInstanced(UmkaStackSlot *params, UmkaStackSlot *result) {
    int offset = params[3].intVal;
    int count = params[2].intVal;
    const void * buffer = (const void *)params[1].ptrVal;
    int instances = params[0].intVal;
    rlDrawVertexArrayElementsInstanced(offset, count, buffer, instances);
}

/**
 * Umka bindings for rlLoadTexture().
 *
 * @see rlLoadTexture()
 */
RAYLIB_UMKA_FUNCTION(rlLoadTexture)
void umkarlLoadTexture(UmkaStackSlot *params, UmkaStackSlot *result) {
    const void * data = (const void *)params[4].ptrVal;
    int width = params[3].intVal;
    int height = params[2].intVal;
    int format = params[1].intVal;
    int mipmapCount = params[0].intVal;
    result->uintVal = rlLoadTexture(data, width, height, format, mipmapCount);
}

/**
 * Umka bindings for rlLoadTextureDepth().
 *
 * @see rlLoadTextureDepth()
 */
RAYLIB_UMKA_FUNCTION(rlLoadTextureDepth)
void umkarlLoadTextureDepth(UmkaStackSlot *params, UmkaStackSlot *result) {
    int width = params[2].intVal;
    int height = params[1].intVal;
    bool useRenderBuffer = (bool)params[0].intVal;
    result->uintVal = rlLoadTextureDepth(width, height, useRenderBuffer);
}

/**
 * Umka bindings for rlLoadTextureCubemap().
 *
 * @see rlLoadTextureCubemap()
 */
RAYLIB_UMKA_FUNCTION(rlLoadTextureCubemap)
void umkarlLoadTextureCubemap(UmkaStackSlot *params, UmkaStackSlot *result) {
    const void * data = (const void *)params[2].ptrVal;
    int size = params[1].intVal;
    int format = params[0].intVal;
    result->uintVal = rlLoadTextureCubemap(data, size, format);
}

/**
 * Umka bindings for rlUpdateTexture().
 *
 * @see rlUpdateTexture()
 */
RAYLIB_UMKA_FUNCTION(rlUpdateTexture)
void umkarlUpdateTexture(UmkaStackSlot *params, UmkaStackSlot *result) {
    unsigned int id = params[6].uintVal;
    int offsetX = params[5].intVal;
    int offsetY = params[4].intVal;
    int width = params[3].intVal;
    int height = params[2].intVal;
    int format = params[1].intVal;
    const void * data = (const void *)params[0].ptrVal;
    rlUpdateTexture(id, offsetX, offsetY, width, height, format, data);
}

/**
 * Umka bindings for rlGetGlTextureFormats().
 *
 * @see rlGetGlTextureFormats()
 */
RAYLIB_UMKA_FUNCTION(rlGetGlTextureFormats)
void umkarlGetGlTextureFormats(UmkaStackSlot *params, UmkaStackSlot *result) {
    int format = params[3].intVal;
    unsigned int * glInternalFormat = (unsigned int *)params[2].ptrVal;
    unsigned int * glFormat = (unsigned int *)params[1].ptrVal;
    unsigned int * glType = (unsigned int *)params[0].ptrVal;
    rlGetGlTextureFormats(format, glInternalFormat, glFormat, glType);
}

/**
 * Umka bindings for rlGetPixelFormatName().
 *
 * @see rlGetPixelFormatName()
 */
RAYLIB_UMKA_FUNCTION(rlGetPixelFormatName)
void umkarlGetPixelFormatName(UmkaStackSlot *params, UmkaStackSlot *result) {
    unsigned int format = params[0].uintVal;
    result->ptrVal = (void*)rlGetPixelFormatName(format);
}

/**
 * Umka bindings for rlUnloadTexture().
 *
 * @see rlUnloadTexture()
 */
RAYLIB_UMKA_FUNCTION(rlUnloadTexture)
void umkarlUnloadTexture(UmkaStackSlot *params, UmkaStackSlot *result) {
    unsigned int id = params[0].uintVal;
    rlUnloadTexture(id);
}

/**
 * Umka bindings for rlGenTextureMipmaps().
 *
 * @see rlGenTextureMipmaps()
 */
RAYLIB_UMKA_FUNCTION(rlGenTextureMipmaps)
void umkarlGenTextureMipmaps(UmkaStackSlot *params, UmkaStackSlot *result) {
    unsigned int id = params[4].uintVal;
    int width = params[3].intVal;
    int height = params[2].intVal;
    int format = params[1].intVal;
    int * mipmaps = (int *)params[0].ptrVal;
    rlGenTextureMipmaps(id, width, height, format, mipmaps);
}

/**
 * Umka bindings for rlReadTexturePixels().
 *
 * @see rlReadTexturePixels()
 */
RAYLIB_UMKA_FUNCTION(rlReadTexturePixels)
void umkarlReadTexturePixels(UmkaStackSlot *params, UmkaStackSlot *result) {
    unsigned int id = params[3].uintVal;
    int width = params[2].intVal;
    int height = params[1].intVal;
    int format = params[0].intVal;
    result->ptrVal = (void*)rlReadTexturePixels(id, width, height, format);
}

/**
 * Umka bindings for rlReadScreenPixels().
 *
 * @see rlReadScreenPixels()
 */
RAYLIB_UMKA_FUNCTION(rlReadScreenPixels)
void umkarlReadScreenPixels(UmkaStackSlot *params, UmkaStackSlot *result) {
    int width = params[1].intVal;
    int height = params[0].intVal;
    result->ptrVal = (void*)rlReadScreenPixels(width, height);
}

/**
 * Umka bindings for rlLoadFramebuffer().
 *
 * @see rlLoadFramebuffer()
 */
RAYLIB_UMKA_FUNCTION(rlLoadFramebuffer)
void umkarlLoadFramebuffer(UmkaStackSlot *params, UmkaStackSlot *result) {
    int width = params[1].intVal;
    int height = params[0].intVal;
    result->uintVal = rlLoadFramebuffer(width, height);
}

/**
 * Umka bindings for rlFramebufferAttach().
 *
 * @see rlFramebufferAttach()
 */
RAYLIB_UMKA_FUNCTION(rlFramebufferAttach)
void umkarlFramebufferAttach(UmkaStackSlot *params, UmkaStackSlot *result) {
    unsigned int fboId = params[4].uintVal;
    unsigned int texId = params[3].uintVal;
    int attachType = params[2].intVal;
    int texType = params[1].intVal;
    int mipLevel = params[0].intVal;
    rlFramebufferAttach(fboId, texId, attachType, texType, mipLevel);
}

/**
 * Umka bindings for rlFramebufferComplete().
 *
 * @see rlFramebufferComplete()
 */
RAYLIB_UMKA_FUNCTION(rlFramebufferComplete)
void umkarlFramebufferComplete(UmkaStackSlot *params, UmkaStackSlot *result) {
    unsigned int id = params[0].uintVal;
    result->intVal = (int)rlFramebufferComplete(id);
}

/**
 * Umka bindings for rlUnloadFramebuffer().
 *
 * @see rlUnloadFramebuffer()
 */
RAYLIB_UMKA_FUNCTION(rlUnloadFramebuffer)
void umkarlUnloadFramebuffer(UmkaStackSlot *params, UmkaStackSlot *result) {
    unsigned int id = params[0].uintVal;
    rlUnloadFramebuffer(id);
}

/**
 * Umka bindings for rlLoadShaderCode().
 *
 * @see rlLoadShaderCode()
 */
RAYLIB_UMKA_FUNCTION(rlLoadShaderCode)
void umkarlLoadShaderCode(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * vsCode = (const char *)params[1].ptrVal;
    const char * fsCode = (const char *)params[0].ptrVal;
    result->uintVal = rlLoadShaderCode(vsCode, fsCode);
}

/**
 * Umka bindings for rlCompileShader().
 *
 * @see rlCompileShader()
 */
RAYLIB_UMKA_FUNCTION(rlCompileShader)
void umkarlCompileShader(UmkaStackSlot *params, UmkaStackSlot *result) {
    const char * shaderCode = (const char *)params[1].ptrVal;
    int type = params[0].intVal;
    result->uintVal = rlCompileShader(shaderCode, type);
}

/**
 * Umka bindings for rlLoadShaderProgram().
 *
 * @see rlLoadShaderProgram()
 */
RAYLIB_UMKA_FUNCTION(rlLoadShaderProgram)
void umkarlLoadShaderProgram(UmkaStackSlot *params, UmkaStackSlot *result) {
    unsigned int vShaderId = params[1].uintVal;
    unsigned int fShaderId = params[0].uintVal;
    result->uintVal = rlLoadShaderProgram(vShaderId, fShaderId);
}

/**
 * Umka bindings for rlUnloadShaderProgram().
 *
 * @see rlUnloadShaderProgram()
 */
RAYLIB_UMKA_FUNCTION(rlUnloadShaderProgram)
void umkarlUnloadShaderProgram(UmkaStackSlot *params, UmkaStackSlot *result) {
    unsigned int id = params[0].uintVal;
    rlUnloadShaderProgram(id);
}

/**
 * Umka bindings for rlGetLocationUniform().
 *
 * @see rlGetLocationUniform()
 */
RAYLIB_UMKA_FUNCTION(rlGetLocationUniform)
void umkarlGetLocationUniform(UmkaStackSlot *params, UmkaStackSlot *result) {
    unsigned int shaderId = params[1].uintVal;
    const char * uniformName = (const char *)params[0].ptrVal;
    result->intVal = rlGetLocationUniform(shaderId, uniformName);
}

/**
 * Umka bindings for rlGetLocationAttrib().
 *
 * @see rlGetLocationAttrib()
 */
RAYLIB_UMKA_FUNCTION(rlGetLocationAttrib)
void umkarlGetLocationAttrib(UmkaStackSlot *params, UmkaStackSlot *result) {
    unsigned int shaderId = params[1].uintVal;
    const char * attribName = (const char *)params[0].ptrVal;
    result->intVal = rlGetLocationAttrib(shaderId, attribName);
}

/**
 * Umka bindings for rlSetUniform().
 *
 * @see rlSetUniform()
 */
RAYLIB_UMKA_FUNCTION(rlSetUniform)
void umkarlSetUniform(UmkaStackSlot *params, UmkaStackSlot *result) {
    int locIndex = params[3].intVal;
    const void * value = (const void *)params[2].ptrVal;
    int uniformType = params[1].intVal;
    int count = params[0].intVal;
    rlSetUniform(locIndex, value, uniformType, count);
}

/**
 * Umka bindings for rlSetUniformMatrix().
 *
 * @see rlSetUniformMatrix()
 */
RAYLIB_UMKA_FUNCTION(rlSetUniformMatrix)
void umkarlSetUniformMatrix(UmkaStackSlot *params, UmkaStackSlot *result) {
    int locIndex = params[1].intVal;
    Matrix* mat = (Matrix*)&params[0];
    rlSetUniformMatrix(locIndex, *mat);
}

/**
 * Umka bindings for rlSetUniformSampler().
 *
 * @see rlSetUniformSampler()
 */
RAYLIB_UMKA_FUNCTION(rlSetUniformSampler)
void umkarlSetUniformSampler(UmkaStackSlot *params, UmkaStackSlot *result) {
    int locIndex = params[1].intVal;
    unsigned int textureId = params[0].uintVal;
    rlSetUniformSampler(locIndex, textureId);
}

/**
 * Umka bindings for rlSetShader().
 *
 * @see rlSetShader()
 */
RAYLIB_UMKA_FUNCTION(rlSetShader)
void umkarlSetShader(UmkaStackSlot *params, UmkaStackSlot *result) {
    unsigned int id = params[1].uintVal;
    int * locs = (int *)params[0].ptrVal;
    rlSetShader(id, locs);
}

/**
 * Umka bindings for rlLoadComputeShaderProgram().
 *
 * @see rlLoadComputeShaderProgram()
 */
RAYLIB_UMKA_FUNCTION(rlLoadComputeShaderProgram)
void umkarlLoadComputeShaderProgram(UmkaStackSlot *params, UmkaStackSlot *result) {
    unsigned int shaderId = params[0].uintVal;
    result->uintVal = rlLoadComputeShaderProgram(shaderId);
}

/**
 * Umka bindings for rlComputeShaderDispatch().
 *
 * @see rlComputeShaderDispatch()
 */
RAYLIB_UMKA_FUNCTION(rlComputeShaderDispatch)
void umkarlComputeShaderDispatch(UmkaStackSlot *params, UmkaStackSlot *result) {
    unsigned int groupX = params[2].uintVal;
    unsigned int groupY = params[1].uintVal;
    unsigned int groupZ = params[0].uintVal;
    rlComputeShaderDispatch(groupX, groupY, groupZ);
}

/**
 * Umka bindings for rlLoadShaderBuffer().
 *
 * @see rlLoadShaderBuffer()
 */
RAYLIB_UMKA_FUNCTION(rlLoadShaderBuffer)
void umkarlLoadShaderBuffer(UmkaStackSlot *params, UmkaStackSlot *result) {
    unsigned long long size = params[2].uintVal;
    const void * data = (const void *)params[1].ptrVal;
    int usageHint = params[0].intVal;
    result->uintVal = rlLoadShaderBuffer(size, data, usageHint);
}

/**
 * Umka bindings for rlUnloadShaderBuffer().
 *
 * @see rlUnloadShaderBuffer()
 */
RAYLIB_UMKA_FUNCTION(rlUnloadShaderBuffer)
void umkarlUnloadShaderBuffer(UmkaStackSlot *params, UmkaStackSlot *result) {
    unsigned int ssboId = params[0].uintVal;
    rlUnloadShaderBuffer(ssboId);
}

/**
 * Umka bindings for rlUpdateShaderBufferElements().
 *
 * @see rlUpdateShaderBufferElements()
 */
RAYLIB_UMKA_FUNCTION(rlUpdateShaderBufferElements)
void umkarlUpdateShaderBufferElements(UmkaStackSlot *params, UmkaStackSlot *result) {
    unsigned int id = params[3].uintVal;
    const void * data = (const void *)params[2].ptrVal;
    unsigned long long dataSize = params[1].uintVal;
    unsigned long long offset = params[0].uintVal;
    rlUpdateShaderBufferElements(id, data, dataSize, offset);
}

/**
 * Umka bindings for rlGetShaderBufferSize().
 *
 * @see rlGetShaderBufferSize()
 */
RAYLIB_UMKA_FUNCTION(rlGetShaderBufferSize)
void umkarlGetShaderBufferSize(UmkaStackSlot *params, UmkaStackSlot *result) {
    unsigned int id = params[0].uintVal;
    result->uintVal = rlGetShaderBufferSize(id);
}

/**
 * Umka bindings for rlReadShaderBufferElements().
 *
 * @see rlReadShaderBufferElements()
 */
RAYLIB_UMKA_FUNCTION(rlReadShaderBufferElements)
void umkarlReadShaderBufferElements(UmkaStackSlot *params, UmkaStackSlot *result) {
    unsigned int id = params[3].uintVal;
    void * dest = (void *)params[2].ptrVal;
    unsigned long long count = params[1].uintVal;
    unsigned long long offset = params[0].uintVal;
    rlReadShaderBufferElements(id, dest, count, offset);
}

/**
 * Umka bindings for rlBindShaderBuffer().
 *
 * @see rlBindShaderBuffer()
 */
RAYLIB_UMKA_FUNCTION(rlBindShaderBuffer)
void umkarlBindShaderBuffer(UmkaStackSlot *params, UmkaStackSlot *result) {
    unsigned int id = params[1].uintVal;
    unsigned int index = params[0].uintVal;
    rlBindShaderBuffer(id, index);
}

/**
 * Umka bindings for rlCopyBuffersElements().
 *
 * @see rlCopyBuffersElements()
 */
RAYLIB_UMKA_FUNCTION(rlCopyBuffersElements)
void umkarlCopyBuffersElements(UmkaStackSlot *params, UmkaStackSlot *result) {
    unsigned int destId = params[4].uintVal;
    unsigned int srcId = params[3].uintVal;
    unsigned long long destOffset = params[2].uintVal;
    unsigned long long srcOffset = params[1].uintVal;
    unsigned long long count = params[0].uintVal;
    rlCopyBuffersElements(destId, srcId, destOffset, srcOffset, count);
}

/**
 * Umka bindings for rlBindImageTexture().
 *
 * @see rlBindImageTexture()
 */
RAYLIB_UMKA_FUNCTION(rlBindImageTexture)
void umkarlBindImageTexture(UmkaStackSlot *params, UmkaStackSlot *result) {
    unsigned int id = params[3].uintVal;
    unsigned int index = params[2].uintVal;
    unsigned int format = params[1].uintVal;
    int readonly = params[0].intVal;
    rlBindImageTexture(id, index, format, readonly);
}

/**
 * Umka bindings for rlGetMatrixModelview().
 *
 * @see rlGetMatrixModelview()
 */
RAYLIB_UMKA_FUNCTION(rlGetMatrixModelview)
void umkarlGetMatrixModelview(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Matrix), NULL);
    Matrix out = rlGetMatrixModelview();
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Matrix));
}

/**
 * Umka bindings for rlGetMatrixProjection().
 *
 * @see rlGetMatrixProjection()
 */
RAYLIB_UMKA_FUNCTION(rlGetMatrixProjection)
void umkarlGetMatrixProjection(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Matrix), NULL);
    Matrix out = rlGetMatrixProjection();
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Matrix));
}

/**
 * Umka bindings for rlGetMatrixTransform().
 *
 * @see rlGetMatrixTransform()
 */
RAYLIB_UMKA_FUNCTION(rlGetMatrixTransform)
void umkarlGetMatrixTransform(UmkaStackSlot *params, UmkaStackSlot *result) {
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Matrix), NULL);
    Matrix out = rlGetMatrixTransform();
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Matrix));
}

/**
 * Umka bindings for rlGetMatrixProjectionStereo().
 *
 * @see rlGetMatrixProjectionStereo()
 */
RAYLIB_UMKA_FUNCTION(rlGetMatrixProjectionStereo)
void umkarlGetMatrixProjectionStereo(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    int eye = params[1].intVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Matrix), NULL);
    Matrix out = rlGetMatrixProjectionStereo(eye);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Matrix));
}

/**
 * Umka bindings for rlGetMatrixViewOffsetStereo().
 *
 * @see rlGetMatrixViewOffsetStereo()
 */
RAYLIB_UMKA_FUNCTION(rlGetMatrixViewOffsetStereo)
void umkarlGetMatrixViewOffsetStereo(UmkaStackSlot *params, UmkaStackSlot *result) {
    // Skipping params[0], as it's a reference to Umka's internal filename
    int eye = params[1].intVal;
    result->ptrVal = umkaAllocData(result->ptrVal, sizeof(Matrix), NULL);
    Matrix out = rlGetMatrixViewOffsetStereo(eye);
    RAYLIB_UMKA_MEMCPY(result->ptrVal, &out, sizeof(Matrix));
}

/**
 * Umka bindings for rlSetMatrixProjection().
 *
 * @see rlSetMatrixProjection()
 */
RAYLIB_UMKA_FUNCTION(rlSetMatrixProjection)
void umkarlSetMatrixProjection(UmkaStackSlot *params, UmkaStackSlot *result) {
    Matrix* proj = (Matrix*)&params[0];
    rlSetMatrixProjection(*proj);
}

/**
 * Umka bindings for rlSetMatrixModelview().
 *
 * @see rlSetMatrixModelview()
 */
RAYLIB_UMKA_FUNCTION(rlSetMatrixModelview)
void umkarlSetMatrixModelview(UmkaStackSlot *params, UmkaStackSlot *result) {
    Matrix* view = (Matrix*)&params[0];
    rlSetMatrixModelview(*view);
}

/**
 * Umka bindings for rlSetMatrixProjectionStereo().
 *
 * @see rlSetMatrixProjectionStereo()
 */
RAYLIB_UMKA_FUNCTION(rlSetMatrixProjectionStereo)
void umkarlSetMatrixProjectionStereo(UmkaStackSlot *params, UmkaStackSlot *result) {
    Matrix* right = (Matrix*)&params[1];
    Matrix* left = (Matrix*)&params[0];
    rlSetMatrixProjectionStereo(*right, *left);
}

/**
 * Umka bindings for rlSetMatrixViewOffsetStereo().
 *
 * @see rlSetMatrixViewOffsetStereo()
 */
RAYLIB_UMKA_FUNCTION(rlSetMatrixViewOffsetStereo)
void umkarlSetMatrixViewOffsetStereo(UmkaStackSlot *params, UmkaStackSlot *result) {
    Matrix* right = (Matrix*)&params[1];
    Matrix* left = (Matrix*)&params[0];
    rlSetMatrixViewOffsetStereo(*right, *left);
}

/**
 * Umka bindings for rlLoadDrawCube().
 *
 * @see rlLoadDrawCube()
 */
RAYLIB_UMKA_FUNCTION(rlLoadDrawCube)
void umkarlLoadDrawCube(UmkaStackSlot *params, UmkaStackSlot *result) {
    rlLoadDrawCube();
}

/**
 * Umka bindings for rlLoadDrawQuad().
 *
 * @see rlLoadDrawQuad()
 */
RAYLIB_UMKA_FUNCTION(rlLoadDrawQuad)
void umkarlLoadDrawQuad(UmkaStackSlot *params, UmkaStackSlot *result) {
    rlLoadDrawQuad();
}


/**
 * Umka implementation for TraceLog(). This is manually implemented.
 *
 * @see TraceLog()
 */
void umkaTraceLog(UmkaStackSlot *params, UmkaStackSlot *result) {
    int logType = params[1].intVal;
    const char* message = (const char*)params[0].ptrVal;
    TraceLog(logType, "%s", message);
}

#ifndef RAYLIB_UMKA_NO_ADD_MODULE
/**
 * Adds the raylib module to the given Umka instance.
 *
 * @param umka The Umka environment to add the raylib module to.
 *
 * @return TRUE when the raylib module is successfully added, FALSE otherwise.
 */
bool umkaAddRaylib(void *umka) {
    // TraceLog() -- Manually implemented.
    if (!umkaAddFunc(umka, "TraceLog", &umkaTraceLog)) {
        return false;
    }

    // InitWindow()
    if (!umkaAddFunc(umka, "InitWindow", &umkaInitWindow)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function InitWindow()");
        return false;
    }
    // WindowShouldClose()
    if (!umkaAddFunc(umka, "WindowShouldClose", &umkaWindowShouldClose)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function WindowShouldClose()");
        return false;
    }
    // CloseWindow()
    if (!umkaAddFunc(umka, "CloseWindow", &umkaCloseWindow)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function CloseWindow()");
        return false;
    }
    // IsWindowReady()
    if (!umkaAddFunc(umka, "IsWindowReady", &umkaIsWindowReady)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function IsWindowReady()");
        return false;
    }
    // IsWindowFullscreen()
    if (!umkaAddFunc(umka, "IsWindowFullscreen", &umkaIsWindowFullscreen)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function IsWindowFullscreen()");
        return false;
    }
    // IsWindowHidden()
    if (!umkaAddFunc(umka, "IsWindowHidden", &umkaIsWindowHidden)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function IsWindowHidden()");
        return false;
    }
    // IsWindowMinimized()
    if (!umkaAddFunc(umka, "IsWindowMinimized", &umkaIsWindowMinimized)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function IsWindowMinimized()");
        return false;
    }
    // IsWindowMaximized()
    if (!umkaAddFunc(umka, "IsWindowMaximized", &umkaIsWindowMaximized)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function IsWindowMaximized()");
        return false;
    }
    // IsWindowFocused()
    if (!umkaAddFunc(umka, "IsWindowFocused", &umkaIsWindowFocused)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function IsWindowFocused()");
        return false;
    }
    // IsWindowResized()
    if (!umkaAddFunc(umka, "IsWindowResized", &umkaIsWindowResized)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function IsWindowResized()");
        return false;
    }
    // IsWindowState()
    if (!umkaAddFunc(umka, "IsWindowState", &umkaIsWindowState)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function IsWindowState()");
        return false;
    }
    // SetWindowState()
    if (!umkaAddFunc(umka, "SetWindowState", &umkaSetWindowState)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetWindowState()");
        return false;
    }
    // ClearWindowState()
    if (!umkaAddFunc(umka, "ClearWindowState", &umkaClearWindowState)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ClearWindowState()");
        return false;
    }
    // ToggleFullscreen()
    if (!umkaAddFunc(umka, "ToggleFullscreen", &umkaToggleFullscreen)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ToggleFullscreen()");
        return false;
    }
    // MaximizeWindow()
    if (!umkaAddFunc(umka, "MaximizeWindow", &umkaMaximizeWindow)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function MaximizeWindow()");
        return false;
    }
    // MinimizeWindow()
    if (!umkaAddFunc(umka, "MinimizeWindow", &umkaMinimizeWindow)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function MinimizeWindow()");
        return false;
    }
    // RestoreWindow()
    if (!umkaAddFunc(umka, "RestoreWindow", &umkaRestoreWindow)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function RestoreWindow()");
        return false;
    }
    // SetWindowIcon()
    if (!umkaAddFunc(umka, "SetWindowIcon", &umkaSetWindowIcon)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetWindowIcon()");
        return false;
    }
    // SetWindowTitle()
    if (!umkaAddFunc(umka, "SetWindowTitle", &umkaSetWindowTitle)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetWindowTitle()");
        return false;
    }
    // SetWindowPosition()
    if (!umkaAddFunc(umka, "SetWindowPosition", &umkaSetWindowPosition)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetWindowPosition()");
        return false;
    }
    // SetWindowMonitor()
    if (!umkaAddFunc(umka, "SetWindowMonitor", &umkaSetWindowMonitor)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetWindowMonitor()");
        return false;
    }
    // SetWindowMinSize()
    if (!umkaAddFunc(umka, "SetWindowMinSize", &umkaSetWindowMinSize)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetWindowMinSize()");
        return false;
    }
    // SetWindowSize()
    if (!umkaAddFunc(umka, "SetWindowSize", &umkaSetWindowSize)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetWindowSize()");
        return false;
    }
    // SetWindowOpacity()
    if (!umkaAddFunc(umka, "SetWindowOpacity", &umkaSetWindowOpacity)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetWindowOpacity()");
        return false;
    }
    // GetWindowHandle()
    if (!umkaAddFunc(umka, "GetWindowHandle", &umkaGetWindowHandle)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetWindowHandle()");
        return false;
    }
    // GetScreenWidth()
    if (!umkaAddFunc(umka, "GetScreenWidth", &umkaGetScreenWidth)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetScreenWidth()");
        return false;
    }
    // GetScreenHeight()
    if (!umkaAddFunc(umka, "GetScreenHeight", &umkaGetScreenHeight)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetScreenHeight()");
        return false;
    }
    // GetRenderWidth()
    if (!umkaAddFunc(umka, "GetRenderWidth", &umkaGetRenderWidth)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetRenderWidth()");
        return false;
    }
    // GetRenderHeight()
    if (!umkaAddFunc(umka, "GetRenderHeight", &umkaGetRenderHeight)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetRenderHeight()");
        return false;
    }
    // GetMonitorCount()
    if (!umkaAddFunc(umka, "GetMonitorCount", &umkaGetMonitorCount)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetMonitorCount()");
        return false;
    }
    // GetCurrentMonitor()
    if (!umkaAddFunc(umka, "GetCurrentMonitor", &umkaGetCurrentMonitor)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetCurrentMonitor()");
        return false;
    }
    // GetMonitorPosition()
    if (!umkaAddFunc(umka, "GetMonitorPosition", &umkaGetMonitorPosition)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetMonitorPosition()");
        return false;
    }
    // GetMonitorWidth()
    if (!umkaAddFunc(umka, "GetMonitorWidth", &umkaGetMonitorWidth)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetMonitorWidth()");
        return false;
    }
    // GetMonitorHeight()
    if (!umkaAddFunc(umka, "GetMonitorHeight", &umkaGetMonitorHeight)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetMonitorHeight()");
        return false;
    }
    // GetMonitorPhysicalWidth()
    if (!umkaAddFunc(umka, "GetMonitorPhysicalWidth", &umkaGetMonitorPhysicalWidth)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetMonitorPhysicalWidth()");
        return false;
    }
    // GetMonitorPhysicalHeight()
    if (!umkaAddFunc(umka, "GetMonitorPhysicalHeight", &umkaGetMonitorPhysicalHeight)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetMonitorPhysicalHeight()");
        return false;
    }
    // GetMonitorRefreshRate()
    if (!umkaAddFunc(umka, "GetMonitorRefreshRate", &umkaGetMonitorRefreshRate)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetMonitorRefreshRate()");
        return false;
    }
    // GetWindowPosition()
    if (!umkaAddFunc(umka, "GetWindowPosition", &umkaGetWindowPosition)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetWindowPosition()");
        return false;
    }
    // GetWindowScaleDPI()
    if (!umkaAddFunc(umka, "GetWindowScaleDPI", &umkaGetWindowScaleDPI)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetWindowScaleDPI()");
        return false;
    }
    // GetMonitorName()
    if (!umkaAddFunc(umka, "GetMonitorName", &umkaGetMonitorName)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetMonitorName()");
        return false;
    }
    // SetClipboardText()
    if (!umkaAddFunc(umka, "SetClipboardText", &umkaSetClipboardText)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetClipboardText()");
        return false;
    }
    // GetClipboardText()
    if (!umkaAddFunc(umka, "GetClipboardText", &umkaGetClipboardText)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetClipboardText()");
        return false;
    }
    // EnableEventWaiting()
    if (!umkaAddFunc(umka, "EnableEventWaiting", &umkaEnableEventWaiting)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function EnableEventWaiting()");
        return false;
    }
    // DisableEventWaiting()
    if (!umkaAddFunc(umka, "DisableEventWaiting", &umkaDisableEventWaiting)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DisableEventWaiting()");
        return false;
    }
    // SwapScreenBuffer()
    if (!umkaAddFunc(umka, "SwapScreenBuffer", &umkaSwapScreenBuffer)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SwapScreenBuffer()");
        return false;
    }
    // PollInputEvents()
    if (!umkaAddFunc(umka, "PollInputEvents", &umkaPollInputEvents)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function PollInputEvents()");
        return false;
    }
    // WaitTime()
    if (!umkaAddFunc(umka, "WaitTime", &umkaWaitTime)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function WaitTime()");
        return false;
    }
    // ShowCursor()
    if (!umkaAddFunc(umka, "ShowCursor", &umkaShowCursor)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ShowCursor()");
        return false;
    }
    // HideCursor()
    if (!umkaAddFunc(umka, "HideCursor", &umkaHideCursor)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function HideCursor()");
        return false;
    }
    // IsCursorHidden()
    if (!umkaAddFunc(umka, "IsCursorHidden", &umkaIsCursorHidden)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function IsCursorHidden()");
        return false;
    }
    // EnableCursor()
    if (!umkaAddFunc(umka, "EnableCursor", &umkaEnableCursor)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function EnableCursor()");
        return false;
    }
    // DisableCursor()
    if (!umkaAddFunc(umka, "DisableCursor", &umkaDisableCursor)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DisableCursor()");
        return false;
    }
    // IsCursorOnScreen()
    if (!umkaAddFunc(umka, "IsCursorOnScreen", &umkaIsCursorOnScreen)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function IsCursorOnScreen()");
        return false;
    }
    // ClearBackground()
    if (!umkaAddFunc(umka, "ClearBackground", &umkaClearBackground)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ClearBackground()");
        return false;
    }
    // BeginDrawing()
    if (!umkaAddFunc(umka, "BeginDrawing", &umkaBeginDrawing)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function BeginDrawing()");
        return false;
    }
    // EndDrawing()
    if (!umkaAddFunc(umka, "EndDrawing", &umkaEndDrawing)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function EndDrawing()");
        return false;
    }
    // BeginMode2D()
    if (!umkaAddFunc(umka, "BeginMode2D", &umkaBeginMode2D)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function BeginMode2D()");
        return false;
    }
    // EndMode2D()
    if (!umkaAddFunc(umka, "EndMode2D", &umkaEndMode2D)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function EndMode2D()");
        return false;
    }
    // BeginMode3D()
    if (!umkaAddFunc(umka, "BeginMode3D", &umkaBeginMode3D)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function BeginMode3D()");
        return false;
    }
    // EndMode3D()
    if (!umkaAddFunc(umka, "EndMode3D", &umkaEndMode3D)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function EndMode3D()");
        return false;
    }
    // BeginTextureMode()
    if (!umkaAddFunc(umka, "BeginTextureMode", &umkaBeginTextureMode)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function BeginTextureMode()");
        return false;
    }
    // EndTextureMode()
    if (!umkaAddFunc(umka, "EndTextureMode", &umkaEndTextureMode)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function EndTextureMode()");
        return false;
    }
    // BeginShaderMode()
    if (!umkaAddFunc(umka, "BeginShaderMode", &umkaBeginShaderMode)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function BeginShaderMode()");
        return false;
    }
    // EndShaderMode()
    if (!umkaAddFunc(umka, "EndShaderMode", &umkaEndShaderMode)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function EndShaderMode()");
        return false;
    }
    // BeginBlendMode()
    if (!umkaAddFunc(umka, "BeginBlendMode", &umkaBeginBlendMode)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function BeginBlendMode()");
        return false;
    }
    // EndBlendMode()
    if (!umkaAddFunc(umka, "EndBlendMode", &umkaEndBlendMode)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function EndBlendMode()");
        return false;
    }
    // BeginScissorMode()
    if (!umkaAddFunc(umka, "BeginScissorMode", &umkaBeginScissorMode)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function BeginScissorMode()");
        return false;
    }
    // EndScissorMode()
    if (!umkaAddFunc(umka, "EndScissorMode", &umkaEndScissorMode)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function EndScissorMode()");
        return false;
    }
    // BeginVrStereoMode()
    if (!umkaAddFunc(umka, "BeginVrStereoMode", &umkaBeginVrStereoMode)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function BeginVrStereoMode()");
        return false;
    }
    // EndVrStereoMode()
    if (!umkaAddFunc(umka, "EndVrStereoMode", &umkaEndVrStereoMode)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function EndVrStereoMode()");
        return false;
    }
    // LoadVrStereoConfig()
    if (!umkaAddFunc(umka, "LoadVrStereoConfig", &umkaLoadVrStereoConfig)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadVrStereoConfig()");
        return false;
    }
    // UnloadVrStereoConfig()
    if (!umkaAddFunc(umka, "UnloadVrStereoConfig", &umkaUnloadVrStereoConfig)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UnloadVrStereoConfig()");
        return false;
    }
    // LoadShader()
    if (!umkaAddFunc(umka, "LoadShader", &umkaLoadShader)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadShader()");
        return false;
    }
    // LoadShaderFromMemory()
    if (!umkaAddFunc(umka, "LoadShaderFromMemory", &umkaLoadShaderFromMemory)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadShaderFromMemory()");
        return false;
    }
    // GetShaderLocation()
    if (!umkaAddFunc(umka, "GetShaderLocation", &umkaGetShaderLocation)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetShaderLocation()");
        return false;
    }
    // GetShaderLocationAttrib()
    if (!umkaAddFunc(umka, "GetShaderLocationAttrib", &umkaGetShaderLocationAttrib)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetShaderLocationAttrib()");
        return false;
    }
    // SetShaderValue()
    if (!umkaAddFunc(umka, "SetShaderValue", &umkaSetShaderValue)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetShaderValue()");
        return false;
    }
    // SetShaderValueV()
    if (!umkaAddFunc(umka, "SetShaderValueV", &umkaSetShaderValueV)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetShaderValueV()");
        return false;
    }
    // SetShaderValueMatrix()
    if (!umkaAddFunc(umka, "SetShaderValueMatrix", &umkaSetShaderValueMatrix)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetShaderValueMatrix()");
        return false;
    }
    // SetShaderValueTexture()
    if (!umkaAddFunc(umka, "SetShaderValueTexture", &umkaSetShaderValueTexture)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetShaderValueTexture()");
        return false;
    }
    // UnloadShader()
    if (!umkaAddFunc(umka, "UnloadShader", &umkaUnloadShader)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UnloadShader()");
        return false;
    }
    // GetMouseRay()
    if (!umkaAddFunc(umka, "GetMouseRay", &umkaGetMouseRay)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetMouseRay()");
        return false;
    }
    // GetCameraMatrix()
    if (!umkaAddFunc(umka, "GetCameraMatrix", &umkaGetCameraMatrix)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetCameraMatrix()");
        return false;
    }
    // GetCameraMatrix2D()
    if (!umkaAddFunc(umka, "GetCameraMatrix2D", &umkaGetCameraMatrix2D)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetCameraMatrix2D()");
        return false;
    }
    // GetWorldToScreen()
    if (!umkaAddFunc(umka, "GetWorldToScreen", &umkaGetWorldToScreen)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetWorldToScreen()");
        return false;
    }
    // GetScreenToWorld2D()
    if (!umkaAddFunc(umka, "GetScreenToWorld2D", &umkaGetScreenToWorld2D)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetScreenToWorld2D()");
        return false;
    }
    // GetWorldToScreenEx()
    if (!umkaAddFunc(umka, "GetWorldToScreenEx", &umkaGetWorldToScreenEx)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetWorldToScreenEx()");
        return false;
    }
    // GetWorldToScreen2D()
    if (!umkaAddFunc(umka, "GetWorldToScreen2D", &umkaGetWorldToScreen2D)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetWorldToScreen2D()");
        return false;
    }
    // SetTargetFPS()
    if (!umkaAddFunc(umka, "SetTargetFPS", &umkaSetTargetFPS)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetTargetFPS()");
        return false;
    }
    // GetFPS()
    if (!umkaAddFunc(umka, "GetFPS", &umkaGetFPS)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetFPS()");
        return false;
    }
    // GetFrameTime()
    if (!umkaAddFunc(umka, "GetFrameTime", &umkaGetFrameTime)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetFrameTime()");
        return false;
    }
    // GetTime()
    if (!umkaAddFunc(umka, "GetTime", &umkaGetTime)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetTime()");
        return false;
    }
    // GetRandomValue()
    if (!umkaAddFunc(umka, "GetRandomValue", &umkaGetRandomValue)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetRandomValue()");
        return false;
    }
    // SetRandomSeed()
    if (!umkaAddFunc(umka, "SetRandomSeed", &umkaSetRandomSeed)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetRandomSeed()");
        return false;
    }
    // TakeScreenshot()
    if (!umkaAddFunc(umka, "TakeScreenshot", &umkaTakeScreenshot)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function TakeScreenshot()");
        return false;
    }
    // SetConfigFlags()
    if (!umkaAddFunc(umka, "SetConfigFlags", &umkaSetConfigFlags)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetConfigFlags()");
        return false;
    }
    // Skipping TraceLog
    // SetTraceLogLevel()
    if (!umkaAddFunc(umka, "SetTraceLogLevel", &umkaSetTraceLogLevel)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetTraceLogLevel()");
        return false;
    }
    // MemAlloc()
    if (!umkaAddFunc(umka, "MemAlloc", &umkaMemAlloc)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function MemAlloc()");
        return false;
    }
    // MemRealloc()
    if (!umkaAddFunc(umka, "MemRealloc", &umkaMemRealloc)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function MemRealloc()");
        return false;
    }
    // MemFree()
    if (!umkaAddFunc(umka, "MemFree", &umkaMemFree)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function MemFree()");
        return false;
    }
    // OpenURL()
    if (!umkaAddFunc(umka, "OpenURL", &umkaOpenURL)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function OpenURL()");
        return false;
    }
    // Skipping SetTraceLogCallback
    // Skipping SetLoadFileDataCallback
    // Skipping SetSaveFileDataCallback
    // Skipping SetLoadFileTextCallback
    // Skipping SetSaveFileTextCallback
    // LoadFileData()
    if (!umkaAddFunc(umka, "LoadFileData", &umkaLoadFileData)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadFileData()");
        return false;
    }
    // UnloadFileData()
    if (!umkaAddFunc(umka, "UnloadFileData", &umkaUnloadFileData)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UnloadFileData()");
        return false;
    }
    // SaveFileData()
    if (!umkaAddFunc(umka, "SaveFileData", &umkaSaveFileData)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SaveFileData()");
        return false;
    }
    // ExportDataAsCode()
    if (!umkaAddFunc(umka, "ExportDataAsCode", &umkaExportDataAsCode)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ExportDataAsCode()");
        return false;
    }
    // LoadFileText()
    if (!umkaAddFunc(umka, "LoadFileText", &umkaLoadFileText)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadFileText()");
        return false;
    }
    // UnloadFileText()
    if (!umkaAddFunc(umka, "UnloadFileText", &umkaUnloadFileText)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UnloadFileText()");
        return false;
    }
    // SaveFileText()
    if (!umkaAddFunc(umka, "SaveFileText", &umkaSaveFileText)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SaveFileText()");
        return false;
    }
    // FileExists()
    if (!umkaAddFunc(umka, "FileExists", &umkaFileExists)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function FileExists()");
        return false;
    }
    // DirectoryExists()
    if (!umkaAddFunc(umka, "DirectoryExists", &umkaDirectoryExists)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DirectoryExists()");
        return false;
    }
    // IsFileExtension()
    if (!umkaAddFunc(umka, "IsFileExtension", &umkaIsFileExtension)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function IsFileExtension()");
        return false;
    }
    // GetFileLength()
    if (!umkaAddFunc(umka, "GetFileLength", &umkaGetFileLength)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetFileLength()");
        return false;
    }
    // GetFileExtension()
    if (!umkaAddFunc(umka, "GetFileExtension", &umkaGetFileExtension)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetFileExtension()");
        return false;
    }
    // GetFileName()
    if (!umkaAddFunc(umka, "GetFileName", &umkaGetFileName)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetFileName()");
        return false;
    }
    // GetFileNameWithoutExt()
    if (!umkaAddFunc(umka, "GetFileNameWithoutExt", &umkaGetFileNameWithoutExt)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetFileNameWithoutExt()");
        return false;
    }
    // GetDirectoryPath()
    if (!umkaAddFunc(umka, "GetDirectoryPath", &umkaGetDirectoryPath)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetDirectoryPath()");
        return false;
    }
    // GetPrevDirectoryPath()
    if (!umkaAddFunc(umka, "GetPrevDirectoryPath", &umkaGetPrevDirectoryPath)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetPrevDirectoryPath()");
        return false;
    }
    // GetWorkingDirectory()
    if (!umkaAddFunc(umka, "GetWorkingDirectory", &umkaGetWorkingDirectory)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetWorkingDirectory()");
        return false;
    }
    // GetApplicationDirectory()
    if (!umkaAddFunc(umka, "GetApplicationDirectory", &umkaGetApplicationDirectory)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetApplicationDirectory()");
        return false;
    }
    // ChangeDirectory()
    if (!umkaAddFunc(umka, "ChangeDirectory", &umkaChangeDirectory)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ChangeDirectory()");
        return false;
    }
    // IsPathFile()
    if (!umkaAddFunc(umka, "IsPathFile", &umkaIsPathFile)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function IsPathFile()");
        return false;
    }
    // LoadDirectoryFiles()
    if (!umkaAddFunc(umka, "LoadDirectoryFiles", &umkaLoadDirectoryFiles)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadDirectoryFiles()");
        return false;
    }
    // LoadDirectoryFilesEx()
    if (!umkaAddFunc(umka, "LoadDirectoryFilesEx", &umkaLoadDirectoryFilesEx)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadDirectoryFilesEx()");
        return false;
    }
    // UnloadDirectoryFiles()
    if (!umkaAddFunc(umka, "UnloadDirectoryFiles", &umkaUnloadDirectoryFiles)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UnloadDirectoryFiles()");
        return false;
    }
    // IsFileDropped()
    if (!umkaAddFunc(umka, "IsFileDropped", &umkaIsFileDropped)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function IsFileDropped()");
        return false;
    }
    // LoadDroppedFiles()
    if (!umkaAddFunc(umka, "LoadDroppedFiles", &umkaLoadDroppedFiles)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadDroppedFiles()");
        return false;
    }
    // UnloadDroppedFiles()
    if (!umkaAddFunc(umka, "UnloadDroppedFiles", &umkaUnloadDroppedFiles)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UnloadDroppedFiles()");
        return false;
    }
    // GetFileModTime()
    if (!umkaAddFunc(umka, "GetFileModTime", &umkaGetFileModTime)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetFileModTime()");
        return false;
    }
    // CompressData()
    if (!umkaAddFunc(umka, "CompressData", &umkaCompressData)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function CompressData()");
        return false;
    }
    // DecompressData()
    if (!umkaAddFunc(umka, "DecompressData", &umkaDecompressData)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DecompressData()");
        return false;
    }
    // EncodeDataBase64()
    if (!umkaAddFunc(umka, "EncodeDataBase64", &umkaEncodeDataBase64)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function EncodeDataBase64()");
        return false;
    }
    // DecodeDataBase64()
    if (!umkaAddFunc(umka, "DecodeDataBase64", &umkaDecodeDataBase64)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DecodeDataBase64()");
        return false;
    }
    // IsKeyPressed()
    if (!umkaAddFunc(umka, "IsKeyPressed", &umkaIsKeyPressed)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function IsKeyPressed()");
        return false;
    }
    // IsKeyDown()
    if (!umkaAddFunc(umka, "IsKeyDown", &umkaIsKeyDown)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function IsKeyDown()");
        return false;
    }
    // IsKeyReleased()
    if (!umkaAddFunc(umka, "IsKeyReleased", &umkaIsKeyReleased)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function IsKeyReleased()");
        return false;
    }
    // IsKeyUp()
    if (!umkaAddFunc(umka, "IsKeyUp", &umkaIsKeyUp)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function IsKeyUp()");
        return false;
    }
    // SetExitKey()
    if (!umkaAddFunc(umka, "SetExitKey", &umkaSetExitKey)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetExitKey()");
        return false;
    }
    // GetKeyPressed()
    if (!umkaAddFunc(umka, "GetKeyPressed", &umkaGetKeyPressed)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetKeyPressed()");
        return false;
    }
    // GetCharPressed()
    if (!umkaAddFunc(umka, "GetCharPressed", &umkaGetCharPressed)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetCharPressed()");
        return false;
    }
    // IsGamepadAvailable()
    if (!umkaAddFunc(umka, "IsGamepadAvailable", &umkaIsGamepadAvailable)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function IsGamepadAvailable()");
        return false;
    }
    // GetGamepadName()
    if (!umkaAddFunc(umka, "GetGamepadName", &umkaGetGamepadName)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetGamepadName()");
        return false;
    }
    // IsGamepadButtonPressed()
    if (!umkaAddFunc(umka, "IsGamepadButtonPressed", &umkaIsGamepadButtonPressed)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function IsGamepadButtonPressed()");
        return false;
    }
    // IsGamepadButtonDown()
    if (!umkaAddFunc(umka, "IsGamepadButtonDown", &umkaIsGamepadButtonDown)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function IsGamepadButtonDown()");
        return false;
    }
    // IsGamepadButtonReleased()
    if (!umkaAddFunc(umka, "IsGamepadButtonReleased", &umkaIsGamepadButtonReleased)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function IsGamepadButtonReleased()");
        return false;
    }
    // IsGamepadButtonUp()
    if (!umkaAddFunc(umka, "IsGamepadButtonUp", &umkaIsGamepadButtonUp)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function IsGamepadButtonUp()");
        return false;
    }
    // GetGamepadButtonPressed()
    if (!umkaAddFunc(umka, "GetGamepadButtonPressed", &umkaGetGamepadButtonPressed)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetGamepadButtonPressed()");
        return false;
    }
    // GetGamepadAxisCount()
    if (!umkaAddFunc(umka, "GetGamepadAxisCount", &umkaGetGamepadAxisCount)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetGamepadAxisCount()");
        return false;
    }
    // GetGamepadAxisMovement()
    if (!umkaAddFunc(umka, "GetGamepadAxisMovement", &umkaGetGamepadAxisMovement)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetGamepadAxisMovement()");
        return false;
    }
    // SetGamepadMappings()
    if (!umkaAddFunc(umka, "SetGamepadMappings", &umkaSetGamepadMappings)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetGamepadMappings()");
        return false;
    }
    // IsMouseButtonPressed()
    if (!umkaAddFunc(umka, "IsMouseButtonPressed", &umkaIsMouseButtonPressed)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function IsMouseButtonPressed()");
        return false;
    }
    // IsMouseButtonDown()
    if (!umkaAddFunc(umka, "IsMouseButtonDown", &umkaIsMouseButtonDown)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function IsMouseButtonDown()");
        return false;
    }
    // IsMouseButtonReleased()
    if (!umkaAddFunc(umka, "IsMouseButtonReleased", &umkaIsMouseButtonReleased)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function IsMouseButtonReleased()");
        return false;
    }
    // IsMouseButtonUp()
    if (!umkaAddFunc(umka, "IsMouseButtonUp", &umkaIsMouseButtonUp)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function IsMouseButtonUp()");
        return false;
    }
    // GetMouseX()
    if (!umkaAddFunc(umka, "GetMouseX", &umkaGetMouseX)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetMouseX()");
        return false;
    }
    // GetMouseY()
    if (!umkaAddFunc(umka, "GetMouseY", &umkaGetMouseY)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetMouseY()");
        return false;
    }
    // GetMousePosition()
    if (!umkaAddFunc(umka, "GetMousePosition", &umkaGetMousePosition)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetMousePosition()");
        return false;
    }
    // GetMouseDelta()
    if (!umkaAddFunc(umka, "GetMouseDelta", &umkaGetMouseDelta)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetMouseDelta()");
        return false;
    }
    // SetMousePosition()
    if (!umkaAddFunc(umka, "SetMousePosition", &umkaSetMousePosition)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetMousePosition()");
        return false;
    }
    // SetMouseOffset()
    if (!umkaAddFunc(umka, "SetMouseOffset", &umkaSetMouseOffset)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetMouseOffset()");
        return false;
    }
    // SetMouseScale()
    if (!umkaAddFunc(umka, "SetMouseScale", &umkaSetMouseScale)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetMouseScale()");
        return false;
    }
    // GetMouseWheelMove()
    if (!umkaAddFunc(umka, "GetMouseWheelMove", &umkaGetMouseWheelMove)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetMouseWheelMove()");
        return false;
    }
    // GetMouseWheelMoveV()
    if (!umkaAddFunc(umka, "GetMouseWheelMoveV", &umkaGetMouseWheelMoveV)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetMouseWheelMoveV()");
        return false;
    }
    // SetMouseCursor()
    if (!umkaAddFunc(umka, "SetMouseCursor", &umkaSetMouseCursor)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetMouseCursor()");
        return false;
    }
    // GetTouchX()
    if (!umkaAddFunc(umka, "GetTouchX", &umkaGetTouchX)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetTouchX()");
        return false;
    }
    // GetTouchY()
    if (!umkaAddFunc(umka, "GetTouchY", &umkaGetTouchY)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetTouchY()");
        return false;
    }
    // GetTouchPosition()
    if (!umkaAddFunc(umka, "GetTouchPosition", &umkaGetTouchPosition)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetTouchPosition()");
        return false;
    }
    // GetTouchPointId()
    if (!umkaAddFunc(umka, "GetTouchPointId", &umkaGetTouchPointId)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetTouchPointId()");
        return false;
    }
    // GetTouchPointCount()
    if (!umkaAddFunc(umka, "GetTouchPointCount", &umkaGetTouchPointCount)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetTouchPointCount()");
        return false;
    }
    // SetGesturesEnabled()
    if (!umkaAddFunc(umka, "SetGesturesEnabled", &umkaSetGesturesEnabled)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetGesturesEnabled()");
        return false;
    }
    // IsGestureDetected()
    if (!umkaAddFunc(umka, "IsGestureDetected", &umkaIsGestureDetected)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function IsGestureDetected()");
        return false;
    }
    // GetGestureDetected()
    if (!umkaAddFunc(umka, "GetGestureDetected", &umkaGetGestureDetected)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetGestureDetected()");
        return false;
    }
    // GetGestureHoldDuration()
    if (!umkaAddFunc(umka, "GetGestureHoldDuration", &umkaGetGestureHoldDuration)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetGestureHoldDuration()");
        return false;
    }
    // GetGestureDragVector()
    if (!umkaAddFunc(umka, "GetGestureDragVector", &umkaGetGestureDragVector)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetGestureDragVector()");
        return false;
    }
    // GetGestureDragAngle()
    if (!umkaAddFunc(umka, "GetGestureDragAngle", &umkaGetGestureDragAngle)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetGestureDragAngle()");
        return false;
    }
    // GetGesturePinchVector()
    if (!umkaAddFunc(umka, "GetGesturePinchVector", &umkaGetGesturePinchVector)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetGesturePinchVector()");
        return false;
    }
    // GetGesturePinchAngle()
    if (!umkaAddFunc(umka, "GetGesturePinchAngle", &umkaGetGesturePinchAngle)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetGesturePinchAngle()");
        return false;
    }
    // SetCameraMode()
    if (!umkaAddFunc(umka, "SetCameraMode", &umkaSetCameraMode)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetCameraMode()");
        return false;
    }
    // UpdateCamera()
    if (!umkaAddFunc(umka, "UpdateCamera", &umkaUpdateCamera)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UpdateCamera()");
        return false;
    }
    // SetCameraPanControl()
    if (!umkaAddFunc(umka, "SetCameraPanControl", &umkaSetCameraPanControl)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetCameraPanControl()");
        return false;
    }
    // SetCameraAltControl()
    if (!umkaAddFunc(umka, "SetCameraAltControl", &umkaSetCameraAltControl)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetCameraAltControl()");
        return false;
    }
    // SetCameraSmoothZoomControl()
    if (!umkaAddFunc(umka, "SetCameraSmoothZoomControl", &umkaSetCameraSmoothZoomControl)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetCameraSmoothZoomControl()");
        return false;
    }
    // SetCameraMoveControls()
    if (!umkaAddFunc(umka, "SetCameraMoveControls", &umkaSetCameraMoveControls)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetCameraMoveControls()");
        return false;
    }
    // SetShapesTexture()
    if (!umkaAddFunc(umka, "SetShapesTexture", &umkaSetShapesTexture)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetShapesTexture()");
        return false;
    }
    // DrawPixel()
    if (!umkaAddFunc(umka, "DrawPixel", &umkaDrawPixel)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawPixel()");
        return false;
    }
    // DrawPixelV()
    if (!umkaAddFunc(umka, "DrawPixelV", &umkaDrawPixelV)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawPixelV()");
        return false;
    }
    // DrawLine()
    if (!umkaAddFunc(umka, "DrawLine", &umkaDrawLine)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawLine()");
        return false;
    }
    // DrawLineV()
    if (!umkaAddFunc(umka, "DrawLineV", &umkaDrawLineV)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawLineV()");
        return false;
    }
    // DrawLineEx()
    if (!umkaAddFunc(umka, "DrawLineEx", &umkaDrawLineEx)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawLineEx()");
        return false;
    }
    // DrawLineBezier()
    if (!umkaAddFunc(umka, "DrawLineBezier", &umkaDrawLineBezier)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawLineBezier()");
        return false;
    }
    // DrawLineBezierQuad()
    if (!umkaAddFunc(umka, "DrawLineBezierQuad", &umkaDrawLineBezierQuad)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawLineBezierQuad()");
        return false;
    }
    // DrawLineBezierCubic()
    if (!umkaAddFunc(umka, "DrawLineBezierCubic", &umkaDrawLineBezierCubic)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawLineBezierCubic()");
        return false;
    }
    // DrawLineStrip()
    if (!umkaAddFunc(umka, "DrawLineStrip", &umkaDrawLineStrip)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawLineStrip()");
        return false;
    }
    // DrawCircle()
    if (!umkaAddFunc(umka, "DrawCircle", &umkaDrawCircle)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawCircle()");
        return false;
    }
    // DrawCircleSector()
    if (!umkaAddFunc(umka, "DrawCircleSector", &umkaDrawCircleSector)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawCircleSector()");
        return false;
    }
    // DrawCircleSectorLines()
    if (!umkaAddFunc(umka, "DrawCircleSectorLines", &umkaDrawCircleSectorLines)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawCircleSectorLines()");
        return false;
    }
    // DrawCircleGradient()
    if (!umkaAddFunc(umka, "DrawCircleGradient", &umkaDrawCircleGradient)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawCircleGradient()");
        return false;
    }
    // DrawCircleV()
    if (!umkaAddFunc(umka, "DrawCircleV", &umkaDrawCircleV)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawCircleV()");
        return false;
    }
    // DrawCircleLines()
    if (!umkaAddFunc(umka, "DrawCircleLines", &umkaDrawCircleLines)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawCircleLines()");
        return false;
    }
    // DrawEllipse()
    if (!umkaAddFunc(umka, "DrawEllipse", &umkaDrawEllipse)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawEllipse()");
        return false;
    }
    // DrawEllipseLines()
    if (!umkaAddFunc(umka, "DrawEllipseLines", &umkaDrawEllipseLines)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawEllipseLines()");
        return false;
    }
    // DrawRing()
    if (!umkaAddFunc(umka, "DrawRing", &umkaDrawRing)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawRing()");
        return false;
    }
    // DrawRingLines()
    if (!umkaAddFunc(umka, "DrawRingLines", &umkaDrawRingLines)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawRingLines()");
        return false;
    }
    // DrawRectangle()
    if (!umkaAddFunc(umka, "DrawRectangle", &umkaDrawRectangle)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawRectangle()");
        return false;
    }
    // DrawRectangleV()
    if (!umkaAddFunc(umka, "DrawRectangleV", &umkaDrawRectangleV)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawRectangleV()");
        return false;
    }
    // DrawRectangleRec()
    if (!umkaAddFunc(umka, "DrawRectangleRec", &umkaDrawRectangleRec)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawRectangleRec()");
        return false;
    }
    // DrawRectanglePro()
    if (!umkaAddFunc(umka, "DrawRectanglePro", &umkaDrawRectanglePro)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawRectanglePro()");
        return false;
    }
    // DrawRectangleGradientV()
    if (!umkaAddFunc(umka, "DrawRectangleGradientV", &umkaDrawRectangleGradientV)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawRectangleGradientV()");
        return false;
    }
    // DrawRectangleGradientH()
    if (!umkaAddFunc(umka, "DrawRectangleGradientH", &umkaDrawRectangleGradientH)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawRectangleGradientH()");
        return false;
    }
    // DrawRectangleGradientEx()
    if (!umkaAddFunc(umka, "DrawRectangleGradientEx", &umkaDrawRectangleGradientEx)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawRectangleGradientEx()");
        return false;
    }
    // DrawRectangleLines()
    if (!umkaAddFunc(umka, "DrawRectangleLines", &umkaDrawRectangleLines)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawRectangleLines()");
        return false;
    }
    // DrawRectangleLinesEx()
    if (!umkaAddFunc(umka, "DrawRectangleLinesEx", &umkaDrawRectangleLinesEx)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawRectangleLinesEx()");
        return false;
    }
    // DrawRectangleRounded()
    if (!umkaAddFunc(umka, "DrawRectangleRounded", &umkaDrawRectangleRounded)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawRectangleRounded()");
        return false;
    }
    // DrawRectangleRoundedLines()
    if (!umkaAddFunc(umka, "DrawRectangleRoundedLines", &umkaDrawRectangleRoundedLines)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawRectangleRoundedLines()");
        return false;
    }
    // DrawTriangle()
    if (!umkaAddFunc(umka, "DrawTriangle", &umkaDrawTriangle)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawTriangle()");
        return false;
    }
    // DrawTriangleLines()
    if (!umkaAddFunc(umka, "DrawTriangleLines", &umkaDrawTriangleLines)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawTriangleLines()");
        return false;
    }
    // DrawTriangleFan()
    if (!umkaAddFunc(umka, "DrawTriangleFan", &umkaDrawTriangleFan)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawTriangleFan()");
        return false;
    }
    // DrawTriangleStrip()
    if (!umkaAddFunc(umka, "DrawTriangleStrip", &umkaDrawTriangleStrip)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawTriangleStrip()");
        return false;
    }
    // DrawPoly()
    if (!umkaAddFunc(umka, "DrawPoly", &umkaDrawPoly)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawPoly()");
        return false;
    }
    // DrawPolyLines()
    if (!umkaAddFunc(umka, "DrawPolyLines", &umkaDrawPolyLines)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawPolyLines()");
        return false;
    }
    // DrawPolyLinesEx()
    if (!umkaAddFunc(umka, "DrawPolyLinesEx", &umkaDrawPolyLinesEx)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawPolyLinesEx()");
        return false;
    }
    // CheckCollisionRecs()
    if (!umkaAddFunc(umka, "CheckCollisionRecs", &umkaCheckCollisionRecs)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function CheckCollisionRecs()");
        return false;
    }
    // CheckCollisionCircles()
    if (!umkaAddFunc(umka, "CheckCollisionCircles", &umkaCheckCollisionCircles)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function CheckCollisionCircles()");
        return false;
    }
    // CheckCollisionCircleRec()
    if (!umkaAddFunc(umka, "CheckCollisionCircleRec", &umkaCheckCollisionCircleRec)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function CheckCollisionCircleRec()");
        return false;
    }
    // CheckCollisionPointRec()
    if (!umkaAddFunc(umka, "CheckCollisionPointRec", &umkaCheckCollisionPointRec)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function CheckCollisionPointRec()");
        return false;
    }
    // CheckCollisionPointCircle()
    if (!umkaAddFunc(umka, "CheckCollisionPointCircle", &umkaCheckCollisionPointCircle)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function CheckCollisionPointCircle()");
        return false;
    }
    // CheckCollisionPointTriangle()
    if (!umkaAddFunc(umka, "CheckCollisionPointTriangle", &umkaCheckCollisionPointTriangle)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function CheckCollisionPointTriangle()");
        return false;
    }
    // CheckCollisionLines()
    if (!umkaAddFunc(umka, "CheckCollisionLines", &umkaCheckCollisionLines)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function CheckCollisionLines()");
        return false;
    }
    // CheckCollisionPointLine()
    if (!umkaAddFunc(umka, "CheckCollisionPointLine", &umkaCheckCollisionPointLine)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function CheckCollisionPointLine()");
        return false;
    }
    // GetCollisionRec()
    if (!umkaAddFunc(umka, "GetCollisionRec", &umkaGetCollisionRec)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetCollisionRec()");
        return false;
    }
    // LoadImage()
    if (!umkaAddFunc(umka, "LoadImage", &umkaLoadImage)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadImage()");
        return false;
    }
    // LoadImageRaw()
    if (!umkaAddFunc(umka, "LoadImageRaw", &umkaLoadImageRaw)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadImageRaw()");
        return false;
    }
    // LoadImageAnim()
    if (!umkaAddFunc(umka, "LoadImageAnim", &umkaLoadImageAnim)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadImageAnim()");
        return false;
    }
    // LoadImageFromMemory()
    if (!umkaAddFunc(umka, "LoadImageFromMemory", &umkaLoadImageFromMemory)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadImageFromMemory()");
        return false;
    }
    // LoadImageFromTexture()
    if (!umkaAddFunc(umka, "LoadImageFromTexture", &umkaLoadImageFromTexture)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadImageFromTexture()");
        return false;
    }
    // LoadImageFromScreen()
    if (!umkaAddFunc(umka, "LoadImageFromScreen", &umkaLoadImageFromScreen)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadImageFromScreen()");
        return false;
    }
    // UnloadImage()
    if (!umkaAddFunc(umka, "UnloadImage", &umkaUnloadImage)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UnloadImage()");
        return false;
    }
    // ExportImage()
    if (!umkaAddFunc(umka, "ExportImage", &umkaExportImage)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ExportImage()");
        return false;
    }
    // ExportImageAsCode()
    if (!umkaAddFunc(umka, "ExportImageAsCode", &umkaExportImageAsCode)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ExportImageAsCode()");
        return false;
    }
    // GenImageColor()
    if (!umkaAddFunc(umka, "GenImageColor", &umkaGenImageColor)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GenImageColor()");
        return false;
    }
    // GenImageGradientV()
    if (!umkaAddFunc(umka, "GenImageGradientV", &umkaGenImageGradientV)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GenImageGradientV()");
        return false;
    }
    // GenImageGradientH()
    if (!umkaAddFunc(umka, "GenImageGradientH", &umkaGenImageGradientH)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GenImageGradientH()");
        return false;
    }
    // GenImageGradientRadial()
    if (!umkaAddFunc(umka, "GenImageGradientRadial", &umkaGenImageGradientRadial)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GenImageGradientRadial()");
        return false;
    }
    // GenImageChecked()
    if (!umkaAddFunc(umka, "GenImageChecked", &umkaGenImageChecked)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GenImageChecked()");
        return false;
    }
    // GenImageWhiteNoise()
    if (!umkaAddFunc(umka, "GenImageWhiteNoise", &umkaGenImageWhiteNoise)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GenImageWhiteNoise()");
        return false;
    }
    // GenImageCellular()
    if (!umkaAddFunc(umka, "GenImageCellular", &umkaGenImageCellular)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GenImageCellular()");
        return false;
    }
    // ImageCopy()
    if (!umkaAddFunc(umka, "ImageCopy", &umkaImageCopy)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageCopy()");
        return false;
    }
    // ImageFromImage()
    if (!umkaAddFunc(umka, "ImageFromImage", &umkaImageFromImage)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageFromImage()");
        return false;
    }
    // ImageText()
    if (!umkaAddFunc(umka, "ImageText", &umkaImageText)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageText()");
        return false;
    }
    // ImageTextEx()
    if (!umkaAddFunc(umka, "ImageTextEx", &umkaImageTextEx)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageTextEx()");
        return false;
    }
    // ImageFormat()
    if (!umkaAddFunc(umka, "ImageFormat", &umkaImageFormat)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageFormat()");
        return false;
    }
    // ImageToPOT()
    if (!umkaAddFunc(umka, "ImageToPOT", &umkaImageToPOT)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageToPOT()");
        return false;
    }
    // ImageCrop()
    if (!umkaAddFunc(umka, "ImageCrop", &umkaImageCrop)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageCrop()");
        return false;
    }
    // ImageAlphaCrop()
    if (!umkaAddFunc(umka, "ImageAlphaCrop", &umkaImageAlphaCrop)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageAlphaCrop()");
        return false;
    }
    // ImageAlphaClear()
    if (!umkaAddFunc(umka, "ImageAlphaClear", &umkaImageAlphaClear)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageAlphaClear()");
        return false;
    }
    // ImageAlphaMask()
    if (!umkaAddFunc(umka, "ImageAlphaMask", &umkaImageAlphaMask)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageAlphaMask()");
        return false;
    }
    // ImageAlphaPremultiply()
    if (!umkaAddFunc(umka, "ImageAlphaPremultiply", &umkaImageAlphaPremultiply)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageAlphaPremultiply()");
        return false;
    }
    // ImageResize()
    if (!umkaAddFunc(umka, "ImageResize", &umkaImageResize)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageResize()");
        return false;
    }
    // ImageResizeNN()
    if (!umkaAddFunc(umka, "ImageResizeNN", &umkaImageResizeNN)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageResizeNN()");
        return false;
    }
    // ImageResizeCanvas()
    if (!umkaAddFunc(umka, "ImageResizeCanvas", &umkaImageResizeCanvas)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageResizeCanvas()");
        return false;
    }
    // ImageMipmaps()
    if (!umkaAddFunc(umka, "ImageMipmaps", &umkaImageMipmaps)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageMipmaps()");
        return false;
    }
    // ImageDither()
    if (!umkaAddFunc(umka, "ImageDither", &umkaImageDither)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageDither()");
        return false;
    }
    // ImageFlipVertical()
    if (!umkaAddFunc(umka, "ImageFlipVertical", &umkaImageFlipVertical)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageFlipVertical()");
        return false;
    }
    // ImageFlipHorizontal()
    if (!umkaAddFunc(umka, "ImageFlipHorizontal", &umkaImageFlipHorizontal)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageFlipHorizontal()");
        return false;
    }
    // ImageRotateCW()
    if (!umkaAddFunc(umka, "ImageRotateCW", &umkaImageRotateCW)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageRotateCW()");
        return false;
    }
    // ImageRotateCCW()
    if (!umkaAddFunc(umka, "ImageRotateCCW", &umkaImageRotateCCW)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageRotateCCW()");
        return false;
    }
    // ImageColorTint()
    if (!umkaAddFunc(umka, "ImageColorTint", &umkaImageColorTint)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageColorTint()");
        return false;
    }
    // ImageColorInvert()
    if (!umkaAddFunc(umka, "ImageColorInvert", &umkaImageColorInvert)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageColorInvert()");
        return false;
    }
    // ImageColorGrayscale()
    if (!umkaAddFunc(umka, "ImageColorGrayscale", &umkaImageColorGrayscale)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageColorGrayscale()");
        return false;
    }
    // ImageColorContrast()
    if (!umkaAddFunc(umka, "ImageColorContrast", &umkaImageColorContrast)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageColorContrast()");
        return false;
    }
    // ImageColorBrightness()
    if (!umkaAddFunc(umka, "ImageColorBrightness", &umkaImageColorBrightness)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageColorBrightness()");
        return false;
    }
    // ImageColorReplace()
    if (!umkaAddFunc(umka, "ImageColorReplace", &umkaImageColorReplace)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageColorReplace()");
        return false;
    }
    // LoadImageColors()
    if (!umkaAddFunc(umka, "LoadImageColors", &umkaLoadImageColors)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadImageColors()");
        return false;
    }
    // LoadImagePalette()
    if (!umkaAddFunc(umka, "LoadImagePalette", &umkaLoadImagePalette)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadImagePalette()");
        return false;
    }
    // UnloadImageColors()
    if (!umkaAddFunc(umka, "UnloadImageColors", &umkaUnloadImageColors)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UnloadImageColors()");
        return false;
    }
    // UnloadImagePalette()
    if (!umkaAddFunc(umka, "UnloadImagePalette", &umkaUnloadImagePalette)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UnloadImagePalette()");
        return false;
    }
    // GetImageAlphaBorder()
    if (!umkaAddFunc(umka, "GetImageAlphaBorder", &umkaGetImageAlphaBorder)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetImageAlphaBorder()");
        return false;
    }
    // GetImageColor()
    if (!umkaAddFunc(umka, "GetImageColor", &umkaGetImageColor)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetImageColor()");
        return false;
    }
    // ImageClearBackground()
    if (!umkaAddFunc(umka, "ImageClearBackground", &umkaImageClearBackground)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageClearBackground()");
        return false;
    }
    // ImageDrawPixel()
    if (!umkaAddFunc(umka, "ImageDrawPixel", &umkaImageDrawPixel)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageDrawPixel()");
        return false;
    }
    // ImageDrawPixelV()
    if (!umkaAddFunc(umka, "ImageDrawPixelV", &umkaImageDrawPixelV)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageDrawPixelV()");
        return false;
    }
    // ImageDrawLine()
    if (!umkaAddFunc(umka, "ImageDrawLine", &umkaImageDrawLine)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageDrawLine()");
        return false;
    }
    // ImageDrawLineV()
    if (!umkaAddFunc(umka, "ImageDrawLineV", &umkaImageDrawLineV)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageDrawLineV()");
        return false;
    }
    // ImageDrawCircle()
    if (!umkaAddFunc(umka, "ImageDrawCircle", &umkaImageDrawCircle)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageDrawCircle()");
        return false;
    }
    // ImageDrawCircleV()
    if (!umkaAddFunc(umka, "ImageDrawCircleV", &umkaImageDrawCircleV)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageDrawCircleV()");
        return false;
    }
    // ImageDrawRectangle()
    if (!umkaAddFunc(umka, "ImageDrawRectangle", &umkaImageDrawRectangle)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageDrawRectangle()");
        return false;
    }
    // ImageDrawRectangleV()
    if (!umkaAddFunc(umka, "ImageDrawRectangleV", &umkaImageDrawRectangleV)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageDrawRectangleV()");
        return false;
    }
    // ImageDrawRectangleRec()
    if (!umkaAddFunc(umka, "ImageDrawRectangleRec", &umkaImageDrawRectangleRec)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageDrawRectangleRec()");
        return false;
    }
    // ImageDrawRectangleLines()
    if (!umkaAddFunc(umka, "ImageDrawRectangleLines", &umkaImageDrawRectangleLines)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageDrawRectangleLines()");
        return false;
    }
    // ImageDraw()
    if (!umkaAddFunc(umka, "ImageDraw", &umkaImageDraw)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageDraw()");
        return false;
    }
    // ImageDrawText()
    if (!umkaAddFunc(umka, "ImageDrawText", &umkaImageDrawText)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageDrawText()");
        return false;
    }
    // ImageDrawTextEx()
    if (!umkaAddFunc(umka, "ImageDrawTextEx", &umkaImageDrawTextEx)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ImageDrawTextEx()");
        return false;
    }
    // LoadTexture()
    if (!umkaAddFunc(umka, "LoadTexture", &umkaLoadTexture)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadTexture()");
        return false;
    }
    // LoadTextureFromImage()
    if (!umkaAddFunc(umka, "LoadTextureFromImage", &umkaLoadTextureFromImage)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadTextureFromImage()");
        return false;
    }
    // LoadTextureCubemap()
    if (!umkaAddFunc(umka, "LoadTextureCubemap", &umkaLoadTextureCubemap)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadTextureCubemap()");
        return false;
    }
    // LoadRenderTexture()
    if (!umkaAddFunc(umka, "LoadRenderTexture", &umkaLoadRenderTexture)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadRenderTexture()");
        return false;
    }
    // UnloadTexture()
    if (!umkaAddFunc(umka, "UnloadTexture", &umkaUnloadTexture)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UnloadTexture()");
        return false;
    }
    // UnloadRenderTexture()
    if (!umkaAddFunc(umka, "UnloadRenderTexture", &umkaUnloadRenderTexture)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UnloadRenderTexture()");
        return false;
    }
    // UpdateTexture()
    if (!umkaAddFunc(umka, "UpdateTexture", &umkaUpdateTexture)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UpdateTexture()");
        return false;
    }
    // UpdateTextureRec()
    if (!umkaAddFunc(umka, "UpdateTextureRec", &umkaUpdateTextureRec)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UpdateTextureRec()");
        return false;
    }
    // GenTextureMipmaps()
    if (!umkaAddFunc(umka, "GenTextureMipmaps", &umkaGenTextureMipmaps)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GenTextureMipmaps()");
        return false;
    }
    // SetTextureFilter()
    if (!umkaAddFunc(umka, "SetTextureFilter", &umkaSetTextureFilter)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetTextureFilter()");
        return false;
    }
    // SetTextureWrap()
    if (!umkaAddFunc(umka, "SetTextureWrap", &umkaSetTextureWrap)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetTextureWrap()");
        return false;
    }
    // DrawTexture()
    if (!umkaAddFunc(umka, "DrawTexture", &umkaDrawTexture)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawTexture()");
        return false;
    }
    // DrawTextureV()
    if (!umkaAddFunc(umka, "DrawTextureV", &umkaDrawTextureV)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawTextureV()");
        return false;
    }
    // DrawTextureEx()
    if (!umkaAddFunc(umka, "DrawTextureEx", &umkaDrawTextureEx)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawTextureEx()");
        return false;
    }
    // DrawTextureRec()
    if (!umkaAddFunc(umka, "DrawTextureRec", &umkaDrawTextureRec)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawTextureRec()");
        return false;
    }
    // DrawTextureQuad()
    if (!umkaAddFunc(umka, "DrawTextureQuad", &umkaDrawTextureQuad)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawTextureQuad()");
        return false;
    }
    // DrawTextureTiled()
    if (!umkaAddFunc(umka, "DrawTextureTiled", &umkaDrawTextureTiled)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawTextureTiled()");
        return false;
    }
    // DrawTexturePro()
    if (!umkaAddFunc(umka, "DrawTexturePro", &umkaDrawTexturePro)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawTexturePro()");
        return false;
    }
    // DrawTextureNPatch()
    if (!umkaAddFunc(umka, "DrawTextureNPatch", &umkaDrawTextureNPatch)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawTextureNPatch()");
        return false;
    }
    // DrawTexturePoly()
    if (!umkaAddFunc(umka, "DrawTexturePoly", &umkaDrawTexturePoly)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawTexturePoly()");
        return false;
    }
    // Fade()
    if (!umkaAddFunc(umka, "Fade", &umkaFade)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Fade()");
        return false;
    }
    // ColorToInt()
    if (!umkaAddFunc(umka, "ColorToInt", &umkaColorToInt)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ColorToInt()");
        return false;
    }
    // ColorNormalize()
    if (!umkaAddFunc(umka, "ColorNormalize", &umkaColorNormalize)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ColorNormalize()");
        return false;
    }
    // ColorFromNormalized()
    if (!umkaAddFunc(umka, "ColorFromNormalized", &umkaColorFromNormalized)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ColorFromNormalized()");
        return false;
    }
    // ColorToHSV()
    if (!umkaAddFunc(umka, "ColorToHSV", &umkaColorToHSV)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ColorToHSV()");
        return false;
    }
    // ColorFromHSV()
    if (!umkaAddFunc(umka, "ColorFromHSV", &umkaColorFromHSV)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ColorFromHSV()");
        return false;
    }
    // ColorAlpha()
    if (!umkaAddFunc(umka, "ColorAlpha", &umkaColorAlpha)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ColorAlpha()");
        return false;
    }
    // ColorAlphaBlend()
    if (!umkaAddFunc(umka, "ColorAlphaBlend", &umkaColorAlphaBlend)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ColorAlphaBlend()");
        return false;
    }
    // GetColor()
    if (!umkaAddFunc(umka, "GetColor", &umkaGetColor)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetColor()");
        return false;
    }
    // GetPixelColor()
    if (!umkaAddFunc(umka, "GetPixelColor", &umkaGetPixelColor)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetPixelColor()");
        return false;
    }
    // SetPixelColor()
    if (!umkaAddFunc(umka, "SetPixelColor", &umkaSetPixelColor)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetPixelColor()");
        return false;
    }
    // GetPixelDataSize()
    if (!umkaAddFunc(umka, "GetPixelDataSize", &umkaGetPixelDataSize)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetPixelDataSize()");
        return false;
    }
    // GetFontDefault()
    if (!umkaAddFunc(umka, "GetFontDefault", &umkaGetFontDefault)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetFontDefault()");
        return false;
    }
    // LoadFont()
    if (!umkaAddFunc(umka, "LoadFont", &umkaLoadFont)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadFont()");
        return false;
    }
    // LoadFontEx()
    if (!umkaAddFunc(umka, "LoadFontEx", &umkaLoadFontEx)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadFontEx()");
        return false;
    }
    // LoadFontFromImage()
    if (!umkaAddFunc(umka, "LoadFontFromImage", &umkaLoadFontFromImage)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadFontFromImage()");
        return false;
    }
    // LoadFontFromMemory()
    if (!umkaAddFunc(umka, "LoadFontFromMemory", &umkaLoadFontFromMemory)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadFontFromMemory()");
        return false;
    }
    // Skipping LoadFontData
    // GenImageFontAtlas()
    if (!umkaAddFunc(umka, "GenImageFontAtlas", &umkaGenImageFontAtlas)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GenImageFontAtlas()");
        return false;
    }
    // UnloadFontData()
    if (!umkaAddFunc(umka, "UnloadFontData", &umkaUnloadFontData)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UnloadFontData()");
        return false;
    }
    // UnloadFont()
    if (!umkaAddFunc(umka, "UnloadFont", &umkaUnloadFont)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UnloadFont()");
        return false;
    }
    // ExportFontAsCode()
    if (!umkaAddFunc(umka, "ExportFontAsCode", &umkaExportFontAsCode)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ExportFontAsCode()");
        return false;
    }
    // DrawFPS()
    if (!umkaAddFunc(umka, "DrawFPS", &umkaDrawFPS)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawFPS()");
        return false;
    }
    // DrawText()
    if (!umkaAddFunc(umka, "DrawText", &umkaDrawText)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawText()");
        return false;
    }
    // DrawTextEx()
    if (!umkaAddFunc(umka, "DrawTextEx", &umkaDrawTextEx)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawTextEx()");
        return false;
    }
    // DrawTextPro()
    if (!umkaAddFunc(umka, "DrawTextPro", &umkaDrawTextPro)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawTextPro()");
        return false;
    }
    // DrawTextCodepoint()
    if (!umkaAddFunc(umka, "DrawTextCodepoint", &umkaDrawTextCodepoint)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawTextCodepoint()");
        return false;
    }
    // DrawTextCodepoints()
    if (!umkaAddFunc(umka, "DrawTextCodepoints", &umkaDrawTextCodepoints)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawTextCodepoints()");
        return false;
    }
    // MeasureText()
    if (!umkaAddFunc(umka, "MeasureText", &umkaMeasureText)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function MeasureText()");
        return false;
    }
    // MeasureTextEx()
    if (!umkaAddFunc(umka, "MeasureTextEx", &umkaMeasureTextEx)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function MeasureTextEx()");
        return false;
    }
    // GetGlyphIndex()
    if (!umkaAddFunc(umka, "GetGlyphIndex", &umkaGetGlyphIndex)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetGlyphIndex()");
        return false;
    }
    // GetGlyphInfo()
    if (!umkaAddFunc(umka, "GetGlyphInfo", &umkaGetGlyphInfo)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetGlyphInfo()");
        return false;
    }
    // GetGlyphAtlasRec()
    if (!umkaAddFunc(umka, "GetGlyphAtlasRec", &umkaGetGlyphAtlasRec)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetGlyphAtlasRec()");
        return false;
    }
    // LoadCodepoints()
    if (!umkaAddFunc(umka, "LoadCodepoints", &umkaLoadCodepoints)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadCodepoints()");
        return false;
    }
    // UnloadCodepoints()
    if (!umkaAddFunc(umka, "UnloadCodepoints", &umkaUnloadCodepoints)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UnloadCodepoints()");
        return false;
    }
    // GetCodepointCount()
    if (!umkaAddFunc(umka, "GetCodepointCount", &umkaGetCodepointCount)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetCodepointCount()");
        return false;
    }
    // GetCodepoint()
    if (!umkaAddFunc(umka, "GetCodepoint", &umkaGetCodepoint)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetCodepoint()");
        return false;
    }
    // CodepointToUTF8()
    if (!umkaAddFunc(umka, "CodepointToUTF8", &umkaCodepointToUTF8)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function CodepointToUTF8()");
        return false;
    }
    // TextCodepointsToUTF8()
    if (!umkaAddFunc(umka, "TextCodepointsToUTF8", &umkaTextCodepointsToUTF8)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function TextCodepointsToUTF8()");
        return false;
    }
    // TextCopy()
    if (!umkaAddFunc(umka, "TextCopy", &umkaTextCopy)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function TextCopy()");
        return false;
    }
    // TextIsEqual()
    if (!umkaAddFunc(umka, "TextIsEqual", &umkaTextIsEqual)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function TextIsEqual()");
        return false;
    }
    // TextLength()
    if (!umkaAddFunc(umka, "TextLength", &umkaTextLength)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function TextLength()");
        return false;
    }
    // Skipping TextFormat
    // TextSubtext()
    if (!umkaAddFunc(umka, "TextSubtext", &umkaTextSubtext)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function TextSubtext()");
        return false;
    }
    // TextReplace()
    if (!umkaAddFunc(umka, "TextReplace", &umkaTextReplace)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function TextReplace()");
        return false;
    }
    // TextInsert()
    if (!umkaAddFunc(umka, "TextInsert", &umkaTextInsert)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function TextInsert()");
        return false;
    }
    // TextJoin()
    if (!umkaAddFunc(umka, "TextJoin", &umkaTextJoin)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function TextJoin()");
        return false;
    }
    // TextSplit()
    if (!umkaAddFunc(umka, "TextSplit", &umkaTextSplit)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function TextSplit()");
        return false;
    }
    // TextAppend()
    if (!umkaAddFunc(umka, "TextAppend", &umkaTextAppend)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function TextAppend()");
        return false;
    }
    // TextFindIndex()
    if (!umkaAddFunc(umka, "TextFindIndex", &umkaTextFindIndex)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function TextFindIndex()");
        return false;
    }
    // TextToUpper()
    if (!umkaAddFunc(umka, "TextToUpper", &umkaTextToUpper)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function TextToUpper()");
        return false;
    }
    // TextToLower()
    if (!umkaAddFunc(umka, "TextToLower", &umkaTextToLower)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function TextToLower()");
        return false;
    }
    // TextToPascal()
    if (!umkaAddFunc(umka, "TextToPascal", &umkaTextToPascal)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function TextToPascal()");
        return false;
    }
    // TextToInteger()
    if (!umkaAddFunc(umka, "TextToInteger", &umkaTextToInteger)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function TextToInteger()");
        return false;
    }
    // DrawLine3D()
    if (!umkaAddFunc(umka, "DrawLine3D", &umkaDrawLine3D)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawLine3D()");
        return false;
    }
    // DrawPoint3D()
    if (!umkaAddFunc(umka, "DrawPoint3D", &umkaDrawPoint3D)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawPoint3D()");
        return false;
    }
    // DrawCircle3D()
    if (!umkaAddFunc(umka, "DrawCircle3D", &umkaDrawCircle3D)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawCircle3D()");
        return false;
    }
    // DrawTriangle3D()
    if (!umkaAddFunc(umka, "DrawTriangle3D", &umkaDrawTriangle3D)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawTriangle3D()");
        return false;
    }
    // DrawTriangleStrip3D()
    if (!umkaAddFunc(umka, "DrawTriangleStrip3D", &umkaDrawTriangleStrip3D)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawTriangleStrip3D()");
        return false;
    }
    // DrawCube()
    if (!umkaAddFunc(umka, "DrawCube", &umkaDrawCube)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawCube()");
        return false;
    }
    // DrawCubeV()
    if (!umkaAddFunc(umka, "DrawCubeV", &umkaDrawCubeV)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawCubeV()");
        return false;
    }
    // DrawCubeWires()
    if (!umkaAddFunc(umka, "DrawCubeWires", &umkaDrawCubeWires)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawCubeWires()");
        return false;
    }
    // DrawCubeWiresV()
    if (!umkaAddFunc(umka, "DrawCubeWiresV", &umkaDrawCubeWiresV)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawCubeWiresV()");
        return false;
    }
    // DrawCubeTexture()
    if (!umkaAddFunc(umka, "DrawCubeTexture", &umkaDrawCubeTexture)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawCubeTexture()");
        return false;
    }
    // DrawCubeTextureRec()
    if (!umkaAddFunc(umka, "DrawCubeTextureRec", &umkaDrawCubeTextureRec)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawCubeTextureRec()");
        return false;
    }
    // DrawSphere()
    if (!umkaAddFunc(umka, "DrawSphere", &umkaDrawSphere)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawSphere()");
        return false;
    }
    // DrawSphereEx()
    if (!umkaAddFunc(umka, "DrawSphereEx", &umkaDrawSphereEx)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawSphereEx()");
        return false;
    }
    // DrawSphereWires()
    if (!umkaAddFunc(umka, "DrawSphereWires", &umkaDrawSphereWires)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawSphereWires()");
        return false;
    }
    // DrawCylinder()
    if (!umkaAddFunc(umka, "DrawCylinder", &umkaDrawCylinder)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawCylinder()");
        return false;
    }
    // DrawCylinderEx()
    if (!umkaAddFunc(umka, "DrawCylinderEx", &umkaDrawCylinderEx)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawCylinderEx()");
        return false;
    }
    // DrawCylinderWires()
    if (!umkaAddFunc(umka, "DrawCylinderWires", &umkaDrawCylinderWires)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawCylinderWires()");
        return false;
    }
    // DrawCylinderWiresEx()
    if (!umkaAddFunc(umka, "DrawCylinderWiresEx", &umkaDrawCylinderWiresEx)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawCylinderWiresEx()");
        return false;
    }
    // DrawPlane()
    if (!umkaAddFunc(umka, "DrawPlane", &umkaDrawPlane)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawPlane()");
        return false;
    }
    // DrawRay()
    if (!umkaAddFunc(umka, "DrawRay", &umkaDrawRay)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawRay()");
        return false;
    }
    // DrawGrid()
    if (!umkaAddFunc(umka, "DrawGrid", &umkaDrawGrid)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawGrid()");
        return false;
    }
    // LoadModel()
    if (!umkaAddFunc(umka, "LoadModel", &umkaLoadModel)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadModel()");
        return false;
    }
    // LoadModelFromMesh()
    if (!umkaAddFunc(umka, "LoadModelFromMesh", &umkaLoadModelFromMesh)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadModelFromMesh()");
        return false;
    }
    // UnloadModel()
    if (!umkaAddFunc(umka, "UnloadModel", &umkaUnloadModel)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UnloadModel()");
        return false;
    }
    // UnloadModelKeepMeshes()
    if (!umkaAddFunc(umka, "UnloadModelKeepMeshes", &umkaUnloadModelKeepMeshes)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UnloadModelKeepMeshes()");
        return false;
    }
    // GetModelBoundingBox()
    if (!umkaAddFunc(umka, "GetModelBoundingBox", &umkaGetModelBoundingBox)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetModelBoundingBox()");
        return false;
    }
    // DrawModel()
    if (!umkaAddFunc(umka, "DrawModel", &umkaDrawModel)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawModel()");
        return false;
    }
    // DrawModelEx()
    if (!umkaAddFunc(umka, "DrawModelEx", &umkaDrawModelEx)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawModelEx()");
        return false;
    }
    // DrawModelWires()
    if (!umkaAddFunc(umka, "DrawModelWires", &umkaDrawModelWires)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawModelWires()");
        return false;
    }
    // DrawModelWiresEx()
    if (!umkaAddFunc(umka, "DrawModelWiresEx", &umkaDrawModelWiresEx)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawModelWiresEx()");
        return false;
    }
    // DrawBoundingBox()
    if (!umkaAddFunc(umka, "DrawBoundingBox", &umkaDrawBoundingBox)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawBoundingBox()");
        return false;
    }
    // DrawBillboard()
    if (!umkaAddFunc(umka, "DrawBillboard", &umkaDrawBillboard)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawBillboard()");
        return false;
    }
    // DrawBillboardRec()
    if (!umkaAddFunc(umka, "DrawBillboardRec", &umkaDrawBillboardRec)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawBillboardRec()");
        return false;
    }
    // DrawBillboardPro()
    if (!umkaAddFunc(umka, "DrawBillboardPro", &umkaDrawBillboardPro)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawBillboardPro()");
        return false;
    }
    // UploadMesh()
    if (!umkaAddFunc(umka, "UploadMesh", &umkaUploadMesh)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UploadMesh()");
        return false;
    }
    // UpdateMeshBuffer()
    if (!umkaAddFunc(umka, "UpdateMeshBuffer", &umkaUpdateMeshBuffer)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UpdateMeshBuffer()");
        return false;
    }
    // UnloadMesh()
    if (!umkaAddFunc(umka, "UnloadMesh", &umkaUnloadMesh)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UnloadMesh()");
        return false;
    }
    // DrawMesh()
    if (!umkaAddFunc(umka, "DrawMesh", &umkaDrawMesh)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawMesh()");
        return false;
    }
    // DrawMeshInstanced()
    if (!umkaAddFunc(umka, "DrawMeshInstanced", &umkaDrawMeshInstanced)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function DrawMeshInstanced()");
        return false;
    }
    // ExportMesh()
    if (!umkaAddFunc(umka, "ExportMesh", &umkaExportMesh)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ExportMesh()");
        return false;
    }
    // GetMeshBoundingBox()
    if (!umkaAddFunc(umka, "GetMeshBoundingBox", &umkaGetMeshBoundingBox)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetMeshBoundingBox()");
        return false;
    }
    // GenMeshTangents()
    if (!umkaAddFunc(umka, "GenMeshTangents", &umkaGenMeshTangents)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GenMeshTangents()");
        return false;
    }
    // GenMeshPoly()
    if (!umkaAddFunc(umka, "GenMeshPoly", &umkaGenMeshPoly)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GenMeshPoly()");
        return false;
    }
    // GenMeshPlane()
    if (!umkaAddFunc(umka, "GenMeshPlane", &umkaGenMeshPlane)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GenMeshPlane()");
        return false;
    }
    // GenMeshCube()
    if (!umkaAddFunc(umka, "GenMeshCube", &umkaGenMeshCube)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GenMeshCube()");
        return false;
    }
    // GenMeshSphere()
    if (!umkaAddFunc(umka, "GenMeshSphere", &umkaGenMeshSphere)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GenMeshSphere()");
        return false;
    }
    // GenMeshHemiSphere()
    if (!umkaAddFunc(umka, "GenMeshHemiSphere", &umkaGenMeshHemiSphere)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GenMeshHemiSphere()");
        return false;
    }
    // GenMeshCylinder()
    if (!umkaAddFunc(umka, "GenMeshCylinder", &umkaGenMeshCylinder)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GenMeshCylinder()");
        return false;
    }
    // GenMeshCone()
    if (!umkaAddFunc(umka, "GenMeshCone", &umkaGenMeshCone)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GenMeshCone()");
        return false;
    }
    // GenMeshTorus()
    if (!umkaAddFunc(umka, "GenMeshTorus", &umkaGenMeshTorus)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GenMeshTorus()");
        return false;
    }
    // GenMeshKnot()
    if (!umkaAddFunc(umka, "GenMeshKnot", &umkaGenMeshKnot)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GenMeshKnot()");
        return false;
    }
    // GenMeshHeightmap()
    if (!umkaAddFunc(umka, "GenMeshHeightmap", &umkaGenMeshHeightmap)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GenMeshHeightmap()");
        return false;
    }
    // GenMeshCubicmap()
    if (!umkaAddFunc(umka, "GenMeshCubicmap", &umkaGenMeshCubicmap)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GenMeshCubicmap()");
        return false;
    }
    // LoadMaterials()
    if (!umkaAddFunc(umka, "LoadMaterials", &umkaLoadMaterials)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadMaterials()");
        return false;
    }
    // LoadMaterialDefault()
    if (!umkaAddFunc(umka, "LoadMaterialDefault", &umkaLoadMaterialDefault)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadMaterialDefault()");
        return false;
    }
    // UnloadMaterial()
    if (!umkaAddFunc(umka, "UnloadMaterial", &umkaUnloadMaterial)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UnloadMaterial()");
        return false;
    }
    // SetMaterialTexture()
    if (!umkaAddFunc(umka, "SetMaterialTexture", &umkaSetMaterialTexture)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetMaterialTexture()");
        return false;
    }
    // SetModelMeshMaterial()
    if (!umkaAddFunc(umka, "SetModelMeshMaterial", &umkaSetModelMeshMaterial)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetModelMeshMaterial()");
        return false;
    }
    // LoadModelAnimations()
    if (!umkaAddFunc(umka, "LoadModelAnimations", &umkaLoadModelAnimations)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadModelAnimations()");
        return false;
    }
    // UpdateModelAnimation()
    if (!umkaAddFunc(umka, "UpdateModelAnimation", &umkaUpdateModelAnimation)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UpdateModelAnimation()");
        return false;
    }
    // UnloadModelAnimation()
    if (!umkaAddFunc(umka, "UnloadModelAnimation", &umkaUnloadModelAnimation)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UnloadModelAnimation()");
        return false;
    }
    // UnloadModelAnimations()
    if (!umkaAddFunc(umka, "UnloadModelAnimations", &umkaUnloadModelAnimations)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UnloadModelAnimations()");
        return false;
    }
    // IsModelAnimationValid()
    if (!umkaAddFunc(umka, "IsModelAnimationValid", &umkaIsModelAnimationValid)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function IsModelAnimationValid()");
        return false;
    }
    // CheckCollisionSpheres()
    if (!umkaAddFunc(umka, "CheckCollisionSpheres", &umkaCheckCollisionSpheres)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function CheckCollisionSpheres()");
        return false;
    }
    // CheckCollisionBoxes()
    if (!umkaAddFunc(umka, "CheckCollisionBoxes", &umkaCheckCollisionBoxes)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function CheckCollisionBoxes()");
        return false;
    }
    // CheckCollisionBoxSphere()
    if (!umkaAddFunc(umka, "CheckCollisionBoxSphere", &umkaCheckCollisionBoxSphere)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function CheckCollisionBoxSphere()");
        return false;
    }
    // GetRayCollisionSphere()
    if (!umkaAddFunc(umka, "GetRayCollisionSphere", &umkaGetRayCollisionSphere)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetRayCollisionSphere()");
        return false;
    }
    // GetRayCollisionBox()
    if (!umkaAddFunc(umka, "GetRayCollisionBox", &umkaGetRayCollisionBox)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetRayCollisionBox()");
        return false;
    }
    // GetRayCollisionMesh()
    if (!umkaAddFunc(umka, "GetRayCollisionMesh", &umkaGetRayCollisionMesh)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetRayCollisionMesh()");
        return false;
    }
    // GetRayCollisionTriangle()
    if (!umkaAddFunc(umka, "GetRayCollisionTriangle", &umkaGetRayCollisionTriangle)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetRayCollisionTriangle()");
        return false;
    }
    // GetRayCollisionQuad()
    if (!umkaAddFunc(umka, "GetRayCollisionQuad", &umkaGetRayCollisionQuad)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetRayCollisionQuad()");
        return false;
    }
    // InitAudioDevice()
    if (!umkaAddFunc(umka, "InitAudioDevice", &umkaInitAudioDevice)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function InitAudioDevice()");
        return false;
    }
    // CloseAudioDevice()
    if (!umkaAddFunc(umka, "CloseAudioDevice", &umkaCloseAudioDevice)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function CloseAudioDevice()");
        return false;
    }
    // IsAudioDeviceReady()
    if (!umkaAddFunc(umka, "IsAudioDeviceReady", &umkaIsAudioDeviceReady)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function IsAudioDeviceReady()");
        return false;
    }
    // SetMasterVolume()
    if (!umkaAddFunc(umka, "SetMasterVolume", &umkaSetMasterVolume)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetMasterVolume()");
        return false;
    }
    // LoadWave()
    if (!umkaAddFunc(umka, "LoadWave", &umkaLoadWave)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadWave()");
        return false;
    }
    // LoadWaveFromMemory()
    if (!umkaAddFunc(umka, "LoadWaveFromMemory", &umkaLoadWaveFromMemory)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadWaveFromMemory()");
        return false;
    }
    // LoadSound()
    if (!umkaAddFunc(umka, "LoadSound", &umkaLoadSound)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadSound()");
        return false;
    }
    // LoadSoundFromWave()
    if (!umkaAddFunc(umka, "LoadSoundFromWave", &umkaLoadSoundFromWave)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadSoundFromWave()");
        return false;
    }
    // UpdateSound()
    if (!umkaAddFunc(umka, "UpdateSound", &umkaUpdateSound)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UpdateSound()");
        return false;
    }
    // UnloadWave()
    if (!umkaAddFunc(umka, "UnloadWave", &umkaUnloadWave)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UnloadWave()");
        return false;
    }
    // UnloadSound()
    if (!umkaAddFunc(umka, "UnloadSound", &umkaUnloadSound)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UnloadSound()");
        return false;
    }
    // ExportWave()
    if (!umkaAddFunc(umka, "ExportWave", &umkaExportWave)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ExportWave()");
        return false;
    }
    // ExportWaveAsCode()
    if (!umkaAddFunc(umka, "ExportWaveAsCode", &umkaExportWaveAsCode)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ExportWaveAsCode()");
        return false;
    }
    // PlaySound()
    if (!umkaAddFunc(umka, "PlaySound", &umkaPlaySound)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function PlaySound()");
        return false;
    }
    // StopSound()
    if (!umkaAddFunc(umka, "StopSound", &umkaStopSound)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function StopSound()");
        return false;
    }
    // PauseSound()
    if (!umkaAddFunc(umka, "PauseSound", &umkaPauseSound)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function PauseSound()");
        return false;
    }
    // ResumeSound()
    if (!umkaAddFunc(umka, "ResumeSound", &umkaResumeSound)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ResumeSound()");
        return false;
    }
    // PlaySoundMulti()
    if (!umkaAddFunc(umka, "PlaySoundMulti", &umkaPlaySoundMulti)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function PlaySoundMulti()");
        return false;
    }
    // StopSoundMulti()
    if (!umkaAddFunc(umka, "StopSoundMulti", &umkaStopSoundMulti)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function StopSoundMulti()");
        return false;
    }
    // GetSoundsPlaying()
    if (!umkaAddFunc(umka, "GetSoundsPlaying", &umkaGetSoundsPlaying)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetSoundsPlaying()");
        return false;
    }
    // IsSoundPlaying()
    if (!umkaAddFunc(umka, "IsSoundPlaying", &umkaIsSoundPlaying)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function IsSoundPlaying()");
        return false;
    }
    // SetSoundVolume()
    if (!umkaAddFunc(umka, "SetSoundVolume", &umkaSetSoundVolume)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetSoundVolume()");
        return false;
    }
    // SetSoundPitch()
    if (!umkaAddFunc(umka, "SetSoundPitch", &umkaSetSoundPitch)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetSoundPitch()");
        return false;
    }
    // SetSoundPan()
    if (!umkaAddFunc(umka, "SetSoundPan", &umkaSetSoundPan)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetSoundPan()");
        return false;
    }
    // WaveCopy()
    if (!umkaAddFunc(umka, "WaveCopy", &umkaWaveCopy)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function WaveCopy()");
        return false;
    }
    // WaveCrop()
    if (!umkaAddFunc(umka, "WaveCrop", &umkaWaveCrop)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function WaveCrop()");
        return false;
    }
    // WaveFormat()
    if (!umkaAddFunc(umka, "WaveFormat", &umkaWaveFormat)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function WaveFormat()");
        return false;
    }
    // LoadWaveSamples()
    if (!umkaAddFunc(umka, "LoadWaveSamples", &umkaLoadWaveSamples)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadWaveSamples()");
        return false;
    }
    // UnloadWaveSamples()
    if (!umkaAddFunc(umka, "UnloadWaveSamples", &umkaUnloadWaveSamples)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UnloadWaveSamples()");
        return false;
    }
    // LoadMusicStream()
    if (!umkaAddFunc(umka, "LoadMusicStream", &umkaLoadMusicStream)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadMusicStream()");
        return false;
    }
    // LoadMusicStreamFromMemory()
    if (!umkaAddFunc(umka, "LoadMusicStreamFromMemory", &umkaLoadMusicStreamFromMemory)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadMusicStreamFromMemory()");
        return false;
    }
    // UnloadMusicStream()
    if (!umkaAddFunc(umka, "UnloadMusicStream", &umkaUnloadMusicStream)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UnloadMusicStream()");
        return false;
    }
    // PlayMusicStream()
    if (!umkaAddFunc(umka, "PlayMusicStream", &umkaPlayMusicStream)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function PlayMusicStream()");
        return false;
    }
    // IsMusicStreamPlaying()
    if (!umkaAddFunc(umka, "IsMusicStreamPlaying", &umkaIsMusicStreamPlaying)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function IsMusicStreamPlaying()");
        return false;
    }
    // UpdateMusicStream()
    if (!umkaAddFunc(umka, "UpdateMusicStream", &umkaUpdateMusicStream)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UpdateMusicStream()");
        return false;
    }
    // StopMusicStream()
    if (!umkaAddFunc(umka, "StopMusicStream", &umkaStopMusicStream)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function StopMusicStream()");
        return false;
    }
    // PauseMusicStream()
    if (!umkaAddFunc(umka, "PauseMusicStream", &umkaPauseMusicStream)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function PauseMusicStream()");
        return false;
    }
    // ResumeMusicStream()
    if (!umkaAddFunc(umka, "ResumeMusicStream", &umkaResumeMusicStream)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ResumeMusicStream()");
        return false;
    }
    // SeekMusicStream()
    if (!umkaAddFunc(umka, "SeekMusicStream", &umkaSeekMusicStream)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SeekMusicStream()");
        return false;
    }
    // SetMusicVolume()
    if (!umkaAddFunc(umka, "SetMusicVolume", &umkaSetMusicVolume)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetMusicVolume()");
        return false;
    }
    // SetMusicPitch()
    if (!umkaAddFunc(umka, "SetMusicPitch", &umkaSetMusicPitch)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetMusicPitch()");
        return false;
    }
    // SetMusicPan()
    if (!umkaAddFunc(umka, "SetMusicPan", &umkaSetMusicPan)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetMusicPan()");
        return false;
    }
    // GetMusicTimeLength()
    if (!umkaAddFunc(umka, "GetMusicTimeLength", &umkaGetMusicTimeLength)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetMusicTimeLength()");
        return false;
    }
    // GetMusicTimePlayed()
    if (!umkaAddFunc(umka, "GetMusicTimePlayed", &umkaGetMusicTimePlayed)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function GetMusicTimePlayed()");
        return false;
    }
    // LoadAudioStream()
    if (!umkaAddFunc(umka, "LoadAudioStream", &umkaLoadAudioStream)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function LoadAudioStream()");
        return false;
    }
    // UnloadAudioStream()
    if (!umkaAddFunc(umka, "UnloadAudioStream", &umkaUnloadAudioStream)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UnloadAudioStream()");
        return false;
    }
    // UpdateAudioStream()
    if (!umkaAddFunc(umka, "UpdateAudioStream", &umkaUpdateAudioStream)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function UpdateAudioStream()");
        return false;
    }
    // IsAudioStreamProcessed()
    if (!umkaAddFunc(umka, "IsAudioStreamProcessed", &umkaIsAudioStreamProcessed)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function IsAudioStreamProcessed()");
        return false;
    }
    // PlayAudioStream()
    if (!umkaAddFunc(umka, "PlayAudioStream", &umkaPlayAudioStream)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function PlayAudioStream()");
        return false;
    }
    // PauseAudioStream()
    if (!umkaAddFunc(umka, "PauseAudioStream", &umkaPauseAudioStream)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function PauseAudioStream()");
        return false;
    }
    // ResumeAudioStream()
    if (!umkaAddFunc(umka, "ResumeAudioStream", &umkaResumeAudioStream)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function ResumeAudioStream()");
        return false;
    }
    // IsAudioStreamPlaying()
    if (!umkaAddFunc(umka, "IsAudioStreamPlaying", &umkaIsAudioStreamPlaying)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function IsAudioStreamPlaying()");
        return false;
    }
    // StopAudioStream()
    if (!umkaAddFunc(umka, "StopAudioStream", &umkaStopAudioStream)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function StopAudioStream()");
        return false;
    }
    // SetAudioStreamVolume()
    if (!umkaAddFunc(umka, "SetAudioStreamVolume", &umkaSetAudioStreamVolume)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetAudioStreamVolume()");
        return false;
    }
    // SetAudioStreamPitch()
    if (!umkaAddFunc(umka, "SetAudioStreamPitch", &umkaSetAudioStreamPitch)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetAudioStreamPitch()");
        return false;
    }
    // SetAudioStreamPan()
    if (!umkaAddFunc(umka, "SetAudioStreamPan", &umkaSetAudioStreamPan)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetAudioStreamPan()");
        return false;
    }
    // SetAudioStreamBufferSizeDefault()
    if (!umkaAddFunc(umka, "SetAudioStreamBufferSizeDefault", &umkaSetAudioStreamBufferSizeDefault)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function SetAudioStreamBufferSizeDefault()");
        return false;
    }
    // Skipping SetAudioStreamCallback
    // Skipping AttachAudioStreamProcessor
    // Skipping DetachAudioStreamProcessor
    // Clamp()
    if (!umkaAddFunc(umka, "Clamp", &umkaClamp)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Clamp()");
        return false;
    }
    // Lerp()
    if (!umkaAddFunc(umka, "Lerp", &umkaLerp)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Lerp()");
        return false;
    }
    // Normalize()
    if (!umkaAddFunc(umka, "Normalize", &umkaNormalize)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Normalize()");
        return false;
    }
    // Remap()
    if (!umkaAddFunc(umka, "Remap", &umkaRemap)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Remap()");
        return false;
    }
    // Wrap()
    if (!umkaAddFunc(umka, "Wrap", &umkaWrap)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Wrap()");
        return false;
    }
    // FloatEquals()
    if (!umkaAddFunc(umka, "FloatEquals", &umkaFloatEquals)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function FloatEquals()");
        return false;
    }
    // Vector2Zero()
    if (!umkaAddFunc(umka, "Vector2Zero", &umkaVector2Zero)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector2Zero()");
        return false;
    }
    // Vector2One()
    if (!umkaAddFunc(umka, "Vector2One", &umkaVector2One)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector2One()");
        return false;
    }
    // Vector2Add()
    if (!umkaAddFunc(umka, "Vector2Add", &umkaVector2Add)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector2Add()");
        return false;
    }
    // Vector2AddValue()
    if (!umkaAddFunc(umka, "Vector2AddValue", &umkaVector2AddValue)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector2AddValue()");
        return false;
    }
    // Vector2Subtract()
    if (!umkaAddFunc(umka, "Vector2Subtract", &umkaVector2Subtract)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector2Subtract()");
        return false;
    }
    // Vector2SubtractValue()
    if (!umkaAddFunc(umka, "Vector2SubtractValue", &umkaVector2SubtractValue)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector2SubtractValue()");
        return false;
    }
    // Vector2Length()
    if (!umkaAddFunc(umka, "Vector2Length", &umkaVector2Length)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector2Length()");
        return false;
    }
    // Vector2LengthSqr()
    if (!umkaAddFunc(umka, "Vector2LengthSqr", &umkaVector2LengthSqr)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector2LengthSqr()");
        return false;
    }
    // Vector2DotProduct()
    if (!umkaAddFunc(umka, "Vector2DotProduct", &umkaVector2DotProduct)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector2DotProduct()");
        return false;
    }
    // Vector2Distance()
    if (!umkaAddFunc(umka, "Vector2Distance", &umkaVector2Distance)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector2Distance()");
        return false;
    }
    // Vector2DistanceSqr()
    if (!umkaAddFunc(umka, "Vector2DistanceSqr", &umkaVector2DistanceSqr)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector2DistanceSqr()");
        return false;
    }
    // Vector2Angle()
    if (!umkaAddFunc(umka, "Vector2Angle", &umkaVector2Angle)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector2Angle()");
        return false;
    }
    // Vector2Scale()
    if (!umkaAddFunc(umka, "Vector2Scale", &umkaVector2Scale)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector2Scale()");
        return false;
    }
    // Vector2Multiply()
    if (!umkaAddFunc(umka, "Vector2Multiply", &umkaVector2Multiply)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector2Multiply()");
        return false;
    }
    // Vector2Negate()
    if (!umkaAddFunc(umka, "Vector2Negate", &umkaVector2Negate)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector2Negate()");
        return false;
    }
    // Vector2Divide()
    if (!umkaAddFunc(umka, "Vector2Divide", &umkaVector2Divide)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector2Divide()");
        return false;
    }
    // Vector2Normalize()
    if (!umkaAddFunc(umka, "Vector2Normalize", &umkaVector2Normalize)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector2Normalize()");
        return false;
    }
    // Vector2Transform()
    if (!umkaAddFunc(umka, "Vector2Transform", &umkaVector2Transform)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector2Transform()");
        return false;
    }
    // Vector2Lerp()
    if (!umkaAddFunc(umka, "Vector2Lerp", &umkaVector2Lerp)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector2Lerp()");
        return false;
    }
    // Vector2Reflect()
    if (!umkaAddFunc(umka, "Vector2Reflect", &umkaVector2Reflect)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector2Reflect()");
        return false;
    }
    // Vector2Rotate()
    if (!umkaAddFunc(umka, "Vector2Rotate", &umkaVector2Rotate)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector2Rotate()");
        return false;
    }
    // Vector2MoveTowards()
    if (!umkaAddFunc(umka, "Vector2MoveTowards", &umkaVector2MoveTowards)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector2MoveTowards()");
        return false;
    }
    // Vector2Invert()
    if (!umkaAddFunc(umka, "Vector2Invert", &umkaVector2Invert)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector2Invert()");
        return false;
    }
    // Vector2Clamp()
    if (!umkaAddFunc(umka, "Vector2Clamp", &umkaVector2Clamp)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector2Clamp()");
        return false;
    }
    // Vector2ClampValue()
    if (!umkaAddFunc(umka, "Vector2ClampValue", &umkaVector2ClampValue)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector2ClampValue()");
        return false;
    }
    // Vector2Equals()
    if (!umkaAddFunc(umka, "Vector2Equals", &umkaVector2Equals)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector2Equals()");
        return false;
    }
    // Vector3Zero()
    if (!umkaAddFunc(umka, "Vector3Zero", &umkaVector3Zero)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3Zero()");
        return false;
    }
    // Vector3One()
    if (!umkaAddFunc(umka, "Vector3One", &umkaVector3One)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3One()");
        return false;
    }
    // Vector3Add()
    if (!umkaAddFunc(umka, "Vector3Add", &umkaVector3Add)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3Add()");
        return false;
    }
    // Vector3AddValue()
    if (!umkaAddFunc(umka, "Vector3AddValue", &umkaVector3AddValue)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3AddValue()");
        return false;
    }
    // Vector3Subtract()
    if (!umkaAddFunc(umka, "Vector3Subtract", &umkaVector3Subtract)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3Subtract()");
        return false;
    }
    // Vector3SubtractValue()
    if (!umkaAddFunc(umka, "Vector3SubtractValue", &umkaVector3SubtractValue)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3SubtractValue()");
        return false;
    }
    // Vector3Scale()
    if (!umkaAddFunc(umka, "Vector3Scale", &umkaVector3Scale)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3Scale()");
        return false;
    }
    // Vector3Multiply()
    if (!umkaAddFunc(umka, "Vector3Multiply", &umkaVector3Multiply)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3Multiply()");
        return false;
    }
    // Vector3CrossProduct()
    if (!umkaAddFunc(umka, "Vector3CrossProduct", &umkaVector3CrossProduct)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3CrossProduct()");
        return false;
    }
    // Vector3Perpendicular()
    if (!umkaAddFunc(umka, "Vector3Perpendicular", &umkaVector3Perpendicular)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3Perpendicular()");
        return false;
    }
    // Vector3Length()
    if (!umkaAddFunc(umka, "Vector3Length", &umkaVector3Length)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3Length()");
        return false;
    }
    // Vector3LengthSqr()
    if (!umkaAddFunc(umka, "Vector3LengthSqr", &umkaVector3LengthSqr)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3LengthSqr()");
        return false;
    }
    // Vector3DotProduct()
    if (!umkaAddFunc(umka, "Vector3DotProduct", &umkaVector3DotProduct)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3DotProduct()");
        return false;
    }
    // Vector3Distance()
    if (!umkaAddFunc(umka, "Vector3Distance", &umkaVector3Distance)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3Distance()");
        return false;
    }
    // Vector3DistanceSqr()
    if (!umkaAddFunc(umka, "Vector3DistanceSqr", &umkaVector3DistanceSqr)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3DistanceSqr()");
        return false;
    }
    // Vector3Angle()
    if (!umkaAddFunc(umka, "Vector3Angle", &umkaVector3Angle)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3Angle()");
        return false;
    }
    // Vector3Negate()
    if (!umkaAddFunc(umka, "Vector3Negate", &umkaVector3Negate)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3Negate()");
        return false;
    }
    // Vector3Divide()
    if (!umkaAddFunc(umka, "Vector3Divide", &umkaVector3Divide)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3Divide()");
        return false;
    }
    // Vector3Normalize()
    if (!umkaAddFunc(umka, "Vector3Normalize", &umkaVector3Normalize)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3Normalize()");
        return false;
    }
    // Vector3OrthoNormalize()
    if (!umkaAddFunc(umka, "Vector3OrthoNormalize", &umkaVector3OrthoNormalize)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3OrthoNormalize()");
        return false;
    }
    // Vector3Transform()
    if (!umkaAddFunc(umka, "Vector3Transform", &umkaVector3Transform)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3Transform()");
        return false;
    }
    // Vector3RotateByQuaternion()
    if (!umkaAddFunc(umka, "Vector3RotateByQuaternion", &umkaVector3RotateByQuaternion)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3RotateByQuaternion()");
        return false;
    }
    // Vector3RotateByAxisAngle()
    if (!umkaAddFunc(umka, "Vector3RotateByAxisAngle", &umkaVector3RotateByAxisAngle)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3RotateByAxisAngle()");
        return false;
    }
    // Vector3Lerp()
    if (!umkaAddFunc(umka, "Vector3Lerp", &umkaVector3Lerp)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3Lerp()");
        return false;
    }
    // Vector3Reflect()
    if (!umkaAddFunc(umka, "Vector3Reflect", &umkaVector3Reflect)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3Reflect()");
        return false;
    }
    // Vector3Min()
    if (!umkaAddFunc(umka, "Vector3Min", &umkaVector3Min)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3Min()");
        return false;
    }
    // Vector3Max()
    if (!umkaAddFunc(umka, "Vector3Max", &umkaVector3Max)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3Max()");
        return false;
    }
    // Vector3Barycenter()
    if (!umkaAddFunc(umka, "Vector3Barycenter", &umkaVector3Barycenter)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3Barycenter()");
        return false;
    }
    // Vector3Unproject()
    if (!umkaAddFunc(umka, "Vector3Unproject", &umkaVector3Unproject)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3Unproject()");
        return false;
    }
    // Vector3ToFloatV()
    if (!umkaAddFunc(umka, "Vector3ToFloatV", &umkaVector3ToFloatV)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3ToFloatV()");
        return false;
    }
    // Vector3Invert()
    if (!umkaAddFunc(umka, "Vector3Invert", &umkaVector3Invert)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3Invert()");
        return false;
    }
    // Vector3Clamp()
    if (!umkaAddFunc(umka, "Vector3Clamp", &umkaVector3Clamp)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3Clamp()");
        return false;
    }
    // Vector3ClampValue()
    if (!umkaAddFunc(umka, "Vector3ClampValue", &umkaVector3ClampValue)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3ClampValue()");
        return false;
    }
    // Vector3Equals()
    if (!umkaAddFunc(umka, "Vector3Equals", &umkaVector3Equals)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3Equals()");
        return false;
    }
    // Vector3Refract()
    if (!umkaAddFunc(umka, "Vector3Refract", &umkaVector3Refract)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function Vector3Refract()");
        return false;
    }
    // MatrixDeterminant()
    if (!umkaAddFunc(umka, "MatrixDeterminant", &umkaMatrixDeterminant)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function MatrixDeterminant()");
        return false;
    }
    // MatrixTrace()
    if (!umkaAddFunc(umka, "MatrixTrace", &umkaMatrixTrace)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function MatrixTrace()");
        return false;
    }
    // MatrixTranspose()
    if (!umkaAddFunc(umka, "MatrixTranspose", &umkaMatrixTranspose)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function MatrixTranspose()");
        return false;
    }
    // MatrixInvert()
    if (!umkaAddFunc(umka, "MatrixInvert", &umkaMatrixInvert)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function MatrixInvert()");
        return false;
    }
    // MatrixIdentity()
    if (!umkaAddFunc(umka, "MatrixIdentity", &umkaMatrixIdentity)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function MatrixIdentity()");
        return false;
    }
    // MatrixAdd()
    if (!umkaAddFunc(umka, "MatrixAdd", &umkaMatrixAdd)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function MatrixAdd()");
        return false;
    }
    // MatrixSubtract()
    if (!umkaAddFunc(umka, "MatrixSubtract", &umkaMatrixSubtract)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function MatrixSubtract()");
        return false;
    }
    // MatrixMultiply()
    if (!umkaAddFunc(umka, "MatrixMultiply", &umkaMatrixMultiply)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function MatrixMultiply()");
        return false;
    }
    // MatrixTranslate()
    if (!umkaAddFunc(umka, "MatrixTranslate", &umkaMatrixTranslate)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function MatrixTranslate()");
        return false;
    }
    // MatrixRotate()
    if (!umkaAddFunc(umka, "MatrixRotate", &umkaMatrixRotate)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function MatrixRotate()");
        return false;
    }
    // MatrixRotateX()
    if (!umkaAddFunc(umka, "MatrixRotateX", &umkaMatrixRotateX)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function MatrixRotateX()");
        return false;
    }
    // MatrixRotateY()
    if (!umkaAddFunc(umka, "MatrixRotateY", &umkaMatrixRotateY)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function MatrixRotateY()");
        return false;
    }
    // MatrixRotateZ()
    if (!umkaAddFunc(umka, "MatrixRotateZ", &umkaMatrixRotateZ)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function MatrixRotateZ()");
        return false;
    }
    // MatrixRotateXYZ()
    if (!umkaAddFunc(umka, "MatrixRotateXYZ", &umkaMatrixRotateXYZ)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function MatrixRotateXYZ()");
        return false;
    }
    // MatrixRotateZYX()
    if (!umkaAddFunc(umka, "MatrixRotateZYX", &umkaMatrixRotateZYX)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function MatrixRotateZYX()");
        return false;
    }
    // MatrixScale()
    if (!umkaAddFunc(umka, "MatrixScale", &umkaMatrixScale)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function MatrixScale()");
        return false;
    }
    // MatrixFrustum()
    if (!umkaAddFunc(umka, "MatrixFrustum", &umkaMatrixFrustum)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function MatrixFrustum()");
        return false;
    }
    // MatrixPerspective()
    if (!umkaAddFunc(umka, "MatrixPerspective", &umkaMatrixPerspective)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function MatrixPerspective()");
        return false;
    }
    // MatrixOrtho()
    if (!umkaAddFunc(umka, "MatrixOrtho", &umkaMatrixOrtho)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function MatrixOrtho()");
        return false;
    }
    // MatrixLookAt()
    if (!umkaAddFunc(umka, "MatrixLookAt", &umkaMatrixLookAt)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function MatrixLookAt()");
        return false;
    }
    // MatrixToFloatV()
    if (!umkaAddFunc(umka, "MatrixToFloatV", &umkaMatrixToFloatV)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function MatrixToFloatV()");
        return false;
    }
    // QuaternionAdd()
    if (!umkaAddFunc(umka, "QuaternionAdd", &umkaQuaternionAdd)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function QuaternionAdd()");
        return false;
    }
    // QuaternionAddValue()
    if (!umkaAddFunc(umka, "QuaternionAddValue", &umkaQuaternionAddValue)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function QuaternionAddValue()");
        return false;
    }
    // QuaternionSubtract()
    if (!umkaAddFunc(umka, "QuaternionSubtract", &umkaQuaternionSubtract)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function QuaternionSubtract()");
        return false;
    }
    // QuaternionSubtractValue()
    if (!umkaAddFunc(umka, "QuaternionSubtractValue", &umkaQuaternionSubtractValue)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function QuaternionSubtractValue()");
        return false;
    }
    // QuaternionIdentity()
    if (!umkaAddFunc(umka, "QuaternionIdentity", &umkaQuaternionIdentity)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function QuaternionIdentity()");
        return false;
    }
    // QuaternionLength()
    if (!umkaAddFunc(umka, "QuaternionLength", &umkaQuaternionLength)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function QuaternionLength()");
        return false;
    }
    // QuaternionNormalize()
    if (!umkaAddFunc(umka, "QuaternionNormalize", &umkaQuaternionNormalize)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function QuaternionNormalize()");
        return false;
    }
    // QuaternionInvert()
    if (!umkaAddFunc(umka, "QuaternionInvert", &umkaQuaternionInvert)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function QuaternionInvert()");
        return false;
    }
    // QuaternionMultiply()
    if (!umkaAddFunc(umka, "QuaternionMultiply", &umkaQuaternionMultiply)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function QuaternionMultiply()");
        return false;
    }
    // QuaternionScale()
    if (!umkaAddFunc(umka, "QuaternionScale", &umkaQuaternionScale)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function QuaternionScale()");
        return false;
    }
    // QuaternionDivide()
    if (!umkaAddFunc(umka, "QuaternionDivide", &umkaQuaternionDivide)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function QuaternionDivide()");
        return false;
    }
    // QuaternionLerp()
    if (!umkaAddFunc(umka, "QuaternionLerp", &umkaQuaternionLerp)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function QuaternionLerp()");
        return false;
    }
    // QuaternionNlerp()
    if (!umkaAddFunc(umka, "QuaternionNlerp", &umkaQuaternionNlerp)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function QuaternionNlerp()");
        return false;
    }
    // QuaternionSlerp()
    if (!umkaAddFunc(umka, "QuaternionSlerp", &umkaQuaternionSlerp)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function QuaternionSlerp()");
        return false;
    }
    // QuaternionFromVector3ToVector3()
    if (!umkaAddFunc(umka, "QuaternionFromVector3ToVector3", &umkaQuaternionFromVector3ToVector3)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function QuaternionFromVector3ToVector3()");
        return false;
    }
    // QuaternionFromMatrix()
    if (!umkaAddFunc(umka, "QuaternionFromMatrix", &umkaQuaternionFromMatrix)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function QuaternionFromMatrix()");
        return false;
    }
    // QuaternionToMatrix()
    if (!umkaAddFunc(umka, "QuaternionToMatrix", &umkaQuaternionToMatrix)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function QuaternionToMatrix()");
        return false;
    }
    // QuaternionFromAxisAngle()
    if (!umkaAddFunc(umka, "QuaternionFromAxisAngle", &umkaQuaternionFromAxisAngle)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function QuaternionFromAxisAngle()");
        return false;
    }
    // QuaternionToAxisAngle()
    if (!umkaAddFunc(umka, "QuaternionToAxisAngle", &umkaQuaternionToAxisAngle)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function QuaternionToAxisAngle()");
        return false;
    }
    // QuaternionFromEuler()
    if (!umkaAddFunc(umka, "QuaternionFromEuler", &umkaQuaternionFromEuler)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function QuaternionFromEuler()");
        return false;
    }
    // QuaternionToEuler()
    if (!umkaAddFunc(umka, "QuaternionToEuler", &umkaQuaternionToEuler)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function QuaternionToEuler()");
        return false;
    }
    // QuaternionTransform()
    if (!umkaAddFunc(umka, "QuaternionTransform", &umkaQuaternionTransform)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function QuaternionTransform()");
        return false;
    }
    // QuaternionEquals()
    if (!umkaAddFunc(umka, "QuaternionEquals", &umkaQuaternionEquals)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function QuaternionEquals()");
        return false;
    }
    // rlMatrixMode()
    if (!umkaAddFunc(umka, "rlMatrixMode", &umkarlMatrixMode)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlMatrixMode()");
        return false;
    }
    // rlPushMatrix()
    if (!umkaAddFunc(umka, "rlPushMatrix", &umkarlPushMatrix)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlPushMatrix()");
        return false;
    }
    // rlPopMatrix()
    if (!umkaAddFunc(umka, "rlPopMatrix", &umkarlPopMatrix)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlPopMatrix()");
        return false;
    }
    // rlLoadIdentity()
    if (!umkaAddFunc(umka, "rlLoadIdentity", &umkarlLoadIdentity)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlLoadIdentity()");
        return false;
    }
    // rlTranslatef()
    if (!umkaAddFunc(umka, "rlTranslatef", &umkarlTranslatef)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlTranslatef()");
        return false;
    }
    // rlRotatef()
    if (!umkaAddFunc(umka, "rlRotatef", &umkarlRotatef)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlRotatef()");
        return false;
    }
    // rlScalef()
    if (!umkaAddFunc(umka, "rlScalef", &umkarlScalef)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlScalef()");
        return false;
    }
    // rlMultMatrixf()
    if (!umkaAddFunc(umka, "rlMultMatrixf", &umkarlMultMatrixf)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlMultMatrixf()");
        return false;
    }
    // rlFrustum()
    if (!umkaAddFunc(umka, "rlFrustum", &umkarlFrustum)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlFrustum()");
        return false;
    }
    // rlOrtho()
    if (!umkaAddFunc(umka, "rlOrtho", &umkarlOrtho)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlOrtho()");
        return false;
    }
    // rlViewport()
    if (!umkaAddFunc(umka, "rlViewport", &umkarlViewport)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlViewport()");
        return false;
    }
    // rlBegin()
    if (!umkaAddFunc(umka, "rlBegin", &umkarlBegin)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlBegin()");
        return false;
    }
    // rlEnd()
    if (!umkaAddFunc(umka, "rlEnd", &umkarlEnd)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlEnd()");
        return false;
    }
    // rlVertex2i()
    if (!umkaAddFunc(umka, "rlVertex2i", &umkarlVertex2i)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlVertex2i()");
        return false;
    }
    // rlVertex2f()
    if (!umkaAddFunc(umka, "rlVertex2f", &umkarlVertex2f)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlVertex2f()");
        return false;
    }
    // rlVertex3f()
    if (!umkaAddFunc(umka, "rlVertex3f", &umkarlVertex3f)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlVertex3f()");
        return false;
    }
    // rlTexCoord2f()
    if (!umkaAddFunc(umka, "rlTexCoord2f", &umkarlTexCoord2f)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlTexCoord2f()");
        return false;
    }
    // rlNormal3f()
    if (!umkaAddFunc(umka, "rlNormal3f", &umkarlNormal3f)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlNormal3f()");
        return false;
    }
    // rlColor4ub()
    if (!umkaAddFunc(umka, "rlColor4ub", &umkarlColor4ub)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlColor4ub()");
        return false;
    }
    // rlColor3f()
    if (!umkaAddFunc(umka, "rlColor3f", &umkarlColor3f)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlColor3f()");
        return false;
    }
    // rlColor4f()
    if (!umkaAddFunc(umka, "rlColor4f", &umkarlColor4f)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlColor4f()");
        return false;
    }
    // rlEnableVertexArray()
    if (!umkaAddFunc(umka, "rlEnableVertexArray", &umkarlEnableVertexArray)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlEnableVertexArray()");
        return false;
    }
    // rlDisableVertexArray()
    if (!umkaAddFunc(umka, "rlDisableVertexArray", &umkarlDisableVertexArray)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlDisableVertexArray()");
        return false;
    }
    // rlEnableVertexBuffer()
    if (!umkaAddFunc(umka, "rlEnableVertexBuffer", &umkarlEnableVertexBuffer)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlEnableVertexBuffer()");
        return false;
    }
    // rlDisableVertexBuffer()
    if (!umkaAddFunc(umka, "rlDisableVertexBuffer", &umkarlDisableVertexBuffer)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlDisableVertexBuffer()");
        return false;
    }
    // rlEnableVertexBufferElement()
    if (!umkaAddFunc(umka, "rlEnableVertexBufferElement", &umkarlEnableVertexBufferElement)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlEnableVertexBufferElement()");
        return false;
    }
    // rlDisableVertexBufferElement()
    if (!umkaAddFunc(umka, "rlDisableVertexBufferElement", &umkarlDisableVertexBufferElement)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlDisableVertexBufferElement()");
        return false;
    }
    // rlEnableVertexAttribute()
    if (!umkaAddFunc(umka, "rlEnableVertexAttribute", &umkarlEnableVertexAttribute)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlEnableVertexAttribute()");
        return false;
    }
    // rlDisableVertexAttribute()
    if (!umkaAddFunc(umka, "rlDisableVertexAttribute", &umkarlDisableVertexAttribute)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlDisableVertexAttribute()");
        return false;
    }
    // Skipping rlEnableStatePointer
    // Skipping rlDisableStatePointer
    // rlActiveTextureSlot()
    if (!umkaAddFunc(umka, "rlActiveTextureSlot", &umkarlActiveTextureSlot)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlActiveTextureSlot()");
        return false;
    }
    // rlEnableTexture()
    if (!umkaAddFunc(umka, "rlEnableTexture", &umkarlEnableTexture)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlEnableTexture()");
        return false;
    }
    // rlDisableTexture()
    if (!umkaAddFunc(umka, "rlDisableTexture", &umkarlDisableTexture)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlDisableTexture()");
        return false;
    }
    // rlEnableTextureCubemap()
    if (!umkaAddFunc(umka, "rlEnableTextureCubemap", &umkarlEnableTextureCubemap)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlEnableTextureCubemap()");
        return false;
    }
    // rlDisableTextureCubemap()
    if (!umkaAddFunc(umka, "rlDisableTextureCubemap", &umkarlDisableTextureCubemap)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlDisableTextureCubemap()");
        return false;
    }
    // rlTextureParameters()
    if (!umkaAddFunc(umka, "rlTextureParameters", &umkarlTextureParameters)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlTextureParameters()");
        return false;
    }
    // rlEnableShader()
    if (!umkaAddFunc(umka, "rlEnableShader", &umkarlEnableShader)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlEnableShader()");
        return false;
    }
    // rlDisableShader()
    if (!umkaAddFunc(umka, "rlDisableShader", &umkarlDisableShader)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlDisableShader()");
        return false;
    }
    // rlEnableFramebuffer()
    if (!umkaAddFunc(umka, "rlEnableFramebuffer", &umkarlEnableFramebuffer)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlEnableFramebuffer()");
        return false;
    }
    // rlDisableFramebuffer()
    if (!umkaAddFunc(umka, "rlDisableFramebuffer", &umkarlDisableFramebuffer)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlDisableFramebuffer()");
        return false;
    }
    // rlActiveDrawBuffers()
    if (!umkaAddFunc(umka, "rlActiveDrawBuffers", &umkarlActiveDrawBuffers)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlActiveDrawBuffers()");
        return false;
    }
    // rlEnableColorBlend()
    if (!umkaAddFunc(umka, "rlEnableColorBlend", &umkarlEnableColorBlend)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlEnableColorBlend()");
        return false;
    }
    // rlDisableColorBlend()
    if (!umkaAddFunc(umka, "rlDisableColorBlend", &umkarlDisableColorBlend)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlDisableColorBlend()");
        return false;
    }
    // rlEnableDepthTest()
    if (!umkaAddFunc(umka, "rlEnableDepthTest", &umkarlEnableDepthTest)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlEnableDepthTest()");
        return false;
    }
    // rlDisableDepthTest()
    if (!umkaAddFunc(umka, "rlDisableDepthTest", &umkarlDisableDepthTest)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlDisableDepthTest()");
        return false;
    }
    // rlEnableDepthMask()
    if (!umkaAddFunc(umka, "rlEnableDepthMask", &umkarlEnableDepthMask)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlEnableDepthMask()");
        return false;
    }
    // rlDisableDepthMask()
    if (!umkaAddFunc(umka, "rlDisableDepthMask", &umkarlDisableDepthMask)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlDisableDepthMask()");
        return false;
    }
    // rlEnableBackfaceCulling()
    if (!umkaAddFunc(umka, "rlEnableBackfaceCulling", &umkarlEnableBackfaceCulling)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlEnableBackfaceCulling()");
        return false;
    }
    // rlDisableBackfaceCulling()
    if (!umkaAddFunc(umka, "rlDisableBackfaceCulling", &umkarlDisableBackfaceCulling)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlDisableBackfaceCulling()");
        return false;
    }
    // rlEnableScissorTest()
    if (!umkaAddFunc(umka, "rlEnableScissorTest", &umkarlEnableScissorTest)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlEnableScissorTest()");
        return false;
    }
    // rlDisableScissorTest()
    if (!umkaAddFunc(umka, "rlDisableScissorTest", &umkarlDisableScissorTest)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlDisableScissorTest()");
        return false;
    }
    // rlScissor()
    if (!umkaAddFunc(umka, "rlScissor", &umkarlScissor)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlScissor()");
        return false;
    }
    // rlEnableWireMode()
    if (!umkaAddFunc(umka, "rlEnableWireMode", &umkarlEnableWireMode)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlEnableWireMode()");
        return false;
    }
    // rlDisableWireMode()
    if (!umkaAddFunc(umka, "rlDisableWireMode", &umkarlDisableWireMode)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlDisableWireMode()");
        return false;
    }
    // rlSetLineWidth()
    if (!umkaAddFunc(umka, "rlSetLineWidth", &umkarlSetLineWidth)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlSetLineWidth()");
        return false;
    }
    // rlGetLineWidth()
    if (!umkaAddFunc(umka, "rlGetLineWidth", &umkarlGetLineWidth)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlGetLineWidth()");
        return false;
    }
    // rlEnableSmoothLines()
    if (!umkaAddFunc(umka, "rlEnableSmoothLines", &umkarlEnableSmoothLines)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlEnableSmoothLines()");
        return false;
    }
    // rlDisableSmoothLines()
    if (!umkaAddFunc(umka, "rlDisableSmoothLines", &umkarlDisableSmoothLines)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlDisableSmoothLines()");
        return false;
    }
    // rlEnableStereoRender()
    if (!umkaAddFunc(umka, "rlEnableStereoRender", &umkarlEnableStereoRender)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlEnableStereoRender()");
        return false;
    }
    // rlDisableStereoRender()
    if (!umkaAddFunc(umka, "rlDisableStereoRender", &umkarlDisableStereoRender)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlDisableStereoRender()");
        return false;
    }
    // rlIsStereoRenderEnabled()
    if (!umkaAddFunc(umka, "rlIsStereoRenderEnabled", &umkarlIsStereoRenderEnabled)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlIsStereoRenderEnabled()");
        return false;
    }
    // rlClearColor()
    if (!umkaAddFunc(umka, "rlClearColor", &umkarlClearColor)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlClearColor()");
        return false;
    }
    // rlClearScreenBuffers()
    if (!umkaAddFunc(umka, "rlClearScreenBuffers", &umkarlClearScreenBuffers)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlClearScreenBuffers()");
        return false;
    }
    // rlCheckErrors()
    if (!umkaAddFunc(umka, "rlCheckErrors", &umkarlCheckErrors)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlCheckErrors()");
        return false;
    }
    // rlSetBlendMode()
    if (!umkaAddFunc(umka, "rlSetBlendMode", &umkarlSetBlendMode)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlSetBlendMode()");
        return false;
    }
    // rlSetBlendFactors()
    if (!umkaAddFunc(umka, "rlSetBlendFactors", &umkarlSetBlendFactors)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlSetBlendFactors()");
        return false;
    }
    // rlglInit()
    if (!umkaAddFunc(umka, "rlglInit", &umkarlglInit)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlglInit()");
        return false;
    }
    // rlglClose()
    if (!umkaAddFunc(umka, "rlglClose", &umkarlglClose)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlglClose()");
        return false;
    }
    // rlLoadExtensions()
    if (!umkaAddFunc(umka, "rlLoadExtensions", &umkarlLoadExtensions)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlLoadExtensions()");
        return false;
    }
    // rlGetVersion()
    if (!umkaAddFunc(umka, "rlGetVersion", &umkarlGetVersion)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlGetVersion()");
        return false;
    }
    // rlSetFramebufferWidth()
    if (!umkaAddFunc(umka, "rlSetFramebufferWidth", &umkarlSetFramebufferWidth)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlSetFramebufferWidth()");
        return false;
    }
    // rlGetFramebufferWidth()
    if (!umkaAddFunc(umka, "rlGetFramebufferWidth", &umkarlGetFramebufferWidth)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlGetFramebufferWidth()");
        return false;
    }
    // rlSetFramebufferHeight()
    if (!umkaAddFunc(umka, "rlSetFramebufferHeight", &umkarlSetFramebufferHeight)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlSetFramebufferHeight()");
        return false;
    }
    // rlGetFramebufferHeight()
    if (!umkaAddFunc(umka, "rlGetFramebufferHeight", &umkarlGetFramebufferHeight)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlGetFramebufferHeight()");
        return false;
    }
    // rlGetTextureIdDefault()
    if (!umkaAddFunc(umka, "rlGetTextureIdDefault", &umkarlGetTextureIdDefault)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlGetTextureIdDefault()");
        return false;
    }
    // rlGetShaderIdDefault()
    if (!umkaAddFunc(umka, "rlGetShaderIdDefault", &umkarlGetShaderIdDefault)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlGetShaderIdDefault()");
        return false;
    }
    // rlGetShaderLocsDefault()
    if (!umkaAddFunc(umka, "rlGetShaderLocsDefault", &umkarlGetShaderLocsDefault)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlGetShaderLocsDefault()");
        return false;
    }
    // Skipping rlLoadRenderBatch
    // Skipping rlUnloadRenderBatch
    // Skipping rlDrawRenderBatch
    // Skipping rlSetRenderBatchActive
    // rlDrawRenderBatchActive()
    if (!umkaAddFunc(umka, "rlDrawRenderBatchActive", &umkarlDrawRenderBatchActive)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlDrawRenderBatchActive()");
        return false;
    }
    // rlCheckRenderBatchLimit()
    if (!umkaAddFunc(umka, "rlCheckRenderBatchLimit", &umkarlCheckRenderBatchLimit)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlCheckRenderBatchLimit()");
        return false;
    }
    // rlSetTexture()
    if (!umkaAddFunc(umka, "rlSetTexture", &umkarlSetTexture)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlSetTexture()");
        return false;
    }
    // rlLoadVertexArray()
    if (!umkaAddFunc(umka, "rlLoadVertexArray", &umkarlLoadVertexArray)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlLoadVertexArray()");
        return false;
    }
    // rlLoadVertexBuffer()
    if (!umkaAddFunc(umka, "rlLoadVertexBuffer", &umkarlLoadVertexBuffer)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlLoadVertexBuffer()");
        return false;
    }
    // rlLoadVertexBufferElement()
    if (!umkaAddFunc(umka, "rlLoadVertexBufferElement", &umkarlLoadVertexBufferElement)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlLoadVertexBufferElement()");
        return false;
    }
    // rlUpdateVertexBuffer()
    if (!umkaAddFunc(umka, "rlUpdateVertexBuffer", &umkarlUpdateVertexBuffer)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlUpdateVertexBuffer()");
        return false;
    }
    // rlUpdateVertexBufferElements()
    if (!umkaAddFunc(umka, "rlUpdateVertexBufferElements", &umkarlUpdateVertexBufferElements)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlUpdateVertexBufferElements()");
        return false;
    }
    // rlUnloadVertexArray()
    if (!umkaAddFunc(umka, "rlUnloadVertexArray", &umkarlUnloadVertexArray)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlUnloadVertexArray()");
        return false;
    }
    // rlUnloadVertexBuffer()
    if (!umkaAddFunc(umka, "rlUnloadVertexBuffer", &umkarlUnloadVertexBuffer)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlUnloadVertexBuffer()");
        return false;
    }
    // rlSetVertexAttribute()
    if (!umkaAddFunc(umka, "rlSetVertexAttribute", &umkarlSetVertexAttribute)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlSetVertexAttribute()");
        return false;
    }
    // rlSetVertexAttributeDivisor()
    if (!umkaAddFunc(umka, "rlSetVertexAttributeDivisor", &umkarlSetVertexAttributeDivisor)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlSetVertexAttributeDivisor()");
        return false;
    }
    // rlSetVertexAttributeDefault()
    if (!umkaAddFunc(umka, "rlSetVertexAttributeDefault", &umkarlSetVertexAttributeDefault)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlSetVertexAttributeDefault()");
        return false;
    }
    // rlDrawVertexArray()
    if (!umkaAddFunc(umka, "rlDrawVertexArray", &umkarlDrawVertexArray)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlDrawVertexArray()");
        return false;
    }
    // rlDrawVertexArrayElements()
    if (!umkaAddFunc(umka, "rlDrawVertexArrayElements", &umkarlDrawVertexArrayElements)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlDrawVertexArrayElements()");
        return false;
    }
    // rlDrawVertexArrayInstanced()
    if (!umkaAddFunc(umka, "rlDrawVertexArrayInstanced", &umkarlDrawVertexArrayInstanced)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlDrawVertexArrayInstanced()");
        return false;
    }
    // rlDrawVertexArrayElementsInstanced()
    if (!umkaAddFunc(umka, "rlDrawVertexArrayElementsInstanced", &umkarlDrawVertexArrayElementsInstanced)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlDrawVertexArrayElementsInstanced()");
        return false;
    }
    // rlLoadTexture()
    if (!umkaAddFunc(umka, "rlLoadTexture", &umkarlLoadTexture)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlLoadTexture()");
        return false;
    }
    // rlLoadTextureDepth()
    if (!umkaAddFunc(umka, "rlLoadTextureDepth", &umkarlLoadTextureDepth)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlLoadTextureDepth()");
        return false;
    }
    // rlLoadTextureCubemap()
    if (!umkaAddFunc(umka, "rlLoadTextureCubemap", &umkarlLoadTextureCubemap)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlLoadTextureCubemap()");
        return false;
    }
    // rlUpdateTexture()
    if (!umkaAddFunc(umka, "rlUpdateTexture", &umkarlUpdateTexture)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlUpdateTexture()");
        return false;
    }
    // rlGetGlTextureFormats()
    if (!umkaAddFunc(umka, "rlGetGlTextureFormats", &umkarlGetGlTextureFormats)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlGetGlTextureFormats()");
        return false;
    }
    // rlGetPixelFormatName()
    if (!umkaAddFunc(umka, "rlGetPixelFormatName", &umkarlGetPixelFormatName)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlGetPixelFormatName()");
        return false;
    }
    // rlUnloadTexture()
    if (!umkaAddFunc(umka, "rlUnloadTexture", &umkarlUnloadTexture)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlUnloadTexture()");
        return false;
    }
    // rlGenTextureMipmaps()
    if (!umkaAddFunc(umka, "rlGenTextureMipmaps", &umkarlGenTextureMipmaps)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlGenTextureMipmaps()");
        return false;
    }
    // rlReadTexturePixels()
    if (!umkaAddFunc(umka, "rlReadTexturePixels", &umkarlReadTexturePixels)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlReadTexturePixels()");
        return false;
    }
    // rlReadScreenPixels()
    if (!umkaAddFunc(umka, "rlReadScreenPixels", &umkarlReadScreenPixels)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlReadScreenPixels()");
        return false;
    }
    // rlLoadFramebuffer()
    if (!umkaAddFunc(umka, "rlLoadFramebuffer", &umkarlLoadFramebuffer)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlLoadFramebuffer()");
        return false;
    }
    // rlFramebufferAttach()
    if (!umkaAddFunc(umka, "rlFramebufferAttach", &umkarlFramebufferAttach)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlFramebufferAttach()");
        return false;
    }
    // rlFramebufferComplete()
    if (!umkaAddFunc(umka, "rlFramebufferComplete", &umkarlFramebufferComplete)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlFramebufferComplete()");
        return false;
    }
    // rlUnloadFramebuffer()
    if (!umkaAddFunc(umka, "rlUnloadFramebuffer", &umkarlUnloadFramebuffer)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlUnloadFramebuffer()");
        return false;
    }
    // rlLoadShaderCode()
    if (!umkaAddFunc(umka, "rlLoadShaderCode", &umkarlLoadShaderCode)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlLoadShaderCode()");
        return false;
    }
    // rlCompileShader()
    if (!umkaAddFunc(umka, "rlCompileShader", &umkarlCompileShader)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlCompileShader()");
        return false;
    }
    // rlLoadShaderProgram()
    if (!umkaAddFunc(umka, "rlLoadShaderProgram", &umkarlLoadShaderProgram)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlLoadShaderProgram()");
        return false;
    }
    // rlUnloadShaderProgram()
    if (!umkaAddFunc(umka, "rlUnloadShaderProgram", &umkarlUnloadShaderProgram)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlUnloadShaderProgram()");
        return false;
    }
    // rlGetLocationUniform()
    if (!umkaAddFunc(umka, "rlGetLocationUniform", &umkarlGetLocationUniform)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlGetLocationUniform()");
        return false;
    }
    // rlGetLocationAttrib()
    if (!umkaAddFunc(umka, "rlGetLocationAttrib", &umkarlGetLocationAttrib)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlGetLocationAttrib()");
        return false;
    }
    // rlSetUniform()
    if (!umkaAddFunc(umka, "rlSetUniform", &umkarlSetUniform)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlSetUniform()");
        return false;
    }
    // rlSetUniformMatrix()
    if (!umkaAddFunc(umka, "rlSetUniformMatrix", &umkarlSetUniformMatrix)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlSetUniformMatrix()");
        return false;
    }
    // rlSetUniformSampler()
    if (!umkaAddFunc(umka, "rlSetUniformSampler", &umkarlSetUniformSampler)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlSetUniformSampler()");
        return false;
    }
    // rlSetShader()
    if (!umkaAddFunc(umka, "rlSetShader", &umkarlSetShader)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlSetShader()");
        return false;
    }
    // rlLoadComputeShaderProgram()
    if (!umkaAddFunc(umka, "rlLoadComputeShaderProgram", &umkarlLoadComputeShaderProgram)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlLoadComputeShaderProgram()");
        return false;
    }
    // rlComputeShaderDispatch()
    if (!umkaAddFunc(umka, "rlComputeShaderDispatch", &umkarlComputeShaderDispatch)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlComputeShaderDispatch()");
        return false;
    }
    // rlLoadShaderBuffer()
    if (!umkaAddFunc(umka, "rlLoadShaderBuffer", &umkarlLoadShaderBuffer)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlLoadShaderBuffer()");
        return false;
    }
    // rlUnloadShaderBuffer()
    if (!umkaAddFunc(umka, "rlUnloadShaderBuffer", &umkarlUnloadShaderBuffer)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlUnloadShaderBuffer()");
        return false;
    }
    // rlUpdateShaderBufferElements()
    if (!umkaAddFunc(umka, "rlUpdateShaderBufferElements", &umkarlUpdateShaderBufferElements)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlUpdateShaderBufferElements()");
        return false;
    }
    // rlGetShaderBufferSize()
    if (!umkaAddFunc(umka, "rlGetShaderBufferSize", &umkarlGetShaderBufferSize)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlGetShaderBufferSize()");
        return false;
    }
    // rlReadShaderBufferElements()
    if (!umkaAddFunc(umka, "rlReadShaderBufferElements", &umkarlReadShaderBufferElements)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlReadShaderBufferElements()");
        return false;
    }
    // rlBindShaderBuffer()
    if (!umkaAddFunc(umka, "rlBindShaderBuffer", &umkarlBindShaderBuffer)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlBindShaderBuffer()");
        return false;
    }
    // rlCopyBuffersElements()
    if (!umkaAddFunc(umka, "rlCopyBuffersElements", &umkarlCopyBuffersElements)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlCopyBuffersElements()");
        return false;
    }
    // rlBindImageTexture()
    if (!umkaAddFunc(umka, "rlBindImageTexture", &umkarlBindImageTexture)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlBindImageTexture()");
        return false;
    }
    // rlGetMatrixModelview()
    if (!umkaAddFunc(umka, "rlGetMatrixModelview", &umkarlGetMatrixModelview)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlGetMatrixModelview()");
        return false;
    }
    // rlGetMatrixProjection()
    if (!umkaAddFunc(umka, "rlGetMatrixProjection", &umkarlGetMatrixProjection)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlGetMatrixProjection()");
        return false;
    }
    // rlGetMatrixTransform()
    if (!umkaAddFunc(umka, "rlGetMatrixTransform", &umkarlGetMatrixTransform)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlGetMatrixTransform()");
        return false;
    }
    // rlGetMatrixProjectionStereo()
    if (!umkaAddFunc(umka, "rlGetMatrixProjectionStereo", &umkarlGetMatrixProjectionStereo)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlGetMatrixProjectionStereo()");
        return false;
    }
    // rlGetMatrixViewOffsetStereo()
    if (!umkaAddFunc(umka, "rlGetMatrixViewOffsetStereo", &umkarlGetMatrixViewOffsetStereo)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlGetMatrixViewOffsetStereo()");
        return false;
    }
    // rlSetMatrixProjection()
    if (!umkaAddFunc(umka, "rlSetMatrixProjection", &umkarlSetMatrixProjection)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlSetMatrixProjection()");
        return false;
    }
    // rlSetMatrixModelview()
    if (!umkaAddFunc(umka, "rlSetMatrixModelview", &umkarlSetMatrixModelview)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlSetMatrixModelview()");
        return false;
    }
    // rlSetMatrixProjectionStereo()
    if (!umkaAddFunc(umka, "rlSetMatrixProjectionStereo", &umkarlSetMatrixProjectionStereo)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlSetMatrixProjectionStereo()");
        return false;
    }
    // rlSetMatrixViewOffsetStereo()
    if (!umkaAddFunc(umka, "rlSetMatrixViewOffsetStereo", &umkarlSetMatrixViewOffsetStereo)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlSetMatrixViewOffsetStereo()");
        return false;
    }
    // rlLoadDrawCube()
    if (!umkaAddFunc(umka, "rlLoadDrawCube", &umkarlLoadDrawCube)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlLoadDrawCube()");
        return false;
    }
    // rlLoadDrawQuad()
    if (!umkaAddFunc(umka, "rlLoadDrawQuad", &umkarlLoadDrawQuad)) {
        TraceLog(LOG_ERROR, "UMKA: Failed to add function rlLoadDrawQuad()");
        return false;
    }

    /**
     * The code for the raylib umka module.
     */
    const char* moduleCode =
        // Structures
        /* 0001 */ "type (\n"
        /* 0002 */ "  Vector2* = struct {\n"
        /* 0003 */ "    x: real32\n"
        /* 0004 */ "    y: real32\n"
        /* 0005 */ "  }\n"
        /* 0006 */ "  Vector3* = struct {\n"
        /* 0007 */ "    x: real32\n"
        /* 0008 */ "    y: real32\n"
        /* 0009 */ "    z: real32\n"
        /* 0010 */ "  }\n"
        /* 0011 */ "  Vector4* = struct {\n"
        /* 0012 */ "    x: real32\n"
        /* 0013 */ "    y: real32\n"
        /* 0014 */ "    z: real32\n"
        /* 0015 */ "    w: real32\n"
        /* 0016 */ "  }\n"
        /* 0017 */ "  Matrix* = struct {\n"
        /* 0018 */ "    m0: real32\n"
        /* 0019 */ "    m4: real32\n"
        /* 0020 */ "    m8: real32\n"
        /* 0021 */ "    m12: real32\n"
        /* 0022 */ "    m1: real32\n"
        /* 0023 */ "    m5: real32\n"
        /* 0024 */ "    m9: real32\n"
        /* 0025 */ "    m13: real32\n"
        /* 0026 */ "    m2: real32\n"
        /* 0027 */ "    m6: real32\n"
        /* 0028 */ "    m10: real32\n"
        /* 0029 */ "    m14: real32\n"
        /* 0030 */ "    m3: real32\n"
        /* 0031 */ "    m7: real32\n"
        /* 0032 */ "    m11: real32\n"
        /* 0033 */ "    m15: real32\n"
        /* 0034 */ "  }\n"
        /* 0035 */ "  Color* = struct {\n"
        /* 0036 */ "    r: uint8\n"
        /* 0037 */ "    g: uint8\n"
        /* 0038 */ "    b: uint8\n"
        /* 0039 */ "    a: uint8\n"
        /* 0040 */ "  }\n"
        /* 0041 */ "  Rectangle* = struct {\n"
        /* 0042 */ "    x: real32\n"
        /* 0043 */ "    y: real32\n"
        /* 0044 */ "    width: real32\n"
        /* 0045 */ "    height: real32\n"
        /* 0046 */ "  }\n"
        /* 0047 */ "  Image* = struct {\n"
        /* 0048 */ "    data: ^void\n"
        /* 0049 */ "    width: int32\n"
        /* 0050 */ "    height: int32\n"
        /* 0051 */ "    mipmaps: int32\n"
        /* 0052 */ "    format: int32\n"
        /* 0053 */ "  }\n"
        /* 0054 */ "  Texture* = struct {\n"
        /* 0055 */ "    id: uint32\n"
        /* 0056 */ "    width: int32\n"
        /* 0057 */ "    height: int32\n"
        /* 0058 */ "    mipmaps: int32\n"
        /* 0059 */ "    format: int32\n"
        /* 0060 */ "  }\n"
        /* 0061 */ "  RenderTexture* = struct {\n"
        /* 0062 */ "    id: uint32\n"
        /* 0063 */ "    texture: Texture\n"
        /* 0064 */ "    depth: Texture\n"
        /* 0065 */ "  }\n"
        /* 0066 */ "  NPatchInfo* = struct {\n"
        /* 0067 */ "    source: Rectangle\n"
        /* 0068 */ "    left: int32\n"
        /* 0069 */ "    top: int32\n"
        /* 0070 */ "    right: int32\n"
        /* 0071 */ "    bottom: int32\n"
        /* 0072 */ "    layout: int32\n"
        /* 0073 */ "  }\n"
        /* 0074 */ "  GlyphInfo* = struct {\n"
        /* 0075 */ "    value: int32\n"
        /* 0076 */ "    offsetX: int32\n"
        /* 0077 */ "    offsetY: int32\n"
        /* 0078 */ "    advanceX: int32\n"
        /* 0079 */ "    image: Image\n"
        /* 0080 */ "  }\n"
        /* 0081 */ "  Font* = struct {\n"
        /* 0082 */ "    baseSize: int32\n"
        /* 0083 */ "    glyphCount: int32\n"
        /* 0084 */ "    glyphPadding: int32\n"
        /* 0085 */ "    texture: Texture\n"
        /* 0086 */ "    recs: ^Rectangle\n"
        /* 0087 */ "    glyphs: ^GlyphInfo\n"
        /* 0088 */ "  }\n"
        /* 0089 */ "  Camera3D* = struct {\n"
        /* 0090 */ "    position: Vector3\n"
        /* 0091 */ "    target: Vector3\n"
        /* 0092 */ "    up: Vector3\n"
        /* 0093 */ "    fovy: real32\n"
        /* 0094 */ "    projection: int32\n"
        /* 0095 */ "  }\n"
        /* 0096 */ "  Camera2D* = struct {\n"
        /* 0097 */ "    offset: Vector2\n"
        /* 0098 */ "    target: Vector2\n"
        /* 0099 */ "    rotation: real32\n"
        /* 0100 */ "    zoom: real32\n"
        /* 0101 */ "  }\n"
        /* 0102 */ "  Mesh* = struct {\n"
        /* 0103 */ "    vertexCount: int32\n"
        /* 0104 */ "    triangleCount: int32\n"
        /* 0105 */ "    vertices: ^real32\n"
        /* 0106 */ "    texcoords: ^real32\n"
        /* 0107 */ "    texcoords2: ^real32\n"
        /* 0108 */ "    normals: ^real32\n"
        /* 0109 */ "    tangents: ^real32\n"
        /* 0110 */ "    colors: ^uint8\n"
        /* 0111 */ "    indices: ^uint16\n"
        /* 0112 */ "    animVertices: ^real32\n"
        /* 0113 */ "    animNormals: ^real32\n"
        /* 0114 */ "    boneIds: ^uint8\n"
        /* 0115 */ "    boneWeights: ^real32\n"
        /* 0116 */ "    vaoId: uint32\n"
        /* 0117 */ "    vboId: ^uint32\n"
        /* 0118 */ "  }\n"
        /* 0119 */ "  Shader* = struct {\n"
        /* 0120 */ "    id: uint32\n"
        /* 0121 */ "    locs: ^int32\n"
        /* 0122 */ "  }\n"
        /* 0123 */ "  MaterialMap* = struct {\n"
        /* 0124 */ "    texture: Texture\n"
        /* 0125 */ "    color: Color\n"
        /* 0126 */ "    value: real32\n"
        /* 0127 */ "  }\n"
        /* 0128 */ "  Material* = struct {\n"
        /* 0129 */ "    shader: Shader\n"
        /* 0130 */ "    maps: ^MaterialMap\n"
        /* 0131 */ "    params: [4]real32\n"
        /* 0132 */ "  }\n"
        /* 0133 */ "  Transform* = struct {\n"
        /* 0134 */ "    translation: Vector3\n"
        /* 0135 */ "    rotation: Vector4\n"
        /* 0136 */ "    scale: Vector3\n"
        /* 0137 */ "  }\n"
        /* 0138 */ "  BoneInfo* = struct {\n"
        /* 0139 */ "    name: [32]char\n"
        /* 0140 */ "    parent: int32\n"
        /* 0141 */ "  }\n"
        /* 0142 */ "  Model* = struct {\n"
        /* 0143 */ "    transform: Matrix\n"
        /* 0144 */ "    meshCount: int32\n"
        /* 0145 */ "    materialCount: int32\n"
        /* 0146 */ "    meshes: ^Mesh\n"
        /* 0147 */ "    materials: ^Material\n"
        /* 0148 */ "    meshMaterial: ^int32\n"
        /* 0149 */ "    boneCount: int32\n"
        /* 0150 */ "    bones: ^BoneInfo\n"
        /* 0151 */ "    bindPose: ^Transform\n"
        /* 0152 */ "  }\n"
        /* 0153 */ "  ModelAnimation* = struct {\n"
        /* 0154 */ "    boneCount: int32\n"
        /* 0155 */ "    frameCount: int32\n"
        /* 0156 */ "    bones: ^BoneInfo\n"
        /* 0157 */ "    framePoses: ^void\n"
        /* 0158 */ "  }\n"
        /* 0159 */ "  Ray* = struct {\n"
        /* 0160 */ "    position: Vector3\n"
        /* 0161 */ "    direction: Vector3\n"
        /* 0162 */ "  }\n"
        /* 0163 */ "  RayCollision* = struct {\n"
        /* 0164 */ "    hit: bool\n"
        /* 0165 */ "    distance: real32\n"
        /* 0166 */ "    point: Vector3\n"
        /* 0167 */ "    normal: Vector3\n"
        /* 0168 */ "  }\n"
        /* 0169 */ "  BoundingBox* = struct {\n"
        /* 0170 */ "    min: Vector3\n"
        /* 0171 */ "    max: Vector3\n"
        /* 0172 */ "  }\n"
        /* 0173 */ "  Wave* = struct {\n"
        /* 0174 */ "    frameCount: uint32\n"
        /* 0175 */ "    sampleRate: uint32\n"
        /* 0176 */ "    sampleSize: uint32\n"
        /* 0177 */ "    channels: uint32\n"
        /* 0178 */ "    data: ^void\n"
        /* 0179 */ "  }\n"
        /* 0180 */ "  AudioStream* = struct {\n"
        /* 0181 */ "    buffer: ^void\n"
        /* 0182 */ "    processor: ^void\n"
        /* 0183 */ "    sampleRate: uint32\n"
        /* 0184 */ "    sampleSize: uint32\n"
        /* 0185 */ "    channels: uint32\n"
        /* 0186 */ "  }\n"
        /* 0187 */ "  Sound* = struct {\n"
        /* 0188 */ "    stream: AudioStream\n"
        /* 0189 */ "    frameCount: uint32\n"
        /* 0190 */ "  }\n"
        /* 0191 */ "  Music* = struct {\n"
        /* 0192 */ "    stream: AudioStream\n"
        /* 0193 */ "    frameCount: uint32\n"
        /* 0194 */ "    looping: bool\n"
        /* 0195 */ "    ctxType: int32\n"
        /* 0196 */ "    ctxData: ^void\n"
        /* 0197 */ "  }\n"
        /* 0198 */ "  VrDeviceInfo* = struct {\n"
        /* 0199 */ "    hResolution: int32\n"
        /* 0200 */ "    vResolution: int32\n"
        /* 0201 */ "    hScreenSize: real32\n"
        /* 0202 */ "    vScreenSize: real32\n"
        /* 0203 */ "    vScreenCenter: real32\n"
        /* 0204 */ "    eyeToScreenDistance: real32\n"
        /* 0205 */ "    lensSeparationDistance: real32\n"
        /* 0206 */ "    interpupillaryDistance: real32\n"
        /* 0207 */ "    lensDistortionValues: [4]real32\n"
        /* 0208 */ "    chromaAbCorrection: [4]real32\n"
        /* 0209 */ "  }\n"
        /* 0210 */ "  VrStereoConfig* = struct {\n"
        /* 0211 */ "    projection: [2]Matrix\n"
        /* 0212 */ "    viewOffset: [2]Matrix\n"
        /* 0213 */ "    leftLensCenter: [2]real32\n"
        /* 0214 */ "    rightLensCenter: [2]real32\n"
        /* 0215 */ "    leftScreenCenter: [2]real32\n"
        /* 0216 */ "    rightScreenCenter: [2]real32\n"
        /* 0217 */ "    scale: [2]real32\n"
        /* 0218 */ "    scaleIn: [2]real32\n"
        /* 0219 */ "  }\n"
        /* 0220 */ "  FilePathList* = struct {\n"
        /* 0221 */ "    capacity: uint32\n"
        /* 0222 */ "    count: uint32\n"
        /* 0223 */ "    paths: ^str\n"
        /* 0224 */ "  }\n"
        /* 0225 */ "  float3* = struct {\n"
        /* 0226 */ "    v: [3]real32\n"
        /* 0227 */ "  }\n"
        /* 0228 */ "  float16* = struct {\n"
        /* 0229 */ "    v: [16]real32\n"
        /* 0230 */ "  }\n"
        /* 0231 */ "  rlDrawCall* = struct {\n"
        /* 0232 */ "    mode: int32\n"
        /* 0233 */ "    vertexCount: int32\n"
        /* 0234 */ "    vertexAlignment: int32\n"
        /* 0235 */ "    textureId: uint32\n"
        /* 0236 */ "  }\n"
        /* 0237 */ ")\n"

        // Callbacks
        /* 0238 */ "type (\n"
        /* 0239 */ "// Skipped TraceLogCallback\n"
        /* 0240 */ "    LoadFileDataCallback = fn(fileName: str, bytesRead: ^uint32): ^uint8\n"
        /* 0241 */ "    SaveFileDataCallback = fn(fileName: str, data: ^void, bytesToWrite: uint32): bool\n"
        /* 0242 */ "    LoadFileTextCallback = fn(fileName: str): str\n"
        /* 0243 */ "    SaveFileTextCallback = fn(fileName: str, text: str): bool\n"
        /* 0244 */ "    AudioCallback = fn(bufferData: ^void, frames: uint32)\n"
        /* 0245 */ ")\n"

        // Function Declarations
        /* 0246 */ "fn TraceLog*(errorType: int , message: str)\n"
        /* 0247 */ "fn InitWindow*(width: int32, height: int32, title: str)\n"
        /* 0248 */ "fn WindowShouldClose*(): bool\n"
        /* 0249 */ "fn CloseWindow*()\n"
        /* 0250 */ "fn IsWindowReady*(): bool\n"
        /* 0251 */ "fn IsWindowFullscreen*(): bool\n"
        /* 0252 */ "fn IsWindowHidden*(): bool\n"
        /* 0253 */ "fn IsWindowMinimized*(): bool\n"
        /* 0254 */ "fn IsWindowMaximized*(): bool\n"
        /* 0255 */ "fn IsWindowFocused*(): bool\n"
        /* 0256 */ "fn IsWindowResized*(): bool\n"
        /* 0257 */ "fn IsWindowState*(flag: uint32): bool\n"
        /* 0258 */ "fn SetWindowState*(flags: uint32)\n"
        /* 0259 */ "fn ClearWindowState*(flags: uint32)\n"
        /* 0260 */ "fn ToggleFullscreen*()\n"
        /* 0261 */ "fn MaximizeWindow*()\n"
        /* 0262 */ "fn MinimizeWindow*()\n"
        /* 0263 */ "fn RestoreWindow*()\n"
        /* 0264 */ "fn SetWindowIcon*(image: Image)\n"
        /* 0265 */ "fn SetWindowTitle*(title: str)\n"
        /* 0266 */ "fn SetWindowPosition*(x: int32, y: int32)\n"
        /* 0267 */ "fn SetWindowMonitor*(monitor: int32)\n"
        /* 0268 */ "fn SetWindowMinSize*(width: int32, height: int32)\n"
        /* 0269 */ "fn SetWindowSize*(width: int32, height: int32)\n"
        /* 0270 */ "fn SetWindowOpacity*(opacity: real32)\n"
        /* 0271 */ "fn GetWindowHandle*(): ^void\n"
        /* 0272 */ "fn GetScreenWidth*(): int32\n"
        /* 0273 */ "fn GetScreenHeight*(): int32\n"
        /* 0274 */ "fn GetRenderWidth*(): int32\n"
        /* 0275 */ "fn GetRenderHeight*(): int32\n"
        /* 0276 */ "fn GetMonitorCount*(): int32\n"
        /* 0277 */ "fn GetCurrentMonitor*(): int32\n"
        /* 0278 */ "fn GetMonitorPosition*(monitor: int32): Vector2\n"
        /* 0279 */ "fn GetMonitorWidth*(monitor: int32): int32\n"
        /* 0280 */ "fn GetMonitorHeight*(monitor: int32): int32\n"
        /* 0281 */ "fn GetMonitorPhysicalWidth*(monitor: int32): int32\n"
        /* 0282 */ "fn GetMonitorPhysicalHeight*(monitor: int32): int32\n"
        /* 0283 */ "fn GetMonitorRefreshRate*(monitor: int32): int32\n"
        /* 0284 */ "fn GetWindowPosition*(): Vector2\n"
        /* 0285 */ "fn GetWindowScaleDPI*(): Vector2\n"
        /* 0286 */ "fn GetMonitorName*(monitor: int32): str\n"
        /* 0287 */ "fn SetClipboardText*(text: str)\n"
        /* 0288 */ "fn GetClipboardText*(): str\n"
        /* 0289 */ "fn EnableEventWaiting*()\n"
        /* 0290 */ "fn DisableEventWaiting*()\n"
        /* 0291 */ "fn SwapScreenBuffer*()\n"
        /* 0292 */ "fn PollInputEvents*()\n"
        /* 0293 */ "fn WaitTime*(seconds: real)\n"
        /* 0294 */ "fn ShowCursor*()\n"
        /* 0295 */ "fn HideCursor*()\n"
        /* 0296 */ "fn IsCursorHidden*(): bool\n"
        /* 0297 */ "fn EnableCursor*()\n"
        /* 0298 */ "fn DisableCursor*()\n"
        /* 0299 */ "fn IsCursorOnScreen*(): bool\n"
        /* 0300 */ "fn ClearBackground*(color: Color)\n"
        /* 0301 */ "fn BeginDrawing*()\n"
        /* 0302 */ "fn EndDrawing*()\n"
        /* 0303 */ "fn BeginMode2D*(camera: Camera2D)\n"
        /* 0304 */ "fn EndMode2D*()\n"
        /* 0305 */ "fn BeginMode3D*(camera: Camera3D)\n"
        /* 0306 */ "fn EndMode3D*()\n"
        /* 0307 */ "fn BeginTextureMode*(target: RenderTexture)\n"
        /* 0308 */ "fn EndTextureMode*()\n"
        /* 0309 */ "fn BeginShaderMode*(shader: Shader)\n"
        /* 0310 */ "fn EndShaderMode*()\n"
        /* 0311 */ "fn BeginBlendMode*(mode: int32)\n"
        /* 0312 */ "fn EndBlendMode*()\n"
        /* 0313 */ "fn BeginScissorMode*(x: int32, y: int32, width: int32, height: int32)\n"
        /* 0314 */ "fn EndScissorMode*()\n"
        /* 0315 */ "fn BeginVrStereoMode*(config: VrStereoConfig)\n"
        /* 0316 */ "fn EndVrStereoMode*()\n"
        /* 0317 */ "fn LoadVrStereoConfig*(device: VrDeviceInfo): VrStereoConfig\n"
        /* 0318 */ "fn UnloadVrStereoConfig*(config: VrStereoConfig)\n"
        /* 0319 */ "fn LoadShader*(vsFileName: str, fsFileName: str): Shader\n"
        /* 0320 */ "fn LoadShaderFromMemory*(vsCode: str, fsCode: str): Shader\n"
        /* 0321 */ "fn GetShaderLocation*(shader: Shader, uniformName: str): int32\n"
        /* 0322 */ "fn GetShaderLocationAttrib*(shader: Shader, attribName: str): int32\n"
        /* 0323 */ "fn SetShaderValue*(shader: Shader, locIndex: int32, value: ^void, uniformType: int32)\n"
        /* 0324 */ "fn SetShaderValueV*(shader: Shader, locIndex: int32, value: ^void, uniformType: int32, count: int32)\n"
        /* 0325 */ "fn SetShaderValueMatrix*(shader: Shader, locIndex: int32, mat: Matrix)\n"
        /* 0326 */ "fn SetShaderValueTexture*(shader: Shader, locIndex: int32, texture: Texture)\n"
        /* 0327 */ "fn UnloadShader*(shader: Shader)\n"
        /* 0328 */ "fn GetMouseRay*(mousePosition: Vector2, camera: Camera3D): Ray\n"
        /* 0329 */ "fn GetCameraMatrix*(camera: Camera3D): Matrix\n"
        /* 0330 */ "fn GetCameraMatrix2D*(camera: Camera2D): Matrix\n"
        /* 0331 */ "fn GetWorldToScreen*(position: Vector3, camera: Camera3D): Vector2\n"
        /* 0332 */ "fn GetScreenToWorld2D*(position: Vector2, camera: Camera2D): Vector2\n"
        /* 0333 */ "fn GetWorldToScreenEx*(position: Vector3, camera: Camera3D, width: int32, height: int32): Vector2\n"
        /* 0334 */ "fn GetWorldToScreen2D*(position: Vector2, camera: Camera2D): Vector2\n"
        /* 0335 */ "fn SetTargetFPS*(fps: int32)\n"
        /* 0336 */ "fn GetFPS*(): int32\n"
        /* 0337 */ "fn GetFrameTime*(): real32\n"
        /* 0338 */ "fn GetTime*(): real\n"
        /* 0339 */ "fn GetRandomValue*(min: int32, max: int32): int32\n"
        /* 0340 */ "fn SetRandomSeed*(seed: uint32)\n"
        /* 0341 */ "fn TakeScreenshot*(fileName: str)\n"
        /* 0342 */ "fn SetConfigFlags*(flags: uint32)\n"
        /* 0343 */ "// Skipping TraceLog\n"
        /* 0344 */ "fn SetTraceLogLevel*(logLevel: int32)\n"
        /* 0345 */ "fn MemAlloc*(size: int32): ^void\n"
        /* 0346 */ "fn MemRealloc*(ptr: ^void, size: int32): ^void\n"
        /* 0347 */ "fn MemFree*(ptr: ^void)\n"
        /* 0348 */ "fn OpenURL*(url: str)\n"
        /* 0349 */ "// Skipping SetTraceLogCallback\n"
        /* 0350 */ "// Skipping SetLoadFileDataCallback\n"
        /* 0351 */ "// Skipping SetSaveFileDataCallback\n"
        /* 0352 */ "// Skipping SetLoadFileTextCallback\n"
        /* 0353 */ "// Skipping SetSaveFileTextCallback\n"
        /* 0354 */ "fn LoadFileData*(fileName: str, bytesRead: ^uint32): ^uint8\n"
        /* 0355 */ "fn UnloadFileData*(data: ^uint8)\n"
        /* 0356 */ "fn SaveFileData*(fileName: str, data: ^void, bytesToWrite: uint32): bool\n"
        /* 0357 */ "fn ExportDataAsCode*(data: str, size: uint32, fileName: str): bool\n"
        /* 0358 */ "fn LoadFileText*(fileName: str): str\n"
        /* 0359 */ "fn UnloadFileText*(text: str)\n"
        /* 0360 */ "fn SaveFileText*(fileName: str, text: str): bool\n"
        /* 0361 */ "fn FileExists*(fileName: str): bool\n"
        /* 0362 */ "fn DirectoryExists*(dirPath: str): bool\n"
        /* 0363 */ "fn IsFileExtension*(fileName: str, ext: str): bool\n"
        /* 0364 */ "fn GetFileLength*(fileName: str): int32\n"
        /* 0365 */ "fn GetFileExtension*(fileName: str): str\n"
        /* 0366 */ "fn GetFileName*(filePath: str): str\n"
        /* 0367 */ "fn GetFileNameWithoutExt*(filePath: str): str\n"
        /* 0368 */ "fn GetDirectoryPath*(filePath: str): str\n"
        /* 0369 */ "fn GetPrevDirectoryPath*(dirPath: str): str\n"
        /* 0370 */ "fn GetWorkingDirectory*(): str\n"
        /* 0371 */ "fn GetApplicationDirectory*(): str\n"
        /* 0372 */ "fn ChangeDirectory*(dir: str): bool\n"
        /* 0373 */ "fn IsPathFile*(path: str): bool\n"
        /* 0374 */ "fn LoadDirectoryFiles*(dirPath: str): FilePathList\n"
        /* 0375 */ "fn LoadDirectoryFilesEx*(basePath: str, filter: str, scanSubdirs: bool): FilePathList\n"
        /* 0376 */ "fn UnloadDirectoryFiles*(files: FilePathList)\n"
        /* 0377 */ "fn IsFileDropped*(): bool\n"
        /* 0378 */ "fn LoadDroppedFiles*(): FilePathList\n"
        /* 0379 */ "fn UnloadDroppedFiles*(files: FilePathList)\n"
        /* 0380 */ "fn GetFileModTime*(fileName: str): int\n"
        /* 0381 */ "fn CompressData*(data: ^uint8, dataSize: int32, compDataSize: ^int32): ^uint8\n"
        /* 0382 */ "fn DecompressData*(compData: ^uint8, compDataSize: int32, dataSize: ^int32): ^uint8\n"
        /* 0383 */ "fn EncodeDataBase64*(data: ^uint8, dataSize: int32, outputSize: ^int32): str\n"
        /* 0384 */ "fn DecodeDataBase64*(data: ^uint8, outputSize: ^int32): ^uint8\n"
        /* 0385 */ "fn IsKeyPressed*(key: int32): bool\n"
        /* 0386 */ "fn IsKeyDown*(key: int32): bool\n"
        /* 0387 */ "fn IsKeyReleased*(key: int32): bool\n"
        /* 0388 */ "fn IsKeyUp*(key: int32): bool\n"
        /* 0389 */ "fn SetExitKey*(key: int32)\n"
        /* 0390 */ "fn GetKeyPressed*(): int32\n"
        /* 0391 */ "fn GetCharPressed*(): int32\n"
        /* 0392 */ "fn IsGamepadAvailable*(gamepad: int32): bool\n"
        /* 0393 */ "fn GetGamepadName*(gamepad: int32): str\n"
        /* 0394 */ "fn IsGamepadButtonPressed*(gamepad: int32, button: int32): bool\n"
        /* 0395 */ "fn IsGamepadButtonDown*(gamepad: int32, button: int32): bool\n"
        /* 0396 */ "fn IsGamepadButtonReleased*(gamepad: int32, button: int32): bool\n"
        /* 0397 */ "fn IsGamepadButtonUp*(gamepad: int32, button: int32): bool\n"
        /* 0398 */ "fn GetGamepadButtonPressed*(): int32\n"
        /* 0399 */ "fn GetGamepadAxisCount*(gamepad: int32): int32\n"
        /* 0400 */ "fn GetGamepadAxisMovement*(gamepad: int32, axis: int32): real32\n"
        /* 0401 */ "fn SetGamepadMappings*(mappings: str): int32\n"
        /* 0402 */ "fn IsMouseButtonPressed*(button: int32): bool\n"
        /* 0403 */ "fn IsMouseButtonDown*(button: int32): bool\n"
        /* 0404 */ "fn IsMouseButtonReleased*(button: int32): bool\n"
        /* 0405 */ "fn IsMouseButtonUp*(button: int32): bool\n"
        /* 0406 */ "fn GetMouseX*(): int32\n"
        /* 0407 */ "fn GetMouseY*(): int32\n"
        /* 0408 */ "fn GetMousePosition*(): Vector2\n"
        /* 0409 */ "fn GetMouseDelta*(): Vector2\n"
        /* 0410 */ "fn SetMousePosition*(x: int32, y: int32)\n"
        /* 0411 */ "fn SetMouseOffset*(offsetX: int32, offsetY: int32)\n"
        /* 0412 */ "fn SetMouseScale*(scaleX: real32, scaleY: real32)\n"
        /* 0413 */ "fn GetMouseWheelMove*(): real32\n"
        /* 0414 */ "fn GetMouseWheelMoveV*(): Vector2\n"
        /* 0415 */ "fn SetMouseCursor*(cursor: int32)\n"
        /* 0416 */ "fn GetTouchX*(): int32\n"
        /* 0417 */ "fn GetTouchY*(): int32\n"
        /* 0418 */ "fn GetTouchPosition*(index: int32): Vector2\n"
        /* 0419 */ "fn GetTouchPointId*(index: int32): int32\n"
        /* 0420 */ "fn GetTouchPointCount*(): int32\n"
        /* 0421 */ "fn SetGesturesEnabled*(flags: uint32)\n"
        /* 0422 */ "fn IsGestureDetected*(gesture: int32): bool\n"
        /* 0423 */ "fn GetGestureDetected*(): int32\n"
        /* 0424 */ "fn GetGestureHoldDuration*(): real32\n"
        /* 0425 */ "fn GetGestureDragVector*(): Vector2\n"
        /* 0426 */ "fn GetGestureDragAngle*(): real32\n"
        /* 0427 */ "fn GetGesturePinchVector*(): Vector2\n"
        /* 0428 */ "fn GetGesturePinchAngle*(): real32\n"
        /* 0429 */ "fn SetCameraMode*(camera: Camera3D, mode: int32)\n"
        /* 0430 */ "fn UpdateCamera*(camera: ^Camera3D)\n"
        /* 0431 */ "fn SetCameraPanControl*(keyPan: int32)\n"
        /* 0432 */ "fn SetCameraAltControl*(keyAlt: int32)\n"
        /* 0433 */ "fn SetCameraSmoothZoomControl*(keySmoothZoom: int32)\n"
        /* 0434 */ "fn SetCameraMoveControls*(keyFront: int32, keyBack: int32, keyRight: int32, keyLeft: int32, keyUp: int32, keyDown: int32)\n"
        /* 0435 */ "fn SetShapesTexture*(texture: Texture, source: Rectangle)\n"
        /* 0436 */ "fn DrawPixel*(posX: int32, posY: int32, color: Color)\n"
        /* 0437 */ "fn DrawPixelV*(position: Vector2, color: Color)\n"
        /* 0438 */ "fn DrawLine*(startPosX: int32, startPosY: int32, endPosX: int32, endPosY: int32, color: Color)\n"
        /* 0439 */ "fn DrawLineV*(startPos: Vector2, endPos: Vector2, color: Color)\n"
        /* 0440 */ "fn DrawLineEx*(startPos: Vector2, endPos: Vector2, thick: real32, color: Color)\n"
        /* 0441 */ "fn DrawLineBezier*(startPos: Vector2, endPos: Vector2, thick: real32, color: Color)\n"
        /* 0442 */ "fn DrawLineBezierQuad*(startPos: Vector2, endPos: Vector2, controlPos: Vector2, thick: real32, color: Color)\n"
        /* 0443 */ "fn DrawLineBezierCubic*(startPos: Vector2, endPos: Vector2, startControlPos: Vector2, endControlPos: Vector2, thick: real32, color: Color)\n"
        /* 0444 */ "fn DrawLineStrip*(points: ^Vector2, pointCount: int32, color: Color)\n"
        /* 0445 */ "fn DrawCircle*(centerX: int32, centerY: int32, radius: real32, color: Color)\n"
        /* 0446 */ "fn DrawCircleSector*(center: Vector2, radius: real32, startAngle: real32, endAngle: real32, segments: int32, color: Color)\n"
        /* 0447 */ "fn DrawCircleSectorLines*(center: Vector2, radius: real32, startAngle: real32, endAngle: real32, segments: int32, color: Color)\n"
        /* 0448 */ "fn DrawCircleGradient*(centerX: int32, centerY: int32, radius: real32, color1: Color, color2: Color)\n"
        /* 0449 */ "fn DrawCircleV*(center: Vector2, radius: real32, color: Color)\n"
        /* 0450 */ "fn DrawCircleLines*(centerX: int32, centerY: int32, radius: real32, color: Color)\n"
        /* 0451 */ "fn DrawEllipse*(centerX: int32, centerY: int32, radiusH: real32, radiusV: real32, color: Color)\n"
        /* 0452 */ "fn DrawEllipseLines*(centerX: int32, centerY: int32, radiusH: real32, radiusV: real32, color: Color)\n"
        /* 0453 */ "fn DrawRing*(center: Vector2, innerRadius: real32, outerRadius: real32, startAngle: real32, endAngle: real32, segments: int32, color: Color)\n"
        /* 0454 */ "fn DrawRingLines*(center: Vector2, innerRadius: real32, outerRadius: real32, startAngle: real32, endAngle: real32, segments: int32, color: Color)\n"
        /* 0455 */ "fn DrawRectangle*(posX: int32, posY: int32, width: int32, height: int32, color: Color)\n"
        /* 0456 */ "fn DrawRectangleV*(position: Vector2, size: Vector2, color: Color)\n"
        /* 0457 */ "fn DrawRectangleRec*(rec: Rectangle, color: Color)\n"
        /* 0458 */ "fn DrawRectanglePro*(rec: Rectangle, origin: Vector2, rotation: real32, color: Color)\n"
        /* 0459 */ "fn DrawRectangleGradientV*(posX: int32, posY: int32, width: int32, height: int32, color1: Color, color2: Color)\n"
        /* 0460 */ "fn DrawRectangleGradientH*(posX: int32, posY: int32, width: int32, height: int32, color1: Color, color2: Color)\n"
        /* 0461 */ "fn DrawRectangleGradientEx*(rec: Rectangle, col1: Color, col2: Color, col3: Color, col4: Color)\n"
        /* 0462 */ "fn DrawRectangleLines*(posX: int32, posY: int32, width: int32, height: int32, color: Color)\n"
        /* 0463 */ "fn DrawRectangleLinesEx*(rec: Rectangle, lineThick: real32, color: Color)\n"
        /* 0464 */ "fn DrawRectangleRounded*(rec: Rectangle, roundness: real32, segments: int32, color: Color)\n"
        /* 0465 */ "fn DrawRectangleRoundedLines*(rec: Rectangle, roundness: real32, segments: int32, lineThick: real32, color: Color)\n"
        /* 0466 */ "fn DrawTriangle*(v1: Vector2, v2: Vector2, v3: Vector2, color: Color)\n"
        /* 0467 */ "fn DrawTriangleLines*(v1: Vector2, v2: Vector2, v3: Vector2, color: Color)\n"
        /* 0468 */ "fn DrawTriangleFan*(points: ^Vector2, pointCount: int32, color: Color)\n"
        /* 0469 */ "fn DrawTriangleStrip*(points: ^Vector2, pointCount: int32, color: Color)\n"
        /* 0470 */ "fn DrawPoly*(center: Vector2, sides: int32, radius: real32, rotation: real32, color: Color)\n"
        /* 0471 */ "fn DrawPolyLines*(center: Vector2, sides: int32, radius: real32, rotation: real32, color: Color)\n"
        /* 0472 */ "fn DrawPolyLinesEx*(center: Vector2, sides: int32, radius: real32, rotation: real32, lineThick: real32, color: Color)\n"
        /* 0473 */ "fn CheckCollisionRecs*(rec1: Rectangle, rec2: Rectangle): bool\n"
        /* 0474 */ "fn CheckCollisionCircles*(center1: Vector2, radius1: real32, center2: Vector2, radius2: real32): bool\n"
        /* 0475 */ "fn CheckCollisionCircleRec*(center: Vector2, radius: real32, rec: Rectangle): bool\n"
        /* 0476 */ "fn CheckCollisionPointRec*(point: Vector2, rec: Rectangle): bool\n"
        /* 0477 */ "fn CheckCollisionPointCircle*(point: Vector2, center: Vector2, radius: real32): bool\n"
        /* 0478 */ "fn CheckCollisionPointTriangle*(point: Vector2, p1: Vector2, p2: Vector2, p3: Vector2): bool\n"
        /* 0479 */ "fn CheckCollisionLines*(startPos1: Vector2, endPos1: Vector2, startPos2: Vector2, endPos2: Vector2, collisionPoint: ^Vector2): bool\n"
        /* 0480 */ "fn CheckCollisionPointLine*(point: Vector2, p1: Vector2, p2: Vector2, threshold: int32): bool\n"
        /* 0481 */ "fn GetCollisionRec*(rec1: Rectangle, rec2: Rectangle): Rectangle\n"
        /* 0482 */ "fn LoadImage*(fileName: str): Image\n"
        /* 0483 */ "fn LoadImageRaw*(fileName: str, width: int32, height: int32, format: int32, headerSize: int32): Image\n"
        /* 0484 */ "fn LoadImageAnim*(fileName: str, frames: ^int32): Image\n"
        /* 0485 */ "fn LoadImageFromMemory*(fileType: str, fileData: ^uint8, dataSize: int32): Image\n"
        /* 0486 */ "fn LoadImageFromTexture*(texture: Texture): Image\n"
        /* 0487 */ "fn LoadImageFromScreen*(): Image\n"
        /* 0488 */ "fn UnloadImage*(image: Image)\n"
        /* 0489 */ "fn ExportImage*(image: Image, fileName: str): bool\n"
        /* 0490 */ "fn ExportImageAsCode*(image: Image, fileName: str): bool\n"
        /* 0491 */ "fn GenImageColor*(width: int32, height: int32, color: Color): Image\n"
        /* 0492 */ "fn GenImageGradientV*(width: int32, height: int32, top: Color, bottom: Color): Image\n"
        /* 0493 */ "fn GenImageGradientH*(width: int32, height: int32, left: Color, right: Color): Image\n"
        /* 0494 */ "fn GenImageGradientRadial*(width: int32, height: int32, density: real32, inner: Color, outer: Color): Image\n"
        /* 0495 */ "fn GenImageChecked*(width: int32, height: int32, checksX: int32, checksY: int32, col1: Color, col2: Color): Image\n"
        /* 0496 */ "fn GenImageWhiteNoise*(width: int32, height: int32, factor: real32): Image\n"
        /* 0497 */ "fn GenImageCellular*(width: int32, height: int32, tileSize: int32): Image\n"
        /* 0498 */ "fn ImageCopy*(image: Image): Image\n"
        /* 0499 */ "fn ImageFromImage*(image: Image, rec: Rectangle): Image\n"
        /* 0500 */ "fn ImageText*(text: str, fontSize: int32, color: Color): Image\n"
        /* 0501 */ "fn ImageTextEx*(font: Font, text: str, fontSize: real32, spacing: real32, tint: Color): Image\n"
        /* 0502 */ "fn ImageFormat*(image: ^Image, newFormat: int32)\n"
        /* 0503 */ "fn ImageToPOT*(image: ^Image, fill: Color)\n"
        /* 0504 */ "fn ImageCrop*(image: ^Image, crop: Rectangle)\n"
        /* 0505 */ "fn ImageAlphaCrop*(image: ^Image, threshold: real32)\n"
        /* 0506 */ "fn ImageAlphaClear*(image: ^Image, color: Color, threshold: real32)\n"
        /* 0507 */ "fn ImageAlphaMask*(image: ^Image, alphaMask: Image)\n"
        /* 0508 */ "fn ImageAlphaPremultiply*(image: ^Image)\n"
        /* 0509 */ "fn ImageResize*(image: ^Image, newWidth: int32, newHeight: int32)\n"
        /* 0510 */ "fn ImageResizeNN*(image: ^Image, newWidth: int32, newHeight: int32)\n"
        /* 0511 */ "fn ImageResizeCanvas*(image: ^Image, newWidth: int32, newHeight: int32, offsetX: int32, offsetY: int32, fill: Color)\n"
        /* 0512 */ "fn ImageMipmaps*(image: ^Image)\n"
        /* 0513 */ "fn ImageDither*(image: ^Image, rBpp: int32, gBpp: int32, bBpp: int32, aBpp: int32)\n"
        /* 0514 */ "fn ImageFlipVertical*(image: ^Image)\n"
        /* 0515 */ "fn ImageFlipHorizontal*(image: ^Image)\n"
        /* 0516 */ "fn ImageRotateCW*(image: ^Image)\n"
        /* 0517 */ "fn ImageRotateCCW*(image: ^Image)\n"
        /* 0518 */ "fn ImageColorTint*(image: ^Image, color: Color)\n"
        /* 0519 */ "fn ImageColorInvert*(image: ^Image)\n"
        /* 0520 */ "fn ImageColorGrayscale*(image: ^Image)\n"
        /* 0521 */ "fn ImageColorContrast*(image: ^Image, contrast: real32)\n"
        /* 0522 */ "fn ImageColorBrightness*(image: ^Image, brightness: int32)\n"
        /* 0523 */ "fn ImageColorReplace*(image: ^Image, color: Color, replace: Color)\n"
        /* 0524 */ "fn LoadImageColors*(image: Image): ^Color\n"
        /* 0525 */ "fn LoadImagePalette*(image: Image, maxPaletteSize: int32, colorCount: ^int32): ^Color\n"
        /* 0526 */ "fn UnloadImageColors*(colors: ^Color)\n"
        /* 0527 */ "fn UnloadImagePalette*(colors: ^Color)\n"
        /* 0528 */ "fn GetImageAlphaBorder*(image: Image, threshold: real32): Rectangle\n"
        /* 0529 */ "fn GetImageColor*(image: Image, x: int32, y: int32): Color\n"
        /* 0530 */ "fn ImageClearBackground*(dst: ^Image, color: Color)\n"
        /* 0531 */ "fn ImageDrawPixel*(dst: ^Image, posX: int32, posY: int32, color: Color)\n"
        /* 0532 */ "fn ImageDrawPixelV*(dst: ^Image, position: Vector2, color: Color)\n"
        /* 0533 */ "fn ImageDrawLine*(dst: ^Image, startPosX: int32, startPosY: int32, endPosX: int32, endPosY: int32, color: Color)\n"
        /* 0534 */ "fn ImageDrawLineV*(dst: ^Image, start: Vector2, end: Vector2, color: Color)\n"
        /* 0535 */ "fn ImageDrawCircle*(dst: ^Image, centerX: int32, centerY: int32, radius: int32, color: Color)\n"
        /* 0536 */ "fn ImageDrawCircleV*(dst: ^Image, center: Vector2, radius: int32, color: Color)\n"
        /* 0537 */ "fn ImageDrawRectangle*(dst: ^Image, posX: int32, posY: int32, width: int32, height: int32, color: Color)\n"
        /* 0538 */ "fn ImageDrawRectangleV*(dst: ^Image, position: Vector2, size: Vector2, color: Color)\n"
        /* 0539 */ "fn ImageDrawRectangleRec*(dst: ^Image, rec: Rectangle, color: Color)\n"
        /* 0540 */ "fn ImageDrawRectangleLines*(dst: ^Image, rec: Rectangle, thick: int32, color: Color)\n"
        /* 0541 */ "fn ImageDraw*(dst: ^Image, src: Image, srcRec: Rectangle, dstRec: Rectangle, tint: Color)\n"
        /* 0542 */ "fn ImageDrawText*(dst: ^Image, text: str, posX: int32, posY: int32, fontSize: int32, color: Color)\n"
        /* 0543 */ "fn ImageDrawTextEx*(dst: ^Image, font: Font, text: str, position: Vector2, fontSize: real32, spacing: real32, tint: Color)\n"
        /* 0544 */ "fn LoadTexture*(fileName: str): Texture\n"
        /* 0545 */ "fn LoadTextureFromImage*(image: Image): Texture\n"
        /* 0546 */ "fn LoadTextureCubemap*(image: Image, layout: int32): Texture\n"
        /* 0547 */ "fn LoadRenderTexture*(width: int32, height: int32): RenderTexture\n"
        /* 0548 */ "fn UnloadTexture*(texture: Texture)\n"
        /* 0549 */ "fn UnloadRenderTexture*(target: RenderTexture)\n"
        /* 0550 */ "fn UpdateTexture*(texture: Texture, pixels: ^void)\n"
        /* 0551 */ "fn UpdateTextureRec*(texture: Texture, rec: Rectangle, pixels: ^void)\n"
        /* 0552 */ "fn GenTextureMipmaps*(texture: ^Texture)\n"
        /* 0553 */ "fn SetTextureFilter*(texture: Texture, filter: int32)\n"
        /* 0554 */ "fn SetTextureWrap*(texture: Texture, wrap: int32)\n"
        /* 0555 */ "fn DrawTexture*(texture: Texture, posX: int32, posY: int32, tint: Color)\n"
        /* 0556 */ "fn DrawTextureV*(texture: Texture, position: Vector2, tint: Color)\n"
        /* 0557 */ "fn DrawTextureEx*(texture: Texture, position: Vector2, rotation: real32, scale: real32, tint: Color)\n"
        /* 0558 */ "fn DrawTextureRec*(texture: Texture, source: Rectangle, position: Vector2, tint: Color)\n"
        /* 0559 */ "fn DrawTextureQuad*(texture: Texture, tiling: Vector2, offset: Vector2, quad: Rectangle, tint: Color)\n"
        /* 0560 */ "fn DrawTextureTiled*(texture: Texture, source: Rectangle, dest: Rectangle, origin: Vector2, rotation: real32, scale: real32, tint: Color)\n"
        /* 0561 */ "fn DrawTexturePro*(texture: Texture, source: Rectangle, dest: Rectangle, origin: Vector2, rotation: real32, tint: Color)\n"
        /* 0562 */ "fn DrawTextureNPatch*(texture: Texture, nPatchInfo: NPatchInfo, dest: Rectangle, origin: Vector2, rotation: real32, tint: Color)\n"
        /* 0563 */ "fn DrawTexturePoly*(texture: Texture, center: Vector2, points: ^Vector2, texcoords: ^Vector2, pointCount: int32, tint: Color)\n"
        /* 0564 */ "fn Fade*(color: Color, alpha: real32): Color\n"
        /* 0565 */ "fn ColorToInt*(color: Color): int32\n"
        /* 0566 */ "fn ColorNormalize*(color: Color): Vector4\n"
        /* 0567 */ "fn ColorFromNormalized*(normalized: Vector4): Color\n"
        /* 0568 */ "fn ColorToHSV*(color: Color): Vector3\n"
        /* 0569 */ "fn ColorFromHSV*(hue: real32, saturation: real32, value: real32): Color\n"
        /* 0570 */ "fn ColorAlpha*(color: Color, alpha: real32): Color\n"
        /* 0571 */ "fn ColorAlphaBlend*(dst: Color, src: Color, tint: Color): Color\n"
        /* 0572 */ "fn GetColor*(hexValue: uint32): Color\n"
        /* 0573 */ "fn GetPixelColor*(srcPtr: ^void, format: int32): Color\n"
        /* 0574 */ "fn SetPixelColor*(dstPtr: ^void, color: Color, format: int32)\n"
        /* 0575 */ "fn GetPixelDataSize*(width: int32, height: int32, format: int32): int32\n"
        /* 0576 */ "fn GetFontDefault*(): Font\n"
        /* 0577 */ "fn LoadFont*(fileName: str): Font\n"
        /* 0578 */ "fn LoadFontEx*(fileName: str, fontSize: int32, fontChars: ^int32, glyphCount: int32): Font\n"
        /* 0579 */ "fn LoadFontFromImage*(image: Image, key: Color, firstChar: int32): Font\n"
        /* 0580 */ "fn LoadFontFromMemory*(fileType: str, fileData: ^uint8, dataSize: int32, fontSize: int32, fontChars: ^int32, glyphCount: int32): Font\n"
        /* 0581 */ "// Skipping LoadFontData\n"
        /* 0582 */ "fn GenImageFontAtlas*(chars: ^void, recs: ^void, glyphCount: int32, fontSize: int32, padding: int32, packMethod: int32): Image\n"
        /* 0583 */ "fn UnloadFontData*(chars: ^GlyphInfo, glyphCount: int32)\n"
        /* 0584 */ "fn UnloadFont*(font: Font)\n"
        /* 0585 */ "fn ExportFontAsCode*(font: Font, fileName: str): bool\n"
        /* 0586 */ "fn DrawFPS*(posX: int32, posY: int32)\n"
        /* 0587 */ "fn DrawText*(text: str, posX: int32, posY: int32, fontSize: int32, color: Color)\n"
        /* 0588 */ "fn DrawTextEx*(font: Font, text: str, position: Vector2, fontSize: real32, spacing: real32, tint: Color)\n"
        /* 0589 */ "fn DrawTextPro*(font: Font, text: str, position: Vector2, origin: Vector2, rotation: real32, fontSize: real32, spacing: real32, tint: Color)\n"
        /* 0590 */ "fn DrawTextCodepoint*(font: Font, codepoint: int32, position: Vector2, fontSize: real32, tint: Color)\n"
        /* 0591 */ "fn DrawTextCodepoints*(font: Font, codepoints: ^int32, count: int32, position: Vector2, fontSize: real32, spacing: real32, tint: Color)\n"
        /* 0592 */ "fn MeasureText*(text: str, fontSize: int32): int32\n"
        /* 0593 */ "fn MeasureTextEx*(font: Font, text: str, fontSize: real32, spacing: real32): Vector2\n"
        /* 0594 */ "fn GetGlyphIndex*(font: Font, codepoint: int32): int32\n"
        /* 0595 */ "fn GetGlyphInfo*(font: Font, codepoint: int32): GlyphInfo\n"
        /* 0596 */ "fn GetGlyphAtlasRec*(font: Font, codepoint: int32): Rectangle\n"
        /* 0597 */ "fn LoadCodepoints*(text: str, count: ^int32): ^int32\n"
        /* 0598 */ "fn UnloadCodepoints*(codepoints: ^int32)\n"
        /* 0599 */ "fn GetCodepointCount*(text: str): int32\n"
        /* 0600 */ "fn GetCodepoint*(text: str, bytesProcessed: ^int32): int32\n"
        /* 0601 */ "fn CodepointToUTF8*(codepoint: int32, byteSize: ^int32): str\n"
        /* 0602 */ "fn TextCodepointsToUTF8*(codepoints: ^int32, length: int32): str\n"
        /* 0603 */ "fn TextCopy*(dst: str, src: str): int32\n"
        /* 0604 */ "fn TextIsEqual*(text1: str, text2: str): bool\n"
        /* 0605 */ "fn TextLength*(text: str): uint32\n"
        /* 0606 */ "// Skipping TextFormat\n"
        /* 0607 */ "fn TextSubtext*(text: str, position: int32, length: int32): str\n"
        /* 0608 */ "fn TextReplace*(text: str, replace: str, by: str): str\n"
        /* 0609 */ "fn TextInsert*(text: str, insert: str, position: int32): str\n"
        /* 0610 */ "fn TextJoin*(textList: ^str, count: int32, delimiter: str): str\n"
        /* 0611 */ "fn TextSplit*(text: str, delimiter: char, count: ^int32): ^str\n"
        /* 0612 */ "fn TextAppend*(text: str, append: str, position: ^int32)\n"
        /* 0613 */ "fn TextFindIndex*(text: str, find: str): int32\n"
        /* 0614 */ "fn TextToUpper*(text: str): str\n"
        /* 0615 */ "fn TextToLower*(text: str): str\n"
        /* 0616 */ "fn TextToPascal*(text: str): str\n"
        /* 0617 */ "fn TextToInteger*(text: str): int32\n"
        /* 0618 */ "fn DrawLine3D*(startPos: Vector3, endPos: Vector3, color: Color)\n"
        /* 0619 */ "fn DrawPoint3D*(position: Vector3, color: Color)\n"
        /* 0620 */ "fn DrawCircle3D*(center: Vector3, radius: real32, rotationAxis: Vector3, rotationAngle: real32, color: Color)\n"
        /* 0621 */ "fn DrawTriangle3D*(v1: Vector3, v2: Vector3, v3: Vector3, color: Color)\n"
        /* 0622 */ "fn DrawTriangleStrip3D*(points: ^Vector3, pointCount: int32, color: Color)\n"
        /* 0623 */ "fn DrawCube*(position: Vector3, width: real32, height: real32, length: real32, color: Color)\n"
        /* 0624 */ "fn DrawCubeV*(position: Vector3, size: Vector3, color: Color)\n"
        /* 0625 */ "fn DrawCubeWires*(position: Vector3, width: real32, height: real32, length: real32, color: Color)\n"
        /* 0626 */ "fn DrawCubeWiresV*(position: Vector3, size: Vector3, color: Color)\n"
        /* 0627 */ "fn DrawCubeTexture*(texture: Texture, position: Vector3, width: real32, height: real32, length: real32, color: Color)\n"
        /* 0628 */ "fn DrawCubeTextureRec*(texture: Texture, source: Rectangle, position: Vector3, width: real32, height: real32, length: real32, color: Color)\n"
        /* 0629 */ "fn DrawSphere*(centerPos: Vector3, radius: real32, color: Color)\n"
        /* 0630 */ "fn DrawSphereEx*(centerPos: Vector3, radius: real32, rings: int32, slices: int32, color: Color)\n"
        /* 0631 */ "fn DrawSphereWires*(centerPos: Vector3, radius: real32, rings: int32, slices: int32, color: Color)\n"
        /* 0632 */ "fn DrawCylinder*(position: Vector3, radiusTop: real32, radiusBottom: real32, height: real32, slices: int32, color: Color)\n"
        /* 0633 */ "fn DrawCylinderEx*(startPos: Vector3, endPos: Vector3, startRadius: real32, endRadius: real32, sides: int32, color: Color)\n"
        /* 0634 */ "fn DrawCylinderWires*(position: Vector3, radiusTop: real32, radiusBottom: real32, height: real32, slices: int32, color: Color)\n"
        /* 0635 */ "fn DrawCylinderWiresEx*(startPos: Vector3, endPos: Vector3, startRadius: real32, endRadius: real32, sides: int32, color: Color)\n"
        /* 0636 */ "fn DrawPlane*(centerPos: Vector3, size: Vector2, color: Color)\n"
        /* 0637 */ "fn DrawRay*(ray: Ray, color: Color)\n"
        /* 0638 */ "fn DrawGrid*(slices: int32, spacing: real32)\n"
        /* 0639 */ "fn LoadModel*(fileName: str): Model\n"
        /* 0640 */ "fn LoadModelFromMesh*(mesh: Mesh): Model\n"
        /* 0641 */ "fn UnloadModel*(model: Model)\n"
        /* 0642 */ "fn UnloadModelKeepMeshes*(model: Model)\n"
        /* 0643 */ "fn GetModelBoundingBox*(model: Model): BoundingBox\n"
        /* 0644 */ "fn DrawModel*(model: Model, position: Vector3, scale: real32, tint: Color)\n"
        /* 0645 */ "fn DrawModelEx*(model: Model, position: Vector3, rotationAxis: Vector3, rotationAngle: real32, scale: Vector3, tint: Color)\n"
        /* 0646 */ "fn DrawModelWires*(model: Model, position: Vector3, scale: real32, tint: Color)\n"
        /* 0647 */ "fn DrawModelWiresEx*(model: Model, position: Vector3, rotationAxis: Vector3, rotationAngle: real32, scale: Vector3, tint: Color)\n"
        /* 0648 */ "fn DrawBoundingBox*(box: BoundingBox, color: Color)\n"
        /* 0649 */ "fn DrawBillboard*(camera: Camera3D, texture: Texture, position: Vector3, size: real32, tint: Color)\n"
        /* 0650 */ "fn DrawBillboardRec*(camera: Camera3D, texture: Texture, source: Rectangle, position: Vector3, size: Vector2, tint: Color)\n"
        /* 0651 */ "fn DrawBillboardPro*(camera: Camera3D, texture: Texture, source: Rectangle, position: Vector3, up: Vector3, size: Vector2, origin: Vector2, rotation: real32, tint: Color)\n"
        /* 0652 */ "fn UploadMesh*(mesh: ^Mesh, dynamic: bool)\n"
        /* 0653 */ "fn UpdateMeshBuffer*(mesh: Mesh, index: int32, data: ^void, dataSize: int32, offset: int32)\n"
        /* 0654 */ "fn UnloadMesh*(mesh: Mesh)\n"
        /* 0655 */ "fn DrawMesh*(mesh: Mesh, material: Material, transform: Matrix)\n"
        /* 0656 */ "fn DrawMeshInstanced*(mesh: Mesh, material: Material, transforms: ^Matrix, instances: int32)\n"
        /* 0657 */ "fn ExportMesh*(mesh: Mesh, fileName: str): bool\n"
        /* 0658 */ "fn GetMeshBoundingBox*(mesh: Mesh): BoundingBox\n"
        /* 0659 */ "fn GenMeshTangents*(mesh: ^Mesh)\n"
        /* 0660 */ "fn GenMeshPoly*(sides: int32, radius: real32): Mesh\n"
        /* 0661 */ "fn GenMeshPlane*(width: real32, length: real32, resX: int32, resZ: int32): Mesh\n"
        /* 0662 */ "fn GenMeshCube*(width: real32, height: real32, length: real32): Mesh\n"
        /* 0663 */ "fn GenMeshSphere*(radius: real32, rings: int32, slices: int32): Mesh\n"
        /* 0664 */ "fn GenMeshHemiSphere*(radius: real32, rings: int32, slices: int32): Mesh\n"
        /* 0665 */ "fn GenMeshCylinder*(radius: real32, height: real32, slices: int32): Mesh\n"
        /* 0666 */ "fn GenMeshCone*(radius: real32, height: real32, slices: int32): Mesh\n"
        /* 0667 */ "fn GenMeshTorus*(radius: real32, size: real32, radSeg: int32, sides: int32): Mesh\n"
        /* 0668 */ "fn GenMeshKnot*(radius: real32, size: real32, radSeg: int32, sides: int32): Mesh\n"
        /* 0669 */ "fn GenMeshHeightmap*(heightmap: Image, size: Vector3): Mesh\n"
        /* 0670 */ "fn GenMeshCubicmap*(cubicmap: Image, cubeSize: Vector3): Mesh\n"
        /* 0671 */ "fn LoadMaterials*(fileName: str, materialCount: ^int32): ^Material\n"
        /* 0672 */ "fn LoadMaterialDefault*(): Material\n"
        /* 0673 */ "fn UnloadMaterial*(material: Material)\n"
        /* 0674 */ "fn SetMaterialTexture*(material: ^Material, mapType: int32, texture: Texture)\n"
        /* 0675 */ "fn SetModelMeshMaterial*(model: ^Model, meshId: int32, materialId: int32)\n"
        /* 0676 */ "fn LoadModelAnimations*(fileName: str, animCount: ^uint32): ^ModelAnimation\n"
        /* 0677 */ "fn UpdateModelAnimation*(model: Model, anim: ModelAnimation, frame: int32)\n"
        /* 0678 */ "fn UnloadModelAnimation*(anim: ModelAnimation)\n"
        /* 0679 */ "fn UnloadModelAnimations*(animations: ^ModelAnimation, count: uint32)\n"
        /* 0680 */ "fn IsModelAnimationValid*(model: Model, anim: ModelAnimation): bool\n"
        /* 0681 */ "fn CheckCollisionSpheres*(center1: Vector3, radius1: real32, center2: Vector3, radius2: real32): bool\n"
        /* 0682 */ "fn CheckCollisionBoxes*(box1: BoundingBox, box2: BoundingBox): bool\n"
        /* 0683 */ "fn CheckCollisionBoxSphere*(box: BoundingBox, center: Vector3, radius: real32): bool\n"
        /* 0684 */ "fn GetRayCollisionSphere*(ray: Ray, center: Vector3, radius: real32): RayCollision\n"
        /* 0685 */ "fn GetRayCollisionBox*(ray: Ray, box: BoundingBox): RayCollision\n"
        /* 0686 */ "fn GetRayCollisionMesh*(ray: Ray, mesh: Mesh, transform: Matrix): RayCollision\n"
        /* 0687 */ "fn GetRayCollisionTriangle*(ray: Ray, p1: Vector3, p2: Vector3, p3: Vector3): RayCollision\n"
        /* 0688 */ "fn GetRayCollisionQuad*(ray: Ray, p1: Vector3, p2: Vector3, p3: Vector3, p4: Vector3): RayCollision\n"
        /* 0689 */ "fn InitAudioDevice*()\n"
        /* 0690 */ "fn CloseAudioDevice*()\n"
        /* 0691 */ "fn IsAudioDeviceReady*(): bool\n"
        /* 0692 */ "fn SetMasterVolume*(volume: real32)\n"
        /* 0693 */ "fn LoadWave*(fileName: str): Wave\n"
        /* 0694 */ "fn LoadWaveFromMemory*(fileType: str, fileData: ^uint8, dataSize: int32): Wave\n"
        /* 0695 */ "fn LoadSound*(fileName: str): Sound\n"
        /* 0696 */ "fn LoadSoundFromWave*(wave: Wave): Sound\n"
        /* 0697 */ "fn UpdateSound*(sound: Sound, data: ^void, sampleCount: int32)\n"
        /* 0698 */ "fn UnloadWave*(wave: Wave)\n"
        /* 0699 */ "fn UnloadSound*(sound: Sound)\n"
        /* 0700 */ "fn ExportWave*(wave: Wave, fileName: str): bool\n"
        /* 0701 */ "fn ExportWaveAsCode*(wave: Wave, fileName: str): bool\n"
        /* 0702 */ "fn PlaySound*(sound: Sound)\n"
        /* 0703 */ "fn StopSound*(sound: Sound)\n"
        /* 0704 */ "fn PauseSound*(sound: Sound)\n"
        /* 0705 */ "fn ResumeSound*(sound: Sound)\n"
        /* 0706 */ "fn PlaySoundMulti*(sound: Sound)\n"
        /* 0707 */ "fn StopSoundMulti*()\n"
        /* 0708 */ "fn GetSoundsPlaying*(): int32\n"
        /* 0709 */ "fn IsSoundPlaying*(sound: Sound): bool\n"
        /* 0710 */ "fn SetSoundVolume*(sound: Sound, volume: real32)\n"
        /* 0711 */ "fn SetSoundPitch*(sound: Sound, pitch: real32)\n"
        /* 0712 */ "fn SetSoundPan*(sound: Sound, pan: real32)\n"
        /* 0713 */ "fn WaveCopy*(wave: Wave): Wave\n"
        /* 0714 */ "fn WaveCrop*(wave: ^Wave, initSample: int32, finalSample: int32)\n"
        /* 0715 */ "fn WaveFormat*(wave: ^Wave, sampleRate: int32, sampleSize: int32, channels: int32)\n"
        /* 0716 */ "fn LoadWaveSamples*(wave: Wave): ^real32\n"
        /* 0717 */ "fn UnloadWaveSamples*(samples: ^real32)\n"
        /* 0718 */ "fn LoadMusicStream*(fileName: str): Music\n"
        /* 0719 */ "fn LoadMusicStreamFromMemory*(fileType: str, data: ^uint8, dataSize: int32): Music\n"
        /* 0720 */ "fn UnloadMusicStream*(music: Music)\n"
        /* 0721 */ "fn PlayMusicStream*(music: Music)\n"
        /* 0722 */ "fn IsMusicStreamPlaying*(music: Music): bool\n"
        /* 0723 */ "fn UpdateMusicStream*(music: Music)\n"
        /* 0724 */ "fn StopMusicStream*(music: Music)\n"
        /* 0725 */ "fn PauseMusicStream*(music: Music)\n"
        /* 0726 */ "fn ResumeMusicStream*(music: Music)\n"
        /* 0727 */ "fn SeekMusicStream*(music: Music, position: real32)\n"
        /* 0728 */ "fn SetMusicVolume*(music: Music, volume: real32)\n"
        /* 0729 */ "fn SetMusicPitch*(music: Music, pitch: real32)\n"
        /* 0730 */ "fn SetMusicPan*(music: Music, pan: real32)\n"
        /* 0731 */ "fn GetMusicTimeLength*(music: Music): real32\n"
        /* 0732 */ "fn GetMusicTimePlayed*(music: Music): real32\n"
        /* 0733 */ "fn LoadAudioStream*(sampleRate: uint32, sampleSize: uint32, channels: uint32): AudioStream\n"
        /* 0734 */ "fn UnloadAudioStream*(stream: AudioStream)\n"
        /* 0735 */ "fn UpdateAudioStream*(stream: AudioStream, data: ^void, frameCount: int32)\n"
        /* 0736 */ "fn IsAudioStreamProcessed*(stream: AudioStream): bool\n"
        /* 0737 */ "fn PlayAudioStream*(stream: AudioStream)\n"
        /* 0738 */ "fn PauseAudioStream*(stream: AudioStream)\n"
        /* 0739 */ "fn ResumeAudioStream*(stream: AudioStream)\n"
        /* 0740 */ "fn IsAudioStreamPlaying*(stream: AudioStream): bool\n"
        /* 0741 */ "fn StopAudioStream*(stream: AudioStream)\n"
        /* 0742 */ "fn SetAudioStreamVolume*(stream: AudioStream, volume: real32)\n"
        /* 0743 */ "fn SetAudioStreamPitch*(stream: AudioStream, pitch: real32)\n"
        /* 0744 */ "fn SetAudioStreamPan*(stream: AudioStream, pan: real32)\n"
        /* 0745 */ "fn SetAudioStreamBufferSizeDefault*(size: int32)\n"
        /* 0746 */ "// Skipping SetAudioStreamCallback\n"
        /* 0747 */ "// Skipping AttachAudioStreamProcessor\n"
        /* 0748 */ "// Skipping DetachAudioStreamProcessor\n"
        /* 0749 */ "fn Clamp*(value: real32, min: real32, max: real32): real32\n"
        /* 0750 */ "fn Lerp*(start: real32, end: real32, amount: real32): real32\n"
        /* 0751 */ "fn Normalize*(value: real32, start: real32, end: real32): real32\n"
        /* 0752 */ "fn Remap*(value: real32, inputStart: real32, inputEnd: real32, outputStart: real32, outputEnd: real32): real32\n"
        /* 0753 */ "fn Wrap*(value: real32, min: real32, max: real32): real32\n"
        /* 0754 */ "fn FloatEquals*(x: real32, y: real32): int32\n"
        /* 0755 */ "fn Vector2Zero*(): Vector2\n"
        /* 0756 */ "fn Vector2One*(): Vector2\n"
        /* 0757 */ "fn Vector2Add*(v1: Vector2, v2: Vector2): Vector2\n"
        /* 0758 */ "fn Vector2AddValue*(v: Vector2, add: real32): Vector2\n"
        /* 0759 */ "fn Vector2Subtract*(v1: Vector2, v2: Vector2): Vector2\n"
        /* 0760 */ "fn Vector2SubtractValue*(v: Vector2, sub: real32): Vector2\n"
        /* 0761 */ "fn Vector2Length*(v: Vector2): real32\n"
        /* 0762 */ "fn Vector2LengthSqr*(v: Vector2): real32\n"
        /* 0763 */ "fn Vector2DotProduct*(v1: Vector2, v2: Vector2): real32\n"
        /* 0764 */ "fn Vector2Distance*(v1: Vector2, v2: Vector2): real32\n"
        /* 0765 */ "fn Vector2DistanceSqr*(v1: Vector2, v2: Vector2): real32\n"
        /* 0766 */ "fn Vector2Angle*(v1: Vector2, v2: Vector2): real32\n"
        /* 0767 */ "fn Vector2Scale*(v: Vector2, scale: real32): Vector2\n"
        /* 0768 */ "fn Vector2Multiply*(v1: Vector2, v2: Vector2): Vector2\n"
        /* 0769 */ "fn Vector2Negate*(v: Vector2): Vector2\n"
        /* 0770 */ "fn Vector2Divide*(v1: Vector2, v2: Vector2): Vector2\n"
        /* 0771 */ "fn Vector2Normalize*(v: Vector2): Vector2\n"
        /* 0772 */ "fn Vector2Transform*(v: Vector2, mat: Matrix): Vector2\n"
        /* 0773 */ "fn Vector2Lerp*(v1: Vector2, v2: Vector2, amount: real32): Vector2\n"
        /* 0774 */ "fn Vector2Reflect*(v: Vector2, normal: Vector2): Vector2\n"
        /* 0775 */ "fn Vector2Rotate*(v: Vector2, angle: real32): Vector2\n"
        /* 0776 */ "fn Vector2MoveTowards*(v: Vector2, target: Vector2, maxDistance: real32): Vector2\n"
        /* 0777 */ "fn Vector2Invert*(v: Vector2): Vector2\n"
        /* 0778 */ "fn Vector2Clamp*(v: Vector2, min: Vector2, max: Vector2): Vector2\n"
        /* 0779 */ "fn Vector2ClampValue*(v: Vector2, min: real32, max: real32): Vector2\n"
        /* 0780 */ "fn Vector2Equals*(p: Vector2, q: Vector2): int32\n"
        /* 0781 */ "fn Vector3Zero*(): Vector3\n"
        /* 0782 */ "fn Vector3One*(): Vector3\n"
        /* 0783 */ "fn Vector3Add*(v1: Vector3, v2: Vector3): Vector3\n"
        /* 0784 */ "fn Vector3AddValue*(v: Vector3, add: real32): Vector3\n"
        /* 0785 */ "fn Vector3Subtract*(v1: Vector3, v2: Vector3): Vector3\n"
        /* 0786 */ "fn Vector3SubtractValue*(v: Vector3, sub: real32): Vector3\n"
        /* 0787 */ "fn Vector3Scale*(v: Vector3, scalar: real32): Vector3\n"
        /* 0788 */ "fn Vector3Multiply*(v1: Vector3, v2: Vector3): Vector3\n"
        /* 0789 */ "fn Vector3CrossProduct*(v1: Vector3, v2: Vector3): Vector3\n"
        /* 0790 */ "fn Vector3Perpendicular*(v: Vector3): Vector3\n"
        /* 0791 */ "fn Vector3Length*(v: Vector3): real32\n"
        /* 0792 */ "fn Vector3LengthSqr*(v: Vector3): real32\n"
        /* 0793 */ "fn Vector3DotProduct*(v1: Vector3, v2: Vector3): real32\n"
        /* 0794 */ "fn Vector3Distance*(v1: Vector3, v2: Vector3): real32\n"
        /* 0795 */ "fn Vector3DistanceSqr*(v1: Vector3, v2: Vector3): real32\n"
        /* 0796 */ "fn Vector3Angle*(v1: Vector3, v2: Vector3): real32\n"
        /* 0797 */ "fn Vector3Negate*(v: Vector3): Vector3\n"
        /* 0798 */ "fn Vector3Divide*(v1: Vector3, v2: Vector3): Vector3\n"
        /* 0799 */ "fn Vector3Normalize*(v: Vector3): Vector3\n"
        /* 0800 */ "fn Vector3OrthoNormalize*(v1: ^Vector3, v2: ^Vector3)\n"
        /* 0801 */ "fn Vector3Transform*(v: Vector3, mat: Matrix): Vector3\n"
        /* 0802 */ "fn Vector3RotateByQuaternion*(v: Vector3, q: Vector4): Vector3\n"
        /* 0803 */ "fn Vector3RotateByAxisAngle*(v: Vector3, axis: Vector3, angle: real32): Vector3\n"
        /* 0804 */ "fn Vector3Lerp*(v1: Vector3, v2: Vector3, amount: real32): Vector3\n"
        /* 0805 */ "fn Vector3Reflect*(v: Vector3, normal: Vector3): Vector3\n"
        /* 0806 */ "fn Vector3Min*(v1: Vector3, v2: Vector3): Vector3\n"
        /* 0807 */ "fn Vector3Max*(v1: Vector3, v2: Vector3): Vector3\n"
        /* 0808 */ "fn Vector3Barycenter*(p: Vector3, a: Vector3, b: Vector3, c: Vector3): Vector3\n"
        /* 0809 */ "fn Vector3Unproject*(source: Vector3, projection: Matrix, view: Matrix): Vector3\n"
        /* 0810 */ "fn Vector3ToFloatV*(v: Vector3): float3\n"
        /* 0811 */ "fn Vector3Invert*(v: Vector3): Vector3\n"
        /* 0812 */ "fn Vector3Clamp*(v: Vector3, min: Vector3, max: Vector3): Vector3\n"
        /* 0813 */ "fn Vector3ClampValue*(v: Vector3, min: real32, max: real32): Vector3\n"
        /* 0814 */ "fn Vector3Equals*(p: Vector3, q: Vector3): int32\n"
        /* 0815 */ "fn Vector3Refract*(v: Vector3, n: Vector3, r: real32): Vector3\n"
        /* 0816 */ "fn MatrixDeterminant*(mat: Matrix): real32\n"
        /* 0817 */ "fn MatrixTrace*(mat: Matrix): real32\n"
        /* 0818 */ "fn MatrixTranspose*(mat: Matrix): Matrix\n"
        /* 0819 */ "fn MatrixInvert*(mat: Matrix): Matrix\n"
        /* 0820 */ "fn MatrixIdentity*(): Matrix\n"
        /* 0821 */ "fn MatrixAdd*(left: Matrix, right: Matrix): Matrix\n"
        /* 0822 */ "fn MatrixSubtract*(left: Matrix, right: Matrix): Matrix\n"
        /* 0823 */ "fn MatrixMultiply*(left: Matrix, right: Matrix): Matrix\n"
        /* 0824 */ "fn MatrixTranslate*(x: real32, y: real32, z: real32): Matrix\n"
        /* 0825 */ "fn MatrixRotate*(axis: Vector3, angle: real32): Matrix\n"
        /* 0826 */ "fn MatrixRotateX*(angle: real32): Matrix\n"
        /* 0827 */ "fn MatrixRotateY*(angle: real32): Matrix\n"
        /* 0828 */ "fn MatrixRotateZ*(angle: real32): Matrix\n"
        /* 0829 */ "fn MatrixRotateXYZ*(angle: Vector3): Matrix\n"
        /* 0830 */ "fn MatrixRotateZYX*(angle: Vector3): Matrix\n"
        /* 0831 */ "fn MatrixScale*(x: real32, y: real32, z: real32): Matrix\n"
        /* 0832 */ "fn MatrixFrustum*(left: real, right: real, bottom: real, top: real, near: real, far: real): Matrix\n"
        /* 0833 */ "fn MatrixPerspective*(fovy: real, aspect: real, near: real, far: real): Matrix\n"
        /* 0834 */ "fn MatrixOrtho*(left: real, right: real, bottom: real, top: real, near: real, far: real): Matrix\n"
        /* 0835 */ "fn MatrixLookAt*(eye: Vector3, target: Vector3, up: Vector3): Matrix\n"
        /* 0836 */ "fn MatrixToFloatV*(mat: Matrix): float16\n"
        /* 0837 */ "fn QuaternionAdd*(q1: Vector4, q2: Vector4): Vector4\n"
        /* 0838 */ "fn QuaternionAddValue*(q: Vector4, add: real32): Vector4\n"
        /* 0839 */ "fn QuaternionSubtract*(q1: Vector4, q2: Vector4): Vector4\n"
        /* 0840 */ "fn QuaternionSubtractValue*(q: Vector4, sub: real32): Vector4\n"
        /* 0841 */ "fn QuaternionIdentity*(): Vector4\n"
        /* 0842 */ "fn QuaternionLength*(q: Vector4): real32\n"
        /* 0843 */ "fn QuaternionNormalize*(q: Vector4): Vector4\n"
        /* 0844 */ "fn QuaternionInvert*(q: Vector4): Vector4\n"
        /* 0845 */ "fn QuaternionMultiply*(q1: Vector4, q2: Vector4): Vector4\n"
        /* 0846 */ "fn QuaternionScale*(q: Vector4, mul: real32): Vector4\n"
        /* 0847 */ "fn QuaternionDivide*(q1: Vector4, q2: Vector4): Vector4\n"
        /* 0848 */ "fn QuaternionLerp*(q1: Vector4, q2: Vector4, amount: real32): Vector4\n"
        /* 0849 */ "fn QuaternionNlerp*(q1: Vector4, q2: Vector4, amount: real32): Vector4\n"
        /* 0850 */ "fn QuaternionSlerp*(q1: Vector4, q2: Vector4, amount: real32): Vector4\n"
        /* 0851 */ "fn QuaternionFromVector3ToVector3*(from: Vector3, to: Vector3): Vector4\n"
        /* 0852 */ "fn QuaternionFromMatrix*(mat: Matrix): Vector4\n"
        /* 0853 */ "fn QuaternionToMatrix*(q: Vector4): Matrix\n"
        /* 0854 */ "fn QuaternionFromAxisAngle*(axis: Vector3, angle: real32): Vector4\n"
        /* 0855 */ "fn QuaternionToAxisAngle*(q: Vector4, outAxis: ^Vector3, outAngle: ^real32)\n"
        /* 0856 */ "fn QuaternionFromEuler*(pitch: real32, yaw: real32, roll: real32): Vector4\n"
        /* 0857 */ "fn QuaternionToEuler*(q: Vector4): Vector3\n"
        /* 0858 */ "fn QuaternionTransform*(q: Vector4, mat: Matrix): Vector4\n"
        /* 0859 */ "fn QuaternionEquals*(p: Vector4, q: Vector4): int32\n"
        /* 0860 */ "fn rlMatrixMode*(mode: int32)\n"
        /* 0861 */ "fn rlPushMatrix*()\n"
        /* 0862 */ "fn rlPopMatrix*()\n"
        /* 0863 */ "fn rlLoadIdentity*()\n"
        /* 0864 */ "fn rlTranslatef*(x: real32, y: real32, z: real32)\n"
        /* 0865 */ "fn rlRotatef*(angle: real32, x: real32, y: real32, z: real32)\n"
        /* 0866 */ "fn rlScalef*(x: real32, y: real32, z: real32)\n"
        /* 0867 */ "fn rlMultMatrixf*(matf: ^real32)\n"
        /* 0868 */ "fn rlFrustum*(left: real, right: real, bottom: real, top: real, znear: real, zfar: real)\n"
        /* 0869 */ "fn rlOrtho*(left: real, right: real, bottom: real, top: real, znear: real, zfar: real)\n"
        /* 0870 */ "fn rlViewport*(x: int32, y: int32, width: int32, height: int32)\n"
        /* 0871 */ "fn rlBegin*(mode: int32)\n"
        /* 0872 */ "fn rlEnd*()\n"
        /* 0873 */ "fn rlVertex2i*(x: int32, y: int32)\n"
        /* 0874 */ "fn rlVertex2f*(x: real32, y: real32)\n"
        /* 0875 */ "fn rlVertex3f*(x: real32, y: real32, z: real32)\n"
        /* 0876 */ "fn rlTexCoord2f*(x: real32, y: real32)\n"
        /* 0877 */ "fn rlNormal3f*(x: real32, y: real32, z: real32)\n"
        /* 0878 */ "fn rlColor4ub*(r: uint8, g: uint8, b: uint8, a: uint8)\n"
        /* 0879 */ "fn rlColor3f*(x: real32, y: real32, z: real32)\n"
        /* 0880 */ "fn rlColor4f*(x: real32, y: real32, z: real32, w: real32)\n"
        /* 0881 */ "fn rlEnableVertexArray*(vaoId: uint32): bool\n"
        /* 0882 */ "fn rlDisableVertexArray*()\n"
        /* 0883 */ "fn rlEnableVertexBuffer*(id: uint32)\n"
        /* 0884 */ "fn rlDisableVertexBuffer*()\n"
        /* 0885 */ "fn rlEnableVertexBufferElement*(id: uint32)\n"
        /* 0886 */ "fn rlDisableVertexBufferElement*()\n"
        /* 0887 */ "fn rlEnableVertexAttribute*(index: uint32)\n"
        /* 0888 */ "fn rlDisableVertexAttribute*(index: uint32)\n"
        /* 0889 */ "// Skipping rlEnableStatePointer\n"
        /* 0890 */ "// Skipping rlDisableStatePointer\n"
        /* 0891 */ "fn rlActiveTextureSlot*(slot: int32)\n"
        /* 0892 */ "fn rlEnableTexture*(id: uint32)\n"
        /* 0893 */ "fn rlDisableTexture*()\n"
        /* 0894 */ "fn rlEnableTextureCubemap*(id: uint32)\n"
        /* 0895 */ "fn rlDisableTextureCubemap*()\n"
        /* 0896 */ "fn rlTextureParameters*(id: uint32, param: int32, value: int32)\n"
        /* 0897 */ "fn rlEnableShader*(id: uint32)\n"
        /* 0898 */ "fn rlDisableShader*()\n"
        /* 0899 */ "fn rlEnableFramebuffer*(id: uint32)\n"
        /* 0900 */ "fn rlDisableFramebuffer*()\n"
        /* 0901 */ "fn rlActiveDrawBuffers*(count: int32)\n"
        /* 0902 */ "fn rlEnableColorBlend*()\n"
        /* 0903 */ "fn rlDisableColorBlend*()\n"
        /* 0904 */ "fn rlEnableDepthTest*()\n"
        /* 0905 */ "fn rlDisableDepthTest*()\n"
        /* 0906 */ "fn rlEnableDepthMask*()\n"
        /* 0907 */ "fn rlDisableDepthMask*()\n"
        /* 0908 */ "fn rlEnableBackfaceCulling*()\n"
        /* 0909 */ "fn rlDisableBackfaceCulling*()\n"
        /* 0910 */ "fn rlEnableScissorTest*()\n"
        /* 0911 */ "fn rlDisableScissorTest*()\n"
        /* 0912 */ "fn rlScissor*(x: int32, y: int32, width: int32, height: int32)\n"
        /* 0913 */ "fn rlEnableWireMode*()\n"
        /* 0914 */ "fn rlDisableWireMode*()\n"
        /* 0915 */ "fn rlSetLineWidth*(width: real32)\n"
        /* 0916 */ "fn rlGetLineWidth*(): real32\n"
        /* 0917 */ "fn rlEnableSmoothLines*()\n"
        /* 0918 */ "fn rlDisableSmoothLines*()\n"
        /* 0919 */ "fn rlEnableStereoRender*()\n"
        /* 0920 */ "fn rlDisableStereoRender*()\n"
        /* 0921 */ "fn rlIsStereoRenderEnabled*(): bool\n"
        /* 0922 */ "fn rlClearColor*(r: uint8, g: uint8, b: uint8, a: uint8)\n"
        /* 0923 */ "fn rlClearScreenBuffers*()\n"
        /* 0924 */ "fn rlCheckErrors*()\n"
        /* 0925 */ "fn rlSetBlendMode*(mode: int32)\n"
        /* 0926 */ "fn rlSetBlendFactors*(glSrcFactor: int32, glDstFactor: int32, glEquation: int32)\n"
        /* 0927 */ "fn rlglInit*(width: int32, height: int32)\n"
        /* 0928 */ "fn rlglClose*()\n"
        /* 0929 */ "fn rlLoadExtensions*(loader: ^void)\n"
        /* 0930 */ "fn rlGetVersion*(): int32\n"
        /* 0931 */ "fn rlSetFramebufferWidth*(width: int32)\n"
        /* 0932 */ "fn rlGetFramebufferWidth*(): int32\n"
        /* 0933 */ "fn rlSetFramebufferHeight*(height: int32)\n"
        /* 0934 */ "fn rlGetFramebufferHeight*(): int32\n"
        /* 0935 */ "fn rlGetTextureIdDefault*(): uint32\n"
        /* 0936 */ "fn rlGetShaderIdDefault*(): uint32\n"
        /* 0937 */ "fn rlGetShaderLocsDefault*(): ^int32\n"
        /* 0938 */ "// Skipping rlLoadRenderBatch\n"
        /* 0939 */ "// Skipping rlUnloadRenderBatch\n"
        /* 0940 */ "// Skipping rlDrawRenderBatch\n"
        /* 0941 */ "// Skipping rlSetRenderBatchActive\n"
        /* 0942 */ "fn rlDrawRenderBatchActive*()\n"
        /* 0943 */ "fn rlCheckRenderBatchLimit*(vCount: int32): bool\n"
        /* 0944 */ "fn rlSetTexture*(id: uint32)\n"
        /* 0945 */ "fn rlLoadVertexArray*(): uint32\n"
        /* 0946 */ "fn rlLoadVertexBuffer*(buffer: ^void, size: int32, dynamic: bool): uint32\n"
        /* 0947 */ "fn rlLoadVertexBufferElement*(buffer: ^void, size: int32, dynamic: bool): uint32\n"
        /* 0948 */ "fn rlUpdateVertexBuffer*(bufferId: uint32, data: ^void, dataSize: int32, offset: int32)\n"
        /* 0949 */ "fn rlUpdateVertexBufferElements*(id: uint32, data: ^void, dataSize: int32, offset: int32)\n"
        /* 0950 */ "fn rlUnloadVertexArray*(vaoId: uint32)\n"
        /* 0951 */ "fn rlUnloadVertexBuffer*(vboId: uint32)\n"
        /* 0952 */ "fn rlSetVertexAttribute*(index: uint32, compSize: int32, typeInput: int32, normalized: bool, stride: int32, pointer: ^void)\n"
        /* 0953 */ "fn rlSetVertexAttributeDivisor*(index: uint32, divisor: int32)\n"
        /* 0954 */ "fn rlSetVertexAttributeDefault*(locIndex: int32, value: ^void, attribType: int32, count: int32)\n"
        /* 0955 */ "fn rlDrawVertexArray*(offset: int32, count: int32)\n"
        /* 0956 */ "fn rlDrawVertexArrayElements*(offset: int32, count: int32, buffer: ^void)\n"
        /* 0957 */ "fn rlDrawVertexArrayInstanced*(offset: int32, count: int32, instances: int32)\n"
        /* 0958 */ "fn rlDrawVertexArrayElementsInstanced*(offset: int32, count: int32, buffer: ^void, instances: int32)\n"
        /* 0959 */ "fn rlLoadTexture*(data: ^void, width: int32, height: int32, format: int32, mipmapCount: int32): uint32\n"
        /* 0960 */ "fn rlLoadTextureDepth*(width: int32, height: int32, useRenderBuffer: bool): uint32\n"
        /* 0961 */ "fn rlLoadTextureCubemap*(data: ^void, size: int32, format: int32): uint32\n"
        /* 0962 */ "fn rlUpdateTexture*(id: uint32, offsetX: int32, offsetY: int32, width: int32, height: int32, format: int32, data: ^void)\n"
        /* 0963 */ "fn rlGetGlTextureFormats*(format: int32, glInternalFormat: ^uint32, glFormat: ^uint32, glType: ^uint32)\n"
        /* 0964 */ "fn rlGetPixelFormatName*(format: uint32): str\n"
        /* 0965 */ "fn rlUnloadTexture*(id: uint32)\n"
        /* 0966 */ "fn rlGenTextureMipmaps*(id: uint32, width: int32, height: int32, format: int32, mipmaps: ^int32)\n"
        /* 0967 */ "fn rlReadTexturePixels*(id: uint32, width: int32, height: int32, format: int32): ^void\n"
        /* 0968 */ "fn rlReadScreenPixels*(width: int32, height: int32): ^uint8\n"
        /* 0969 */ "fn rlLoadFramebuffer*(width: int32, height: int32): uint32\n"
        /* 0970 */ "fn rlFramebufferAttach*(fboId: uint32, texId: uint32, attachType: int32, texType: int32, mipLevel: int32)\n"
        /* 0971 */ "fn rlFramebufferComplete*(id: uint32): bool\n"
        /* 0972 */ "fn rlUnloadFramebuffer*(id: uint32)\n"
        /* 0973 */ "fn rlLoadShaderCode*(vsCode: str, fsCode: str): uint32\n"
        /* 0974 */ "fn rlCompileShader*(shaderCode: str, typeInput: int32): uint32\n"
        /* 0975 */ "fn rlLoadShaderProgram*(vShaderId: uint32, fShaderId: uint32): uint32\n"
        /* 0976 */ "fn rlUnloadShaderProgram*(id: uint32)\n"
        /* 0977 */ "fn rlGetLocationUniform*(shaderId: uint32, uniformName: str): int32\n"
        /* 0978 */ "fn rlGetLocationAttrib*(shaderId: uint32, attribName: str): int32\n"
        /* 0979 */ "fn rlSetUniform*(locIndex: int32, value: ^void, uniformType: int32, count: int32)\n"
        /* 0980 */ "fn rlSetUniformMatrix*(locIndex: int32, mat: Matrix)\n"
        /* 0981 */ "fn rlSetUniformSampler*(locIndex: int32, textureId: uint32)\n"
        /* 0982 */ "fn rlSetShader*(id: uint32, locs: ^int32)\n"
        /* 0983 */ "fn rlLoadComputeShaderProgram*(shaderId: uint32): uint32\n"
        /* 0984 */ "fn rlComputeShaderDispatch*(groupX: uint32, groupY: uint32, groupZ: uint32)\n"
        /* 0985 */ "fn rlLoadShaderBuffer*(size: uint, data: ^void, usageHint: int32): uint32\n"
        /* 0986 */ "fn rlUnloadShaderBuffer*(ssboId: uint32)\n"
        /* 0987 */ "fn rlUpdateShaderBufferElements*(id: uint32, data: ^void, dataSize: uint, offset: uint)\n"
        /* 0988 */ "fn rlGetShaderBufferSize*(id: uint32): uint\n"
        /* 0989 */ "fn rlReadShaderBufferElements*(id: uint32, dest: ^void, count: uint, offset: uint)\n"
        /* 0990 */ "fn rlBindShaderBuffer*(id: uint32, index: uint32)\n"
        /* 0991 */ "fn rlCopyBuffersElements*(destId: uint32, srcId: uint32, destOffset: uint, srcOffset: uint, count: uint)\n"
        /* 0992 */ "fn rlBindImageTexture*(id: uint32, index: uint32, format: uint32, readonly: int32)\n"
        /* 0993 */ "fn rlGetMatrixModelview*(): Matrix\n"
        /* 0994 */ "fn rlGetMatrixProjection*(): Matrix\n"
        /* 0995 */ "fn rlGetMatrixTransform*(): Matrix\n"
        /* 0996 */ "fn rlGetMatrixProjectionStereo*(eye: int32): Matrix\n"
        /* 0997 */ "fn rlGetMatrixViewOffsetStereo*(eye: int32): Matrix\n"
        /* 0998 */ "fn rlSetMatrixProjection*(proj: Matrix)\n"
        /* 0999 */ "fn rlSetMatrixModelview*(view: Matrix)\n"
        /* 1000 */ "fn rlSetMatrixProjectionStereo*(right: Matrix, left: Matrix)\n"
        /* 1001 */ "fn rlSetMatrixViewOffsetStereo*(right: Matrix, left: Matrix)\n"
        /* 1002 */ "fn rlLoadDrawCube*()\n"
        /* 1003 */ "fn rlLoadDrawQuad*()\n"
        // Enums
        /* 1004 */ "const FLAG_VSYNC_HINT* = 64\n"
        /* 1005 */ "const FLAG_FULLSCREEN_MODE* = 2\n"
        /* 1006 */ "const FLAG_WINDOW_RESIZABLE* = 4\n"
        /* 1007 */ "const FLAG_WINDOW_UNDECORATED* = 8\n"
        /* 1008 */ "const FLAG_WINDOW_HIDDEN* = 128\n"
        /* 1009 */ "const FLAG_WINDOW_MINIMIZED* = 512\n"
        /* 1010 */ "const FLAG_WINDOW_MAXIMIZED* = 1024\n"
        /* 1011 */ "const FLAG_WINDOW_UNFOCUSED* = 2048\n"
        /* 1012 */ "const FLAG_WINDOW_TOPMOST* = 4096\n"
        /* 1013 */ "const FLAG_WINDOW_ALWAYS_RUN* = 256\n"
        /* 1014 */ "const FLAG_WINDOW_TRANSPARENT* = 16\n"
        /* 1015 */ "const FLAG_WINDOW_HIGHDPI* = 8192\n"
        /* 1016 */ "const FLAG_WINDOW_MOUSE_PASSTHROUGH* = 16384\n"
        /* 1017 */ "const FLAG_MSAA_4X_HINT* = 32\n"
        /* 1018 */ "const FLAG_INTERLACED_HINT* = 65536\n"
        /* 1019 */ "const LOG_ALL* = 0\n"
        /* 1020 */ "const LOG_TRACE* = 1\n"
        /* 1021 */ "const LOG_DEBUG* = 2\n"
        /* 1022 */ "const LOG_INFO* = 3\n"
        /* 1023 */ "const LOG_WARNING* = 4\n"
        /* 1024 */ "const LOG_ERROR* = 5\n"
        /* 1025 */ "const LOG_FATAL* = 6\n"
        /* 1026 */ "const LOG_NONE* = 7\n"
        /* 1027 */ "const KEY_NULL* = 0\n"
        /* 1028 */ "const KEY_APOSTROPHE* = 39\n"
        /* 1029 */ "const KEY_COMMA* = 44\n"
        /* 1030 */ "const KEY_MINUS* = 45\n"
        /* 1031 */ "const KEY_PERIOD* = 46\n"
        /* 1032 */ "const KEY_SLASH* = 47\n"
        /* 1033 */ "const KEY_ZERO* = 48\n"
        /* 1034 */ "const KEY_ONE* = 49\n"
        /* 1035 */ "const KEY_TWO* = 50\n"
        /* 1036 */ "const KEY_THREE* = 51\n"
        /* 1037 */ "const KEY_FOUR* = 52\n"
        /* 1038 */ "const KEY_FIVE* = 53\n"
        /* 1039 */ "const KEY_SIX* = 54\n"
        /* 1040 */ "const KEY_SEVEN* = 55\n"
        /* 1041 */ "const KEY_EIGHT* = 56\n"
        /* 1042 */ "const KEY_NINE* = 57\n"
        /* 1043 */ "const KEY_SEMICOLON* = 59\n"
        /* 1044 */ "const KEY_EQUAL* = 61\n"
        /* 1045 */ "const KEY_A* = 65\n"
        /* 1046 */ "const KEY_B* = 66\n"
        /* 1047 */ "const KEY_C* = 67\n"
        /* 1048 */ "const KEY_D* = 68\n"
        /* 1049 */ "const KEY_E* = 69\n"
        /* 1050 */ "const KEY_F* = 70\n"
        /* 1051 */ "const KEY_G* = 71\n"
        /* 1052 */ "const KEY_H* = 72\n"
        /* 1053 */ "const KEY_I* = 73\n"
        /* 1054 */ "const KEY_J* = 74\n"
        /* 1055 */ "const KEY_K* = 75\n"
        /* 1056 */ "const KEY_L* = 76\n"
        /* 1057 */ "const KEY_M* = 77\n"
        /* 1058 */ "const KEY_N* = 78\n"
        /* 1059 */ "const KEY_O* = 79\n"
        /* 1060 */ "const KEY_P* = 80\n"
        /* 1061 */ "const KEY_Q* = 81\n"
        /* 1062 */ "const KEY_R* = 82\n"
        /* 1063 */ "const KEY_S* = 83\n"
        /* 1064 */ "const KEY_T* = 84\n"
        /* 1065 */ "const KEY_U* = 85\n"
        /* 1066 */ "const KEY_V* = 86\n"
        /* 1067 */ "const KEY_W* = 87\n"
        /* 1068 */ "const KEY_X* = 88\n"
        /* 1069 */ "const KEY_Y* = 89\n"
        /* 1070 */ "const KEY_Z* = 90\n"
        /* 1071 */ "const KEY_LEFT_BRACKET* = 91\n"
        /* 1072 */ "const KEY_BACKSLASH* = 92\n"
        /* 1073 */ "const KEY_RIGHT_BRACKET* = 93\n"
        /* 1074 */ "const KEY_GRAVE* = 96\n"
        /* 1075 */ "const KEY_SPACE* = 32\n"
        /* 1076 */ "const KEY_ESCAPE* = 256\n"
        /* 1077 */ "const KEY_ENTER* = 257\n"
        /* 1078 */ "const KEY_TAB* = 258\n"
        /* 1079 */ "const KEY_BACKSPACE* = 259\n"
        /* 1080 */ "const KEY_INSERT* = 260\n"
        /* 1081 */ "const KEY_DELETE* = 261\n"
        /* 1082 */ "const KEY_RIGHT* = 262\n"
        /* 1083 */ "const KEY_LEFT* = 263\n"
        /* 1084 */ "const KEY_DOWN* = 264\n"
        /* 1085 */ "const KEY_UP* = 265\n"
        /* 1086 */ "const KEY_PAGE_UP* = 266\n"
        /* 1087 */ "const KEY_PAGE_DOWN* = 267\n"
        /* 1088 */ "const KEY_HOME* = 268\n"
        /* 1089 */ "const KEY_END* = 269\n"
        /* 1090 */ "const KEY_CAPS_LOCK* = 280\n"
        /* 1091 */ "const KEY_SCROLL_LOCK* = 281\n"
        /* 1092 */ "const KEY_NUM_LOCK* = 282\n"
        /* 1093 */ "const KEY_PRINT_SCREEN* = 283\n"
        /* 1094 */ "const KEY_PAUSE* = 284\n"
        /* 1095 */ "const KEY_F1* = 290\n"
        /* 1096 */ "const KEY_F2* = 291\n"
        /* 1097 */ "const KEY_F3* = 292\n"
        /* 1098 */ "const KEY_F4* = 293\n"
        /* 1099 */ "const KEY_F5* = 294\n"
        /* 1100 */ "const KEY_F6* = 295\n"
        /* 1101 */ "const KEY_F7* = 296\n"
        /* 1102 */ "const KEY_F8* = 297\n"
        /* 1103 */ "const KEY_F9* = 298\n"
        /* 1104 */ "const KEY_F10* = 299\n"
        /* 1105 */ "const KEY_F11* = 300\n"
        /* 1106 */ "const KEY_F12* = 301\n"
        /* 1107 */ "const KEY_LEFT_SHIFT* = 340\n"
        /* 1108 */ "const KEY_LEFT_CONTROL* = 341\n"
        /* 1109 */ "const KEY_LEFT_ALT* = 342\n"
        /* 1110 */ "const KEY_LEFT_SUPER* = 343\n"
        /* 1111 */ "const KEY_RIGHT_SHIFT* = 344\n"
        /* 1112 */ "const KEY_RIGHT_CONTROL* = 345\n"
        /* 1113 */ "const KEY_RIGHT_ALT* = 346\n"
        /* 1114 */ "const KEY_RIGHT_SUPER* = 347\n"
        /* 1115 */ "const KEY_KB_MENU* = 348\n"
        /* 1116 */ "const KEY_KP_0* = 320\n"
        /* 1117 */ "const KEY_KP_1* = 321\n"
        /* 1118 */ "const KEY_KP_2* = 322\n"
        /* 1119 */ "const KEY_KP_3* = 323\n"
        /* 1120 */ "const KEY_KP_4* = 324\n"
        /* 1121 */ "const KEY_KP_5* = 325\n"
        /* 1122 */ "const KEY_KP_6* = 326\n"
        /* 1123 */ "const KEY_KP_7* = 327\n"
        /* 1124 */ "const KEY_KP_8* = 328\n"
        /* 1125 */ "const KEY_KP_9* = 329\n"
        /* 1126 */ "const KEY_KP_DECIMAL* = 330\n"
        /* 1127 */ "const KEY_KP_DIVIDE* = 331\n"
        /* 1128 */ "const KEY_KP_MULTIPLY* = 332\n"
        /* 1129 */ "const KEY_KP_SUBTRACT* = 333\n"
        /* 1130 */ "const KEY_KP_ADD* = 334\n"
        /* 1131 */ "const KEY_KP_ENTER* = 335\n"
        /* 1132 */ "const KEY_KP_EQUAL* = 336\n"
        /* 1133 */ "const KEY_BACK* = 4\n"
        /* 1134 */ "const KEY_MENU* = 82\n"
        /* 1135 */ "const KEY_VOLUME_UP* = 24\n"
        /* 1136 */ "const KEY_VOLUME_DOWN* = 25\n"
        /* 1137 */ "const MOUSE_BUTTON_LEFT* = 0\n"
        /* 1138 */ "const MOUSE_BUTTON_RIGHT* = 1\n"
        /* 1139 */ "const MOUSE_BUTTON_MIDDLE* = 2\n"
        /* 1140 */ "const MOUSE_BUTTON_SIDE* = 3\n"
        /* 1141 */ "const MOUSE_BUTTON_EXTRA* = 4\n"
        /* 1142 */ "const MOUSE_BUTTON_FORWARD* = 5\n"
        /* 1143 */ "const MOUSE_BUTTON_BACK* = 6\n"
        /* 1144 */ "const MOUSE_CURSOR_DEFAULT* = 0\n"
        /* 1145 */ "const MOUSE_CURSOR_ARROW* = 1\n"
        /* 1146 */ "const MOUSE_CURSOR_IBEAM* = 2\n"
        /* 1147 */ "const MOUSE_CURSOR_CROSSHAIR* = 3\n"
        /* 1148 */ "const MOUSE_CURSOR_POINTING_HAND* = 4\n"
        /* 1149 */ "const MOUSE_CURSOR_RESIZE_EW* = 5\n"
        /* 1150 */ "const MOUSE_CURSOR_RESIZE_NS* = 6\n"
        /* 1151 */ "const MOUSE_CURSOR_RESIZE_NWSE* = 7\n"
        /* 1152 */ "const MOUSE_CURSOR_RESIZE_NESW* = 8\n"
        /* 1153 */ "const MOUSE_CURSOR_RESIZE_ALL* = 9\n"
        /* 1154 */ "const MOUSE_CURSOR_NOT_ALLOWED* = 10\n"
        /* 1155 */ "const GAMEPAD_BUTTON_UNKNOWN* = 0\n"
        /* 1156 */ "const GAMEPAD_BUTTON_LEFT_FACE_UP* = 1\n"
        /* 1157 */ "const GAMEPAD_BUTTON_LEFT_FACE_RIGHT* = 2\n"
        /* 1158 */ "const GAMEPAD_BUTTON_LEFT_FACE_DOWN* = 3\n"
        /* 1159 */ "const GAMEPAD_BUTTON_LEFT_FACE_LEFT* = 4\n"
        /* 1160 */ "const GAMEPAD_BUTTON_RIGHT_FACE_UP* = 5\n"
        /* 1161 */ "const GAMEPAD_BUTTON_RIGHT_FACE_RIGHT* = 6\n"
        /* 1162 */ "const GAMEPAD_BUTTON_RIGHT_FACE_DOWN* = 7\n"
        /* 1163 */ "const GAMEPAD_BUTTON_RIGHT_FACE_LEFT* = 8\n"
        /* 1164 */ "const GAMEPAD_BUTTON_LEFT_TRIGGER_1* = 9\n"
        /* 1165 */ "const GAMEPAD_BUTTON_LEFT_TRIGGER_2* = 10\n"
        /* 1166 */ "const GAMEPAD_BUTTON_RIGHT_TRIGGER_1* = 11\n"
        /* 1167 */ "const GAMEPAD_BUTTON_RIGHT_TRIGGER_2* = 12\n"
        /* 1168 */ "const GAMEPAD_BUTTON_MIDDLE_LEFT* = 13\n"
        /* 1169 */ "const GAMEPAD_BUTTON_MIDDLE* = 14\n"
        /* 1170 */ "const GAMEPAD_BUTTON_MIDDLE_RIGHT* = 15\n"
        /* 1171 */ "const GAMEPAD_BUTTON_LEFT_THUMB* = 16\n"
        /* 1172 */ "const GAMEPAD_BUTTON_RIGHT_THUMB* = 17\n"
        /* 1173 */ "const GAMEPAD_AXIS_LEFT_X* = 0\n"
        /* 1174 */ "const GAMEPAD_AXIS_LEFT_Y* = 1\n"
        /* 1175 */ "const GAMEPAD_AXIS_RIGHT_X* = 2\n"
        /* 1176 */ "const GAMEPAD_AXIS_RIGHT_Y* = 3\n"
        /* 1177 */ "const GAMEPAD_AXIS_LEFT_TRIGGER* = 4\n"
        /* 1178 */ "const GAMEPAD_AXIS_RIGHT_TRIGGER* = 5\n"
        /* 1179 */ "const MATERIAL_MAP_ALBEDO* = 0\n"
        /* 1180 */ "const MATERIAL_MAP_METALNESS* = 1\n"
        /* 1181 */ "const MATERIAL_MAP_NORMAL* = 2\n"
        /* 1182 */ "const MATERIAL_MAP_ROUGHNESS* = 3\n"
        /* 1183 */ "const MATERIAL_MAP_OCCLUSION* = 4\n"
        /* 1184 */ "const MATERIAL_MAP_EMISSION* = 5\n"
        /* 1185 */ "const MATERIAL_MAP_HEIGHT* = 6\n"
        /* 1186 */ "const MATERIAL_MAP_CUBEMAP* = 7\n"
        /* 1187 */ "const MATERIAL_MAP_IRRADIANCE* = 8\n"
        /* 1188 */ "const MATERIAL_MAP_PREFILTER* = 9\n"
        /* 1189 */ "const MATERIAL_MAP_BRDF* = 10\n"
        /* 1190 */ "const SHADER_LOC_VERTEX_POSITION* = 0\n"
        /* 1191 */ "const SHADER_LOC_VERTEX_TEXCOORD01* = 1\n"
        /* 1192 */ "const SHADER_LOC_VERTEX_TEXCOORD02* = 2\n"
        /* 1193 */ "const SHADER_LOC_VERTEX_NORMAL* = 3\n"
        /* 1194 */ "const SHADER_LOC_VERTEX_TANGENT* = 4\n"
        /* 1195 */ "const SHADER_LOC_VERTEX_COLOR* = 5\n"
        /* 1196 */ "const SHADER_LOC_MATRIX_MVP* = 6\n"
        /* 1197 */ "const SHADER_LOC_MATRIX_VIEW* = 7\n"
        /* 1198 */ "const SHADER_LOC_MATRIX_PROJECTION* = 8\n"
        /* 1199 */ "const SHADER_LOC_MATRIX_MODEL* = 9\n"
        /* 1200 */ "const SHADER_LOC_MATRIX_NORMAL* = 10\n"
        /* 1201 */ "const SHADER_LOC_VECTOR_VIEW* = 11\n"
        /* 1202 */ "const SHADER_LOC_COLOR_DIFFUSE* = 12\n"
        /* 1203 */ "const SHADER_LOC_COLOR_SPECULAR* = 13\n"
        /* 1204 */ "const SHADER_LOC_COLOR_AMBIENT* = 14\n"
        /* 1205 */ "const SHADER_LOC_MAP_ALBEDO* = 15\n"
        /* 1206 */ "const SHADER_LOC_MAP_METALNESS* = 16\n"
        /* 1207 */ "const SHADER_LOC_MAP_NORMAL* = 17\n"
        /* 1208 */ "const SHADER_LOC_MAP_ROUGHNESS* = 18\n"
        /* 1209 */ "const SHADER_LOC_MAP_OCCLUSION* = 19\n"
        /* 1210 */ "const SHADER_LOC_MAP_EMISSION* = 20\n"
        /* 1211 */ "const SHADER_LOC_MAP_HEIGHT* = 21\n"
        /* 1212 */ "const SHADER_LOC_MAP_CUBEMAP* = 22\n"
        /* 1213 */ "const SHADER_LOC_MAP_IRRADIANCE* = 23\n"
        /* 1214 */ "const SHADER_LOC_MAP_PREFILTER* = 24\n"
        /* 1215 */ "const SHADER_LOC_MAP_BRDF* = 25\n"
        /* 1216 */ "const SHADER_UNIFORM_FLOAT* = 0\n"
        /* 1217 */ "const SHADER_UNIFORM_VEC2* = 1\n"
        /* 1218 */ "const SHADER_UNIFORM_VEC3* = 2\n"
        /* 1219 */ "const SHADER_UNIFORM_VEC4* = 3\n"
        /* 1220 */ "const SHADER_UNIFORM_INT* = 4\n"
        /* 1221 */ "const SHADER_UNIFORM_IVEC2* = 5\n"
        /* 1222 */ "const SHADER_UNIFORM_IVEC3* = 6\n"
        /* 1223 */ "const SHADER_UNIFORM_IVEC4* = 7\n"
        /* 1224 */ "const SHADER_UNIFORM_SAMPLER2D* = 8\n"
        /* 1225 */ "const SHADER_ATTRIB_FLOAT* = 0\n"
        /* 1226 */ "const SHADER_ATTRIB_VEC2* = 1\n"
        /* 1227 */ "const SHADER_ATTRIB_VEC3* = 2\n"
        /* 1228 */ "const SHADER_ATTRIB_VEC4* = 3\n"
        /* 1229 */ "const PIXELFORMAT_UNCOMPRESSED_GRAYSCALE* = 1\n"
        /* 1230 */ "const PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA* = 2\n"
        /* 1231 */ "const PIXELFORMAT_UNCOMPRESSED_R5G6B5* = 3\n"
        /* 1232 */ "const PIXELFORMAT_UNCOMPRESSED_R8G8B8* = 4\n"
        /* 1233 */ "const PIXELFORMAT_UNCOMPRESSED_R5G5B5A1* = 5\n"
        /* 1234 */ "const PIXELFORMAT_UNCOMPRESSED_R4G4B4A4* = 6\n"
        /* 1235 */ "const PIXELFORMAT_UNCOMPRESSED_R8G8B8A8* = 7\n"
        /* 1236 */ "const PIXELFORMAT_UNCOMPRESSED_R32* = 8\n"
        /* 1237 */ "const PIXELFORMAT_UNCOMPRESSED_R32G32B32* = 9\n"
        /* 1238 */ "const PIXELFORMAT_UNCOMPRESSED_R32G32B32A32* = 10\n"
        /* 1239 */ "const PIXELFORMAT_COMPRESSED_DXT1_RGB* = 11\n"
        /* 1240 */ "const PIXELFORMAT_COMPRESSED_DXT1_RGBA* = 12\n"
        /* 1241 */ "const PIXELFORMAT_COMPRESSED_DXT3_RGBA* = 13\n"
        /* 1242 */ "const PIXELFORMAT_COMPRESSED_DXT5_RGBA* = 14\n"
        /* 1243 */ "const PIXELFORMAT_COMPRESSED_ETC1_RGB* = 15\n"
        /* 1244 */ "const PIXELFORMAT_COMPRESSED_ETC2_RGB* = 16\n"
        /* 1245 */ "const PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA* = 17\n"
        /* 1246 */ "const PIXELFORMAT_COMPRESSED_PVRT_RGB* = 18\n"
        /* 1247 */ "const PIXELFORMAT_COMPRESSED_PVRT_RGBA* = 19\n"
        /* 1248 */ "const PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA* = 20\n"
        /* 1249 */ "const PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA* = 21\n"
        /* 1250 */ "const TEXTURE_FILTER_POINT* = 0\n"
        /* 1251 */ "const TEXTURE_FILTER_BILINEAR* = 1\n"
        /* 1252 */ "const TEXTURE_FILTER_TRILINEAR* = 2\n"
        /* 1253 */ "const TEXTURE_FILTER_ANISOTROPIC_4X* = 3\n"
        /* 1254 */ "const TEXTURE_FILTER_ANISOTROPIC_8X* = 4\n"
        /* 1255 */ "const TEXTURE_FILTER_ANISOTROPIC_16X* = 5\n"
        /* 1256 */ "const TEXTURE_WRAP_REPEAT* = 0\n"
        /* 1257 */ "const TEXTURE_WRAP_CLAMP* = 1\n"
        /* 1258 */ "const TEXTURE_WRAP_MIRROR_REPEAT* = 2\n"
        /* 1259 */ "const TEXTURE_WRAP_MIRROR_CLAMP* = 3\n"
        /* 1260 */ "const CUBEMAP_LAYOUT_AUTO_DETECT* = 0\n"
        /* 1261 */ "const CUBEMAP_LAYOUT_LINE_VERTICAL* = 1\n"
        /* 1262 */ "const CUBEMAP_LAYOUT_LINE_HORIZONTAL* = 2\n"
        /* 1263 */ "const CUBEMAP_LAYOUT_CROSS_THREE_BY_FOUR* = 3\n"
        /* 1264 */ "const CUBEMAP_LAYOUT_CROSS_FOUR_BY_THREE* = 4\n"
        /* 1265 */ "const CUBEMAP_LAYOUT_PANORAMA* = 5\n"
        /* 1266 */ "const FONT_DEFAULT* = 0\n"
        /* 1267 */ "const FONT_BITMAP* = 1\n"
        /* 1268 */ "const FONT_SDF* = 2\n"
        /* 1269 */ "const BLEND_ALPHA* = 0\n"
        /* 1270 */ "const BLEND_ADDITIVE* = 1\n"
        /* 1271 */ "const BLEND_MULTIPLIED* = 2\n"
        /* 1272 */ "const BLEND_ADD_COLORS* = 3\n"
        /* 1273 */ "const BLEND_SUBTRACT_COLORS* = 4\n"
        /* 1274 */ "const BLEND_ALPHA_PREMULTIPLY* = 5\n"
        /* 1275 */ "const BLEND_CUSTOM* = 6\n"
        /* 1276 */ "const GESTURE_NONE* = 0\n"
        /* 1277 */ "const GESTURE_TAP* = 1\n"
        /* 1278 */ "const GESTURE_DOUBLETAP* = 2\n"
        /* 1279 */ "const GESTURE_HOLD* = 4\n"
        /* 1280 */ "const GESTURE_DRAG* = 8\n"
        /* 1281 */ "const GESTURE_SWIPE_RIGHT* = 16\n"
        /* 1282 */ "const GESTURE_SWIPE_LEFT* = 32\n"
        /* 1283 */ "const GESTURE_SWIPE_UP* = 64\n"
        /* 1284 */ "const GESTURE_SWIPE_DOWN* = 128\n"
        /* 1285 */ "const GESTURE_PINCH_IN* = 256\n"
        /* 1286 */ "const GESTURE_PINCH_OUT* = 512\n"
        /* 1287 */ "const CAMERA_CUSTOM* = 0\n"
        /* 1288 */ "const CAMERA_FREE* = 1\n"
        /* 1289 */ "const CAMERA_ORBITAL* = 2\n"
        /* 1290 */ "const CAMERA_FIRST_PERSON* = 3\n"
        /* 1291 */ "const CAMERA_THIRD_PERSON* = 4\n"
        /* 1292 */ "const CAMERA_PERSPECTIVE* = 0\n"
        /* 1293 */ "const CAMERA_ORTHOGRAPHIC* = 1\n"
        /* 1294 */ "const NPATCH_NINE_PATCH* = 0\n"
        /* 1295 */ "const NPATCH_THREE_PATCH_VERTICAL* = 1\n"
        /* 1296 */ "const NPATCH_THREE_PATCH_HORIZONTAL* = 2\n"
        /* 1297 */ "const OPENGL_11* = 1\n"
        /* 1298 */ "const OPENGL_21* = 2\n"
        /* 1299 */ "const OPENGL_33* = 3\n"
        /* 1300 */ "const OPENGL_43* = 4\n"
        /* 1301 */ "const OPENGL_ES_20* = 5\n"
        /* 1302 */ "const RL_ATTACHMENT_COLOR_CHANNEL0* = 0\n"
        /* 1303 */ "const RL_ATTACHMENT_COLOR_CHANNEL1* = 1\n"
        /* 1304 */ "const RL_ATTACHMENT_COLOR_CHANNEL2* = 2\n"
        /* 1305 */ "const RL_ATTACHMENT_COLOR_CHANNEL3* = 3\n"
        /* 1306 */ "const RL_ATTACHMENT_COLOR_CHANNEL4* = 4\n"
        /* 1307 */ "const RL_ATTACHMENT_COLOR_CHANNEL5* = 5\n"
        /* 1308 */ "const RL_ATTACHMENT_COLOR_CHANNEL6* = 6\n"
        /* 1309 */ "const RL_ATTACHMENT_COLOR_CHANNEL7* = 7\n"
        /* 1310 */ "const RL_ATTACHMENT_DEPTH* = 100\n"
        /* 1311 */ "const RL_ATTACHMENT_STENCIL* = 200\n"
        /* 1312 */ "const RL_ATTACHMENT_CUBEMAP_POSITIVE_X* = 0\n"
        /* 1313 */ "const RL_ATTACHMENT_CUBEMAP_NEGATIVE_X* = 1\n"
        /* 1314 */ "const RL_ATTACHMENT_CUBEMAP_POSITIVE_Y* = 2\n"
        /* 1315 */ "const RL_ATTACHMENT_CUBEMAP_NEGATIVE_Y* = 3\n"
        /* 1316 */ "const RL_ATTACHMENT_CUBEMAP_POSITIVE_Z* = 4\n"
        /* 1317 */ "const RL_ATTACHMENT_CUBEMAP_NEGATIVE_Z* = 5\n"
        /* 1318 */ "const RL_ATTACHMENT_TEXTURE2D* = 100\n"
        /* 1319 */ "const RL_ATTACHMENT_RENDERBUFFER* = 200\n"
        /* 1320 */ "const RL_LOG_ALL* = 0\n"
        /* 1321 */ "const RL_LOG_TRACE* = 1\n"
        /* 1322 */ "const RL_LOG_DEBUG* = 2\n"
        /* 1323 */ "const RL_LOG_INFO* = 3\n"
        /* 1324 */ "const RL_LOG_WARNING* = 4\n"
        /* 1325 */ "const RL_LOG_ERROR* = 5\n"
        /* 1326 */ "const RL_LOG_FATAL* = 6\n"
        /* 1327 */ "const RL_LOG_NONE* = 7\n"
        /* 1328 */ "const RL_PIXELFORMAT_UNCOMPRESSED_GRAYSCALE* = 1\n"
        /* 1329 */ "const RL_PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA* = 2\n"
        /* 1330 */ "const RL_PIXELFORMAT_UNCOMPRESSED_R5G6B5* = 3\n"
        /* 1331 */ "const RL_PIXELFORMAT_UNCOMPRESSED_R8G8B8* = 4\n"
        /* 1332 */ "const RL_PIXELFORMAT_UNCOMPRESSED_R5G5B5A1* = 5\n"
        /* 1333 */ "const RL_PIXELFORMAT_UNCOMPRESSED_R4G4B4A4* = 6\n"
        /* 1334 */ "const RL_PIXELFORMAT_UNCOMPRESSED_R8G8B8A8* = 7\n"
        /* 1335 */ "const RL_PIXELFORMAT_UNCOMPRESSED_R32* = 8\n"
        /* 1336 */ "const RL_PIXELFORMAT_UNCOMPRESSED_R32G32B32* = 9\n"
        /* 1337 */ "const RL_PIXELFORMAT_UNCOMPRESSED_R32G32B32A32* = 10\n"
        /* 1338 */ "const RL_PIXELFORMAT_COMPRESSED_DXT1_RGB* = 11\n"
        /* 1339 */ "const RL_PIXELFORMAT_COMPRESSED_DXT1_RGBA* = 12\n"
        /* 1340 */ "const RL_PIXELFORMAT_COMPRESSED_DXT3_RGBA* = 13\n"
        /* 1341 */ "const RL_PIXELFORMAT_COMPRESSED_DXT5_RGBA* = 14\n"
        /* 1342 */ "const RL_PIXELFORMAT_COMPRESSED_ETC1_RGB* = 15\n"
        /* 1343 */ "const RL_PIXELFORMAT_COMPRESSED_ETC2_RGB* = 16\n"
        /* 1344 */ "const RL_PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA* = 17\n"
        /* 1345 */ "const RL_PIXELFORMAT_COMPRESSED_PVRT_RGB* = 18\n"
        /* 1346 */ "const RL_PIXELFORMAT_COMPRESSED_PVRT_RGBA* = 19\n"
        /* 1347 */ "const RL_PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA* = 20\n"
        /* 1348 */ "const RL_PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA* = 21\n"
        /* 1349 */ "const RL_TEXTURE_FILTER_POINT* = 0\n"
        /* 1350 */ "const RL_TEXTURE_FILTER_BILINEAR* = 1\n"
        /* 1351 */ "const RL_TEXTURE_FILTER_TRILINEAR* = 2\n"
        /* 1352 */ "const RL_TEXTURE_FILTER_ANISOTROPIC_4X* = 3\n"
        /* 1353 */ "const RL_TEXTURE_FILTER_ANISOTROPIC_8X* = 4\n"
        /* 1354 */ "const RL_TEXTURE_FILTER_ANISOTROPIC_16X* = 5\n"
        /* 1355 */ "const RL_BLEND_ALPHA* = 0\n"
        /* 1356 */ "const RL_BLEND_ADDITIVE* = 1\n"
        /* 1357 */ "const RL_BLEND_MULTIPLIED* = 2\n"
        /* 1358 */ "const RL_BLEND_ADD_COLORS* = 3\n"
        /* 1359 */ "const RL_BLEND_SUBTRACT_COLORS* = 4\n"
        /* 1360 */ "const RL_BLEND_ALPHA_PREMULTIPLY* = 5\n"
        /* 1361 */ "const RL_BLEND_CUSTOM* = 6\n"
        /* 1362 */ "const RL_SHADER_LOC_VERTEX_POSITION* = 0\n"
        /* 1363 */ "const RL_SHADER_LOC_VERTEX_TEXCOORD01* = 1\n"
        /* 1364 */ "const RL_SHADER_LOC_VERTEX_TEXCOORD02* = 2\n"
        /* 1365 */ "const RL_SHADER_LOC_VERTEX_NORMAL* = 3\n"
        /* 1366 */ "const RL_SHADER_LOC_VERTEX_TANGENT* = 4\n"
        /* 1367 */ "const RL_SHADER_LOC_VERTEX_COLOR* = 5\n"
        /* 1368 */ "const RL_SHADER_LOC_MATRIX_MVP* = 6\n"
        /* 1369 */ "const RL_SHADER_LOC_MATRIX_VIEW* = 7\n"
        /* 1370 */ "const RL_SHADER_LOC_MATRIX_PROJECTION* = 8\n"
        /* 1371 */ "const RL_SHADER_LOC_MATRIX_MODEL* = 9\n"
        /* 1372 */ "const RL_SHADER_LOC_MATRIX_NORMAL* = 10\n"
        /* 1373 */ "const RL_SHADER_LOC_VECTOR_VIEW* = 11\n"
        /* 1374 */ "const RL_SHADER_LOC_COLOR_DIFFUSE* = 12\n"
        /* 1375 */ "const RL_SHADER_LOC_COLOR_SPECULAR* = 13\n"
        /* 1376 */ "const RL_SHADER_LOC_COLOR_AMBIENT* = 14\n"
        /* 1377 */ "const RL_SHADER_LOC_MAP_ALBEDO* = 15\n"
        /* 1378 */ "const RL_SHADER_LOC_MAP_METALNESS* = 16\n"
        /* 1379 */ "const RL_SHADER_LOC_MAP_NORMAL* = 17\n"
        /* 1380 */ "const RL_SHADER_LOC_MAP_ROUGHNESS* = 18\n"
        /* 1381 */ "const RL_SHADER_LOC_MAP_OCCLUSION* = 19\n"
        /* 1382 */ "const RL_SHADER_LOC_MAP_EMISSION* = 20\n"
        /* 1383 */ "const RL_SHADER_LOC_MAP_HEIGHT* = 21\n"
        /* 1384 */ "const RL_SHADER_LOC_MAP_CUBEMAP* = 22\n"
        /* 1385 */ "const RL_SHADER_LOC_MAP_IRRADIANCE* = 23\n"
        /* 1386 */ "const RL_SHADER_LOC_MAP_PREFILTER* = 24\n"
        /* 1387 */ "const RL_SHADER_LOC_MAP_BRDF* = 25\n"
        /* 1388 */ "const RL_SHADER_UNIFORM_FLOAT* = 0\n"
        /* 1389 */ "const RL_SHADER_UNIFORM_VEC2* = 1\n"
        /* 1390 */ "const RL_SHADER_UNIFORM_VEC3* = 2\n"
        /* 1391 */ "const RL_SHADER_UNIFORM_VEC4* = 3\n"
        /* 1392 */ "const RL_SHADER_UNIFORM_INT* = 4\n"
        /* 1393 */ "const RL_SHADER_UNIFORM_IVEC2* = 5\n"
        /* 1394 */ "const RL_SHADER_UNIFORM_IVEC3* = 6\n"
        /* 1395 */ "const RL_SHADER_UNIFORM_IVEC4* = 7\n"
        /* 1396 */ "const RL_SHADER_UNIFORM_SAMPLER2D* = 8\n"
        /* 1397 */ "const RL_SHADER_ATTRIB_FLOAT* = 0\n"
        /* 1398 */ "const RL_SHADER_ATTRIB_VEC2* = 1\n"
        /* 1399 */ "const RL_SHADER_ATTRIB_VEC3* = 2\n"
        /* 1400 */ "const RL_SHADER_ATTRIB_VEC4* = 3\n"

        // Defines
        /* 1401 */ "const RAYLIB_VERSION* = \"4.2\"\n"
        /* 1402 */ "// Skipped define: __declspec(x)\n"
        /* 1403 */ "// Skipped define: RLAPI\n"
        /* 1404 */ "const PI* = 3.141592653589793\n"
        /* 1405 */ "// Skipped define: DEG2RAD\n"
        /* 1406 */ "// Skipped define: RAD2DEG\n"
        /* 1407 */ "// Skipped define: RL_MALLOC(sz)\n"
        /* 1408 */ "// Skipped define: RL_CALLOC(n,sz)\n"
        /* 1409 */ "// Skipped define: RL_REALLOC(ptr,sz)\n"
        /* 1410 */ "// Skipped define: RL_FREE(ptr)\n"
        /* 1411 */ "// Skipped define: CLITERAL(type)\n"
        /* 1412 */ "const LIGHTGRAY* = Color{ 200, 200, 200, 255 }\n"
        /* 1413 */ "const GRAY* = Color{ 130, 130, 130, 255 }\n"
        /* 1414 */ "const DARKGRAY* = Color{ 80, 80, 80, 255 }\n"
        /* 1415 */ "const YELLOW* = Color{ 253, 249, 0, 255 }\n"
        /* 1416 */ "const GOLD* = Color{ 255, 203, 0, 255 }\n"
        /* 1417 */ "const ORANGE* = Color{ 255, 161, 0, 255 }\n"
        /* 1418 */ "const PINK* = Color{ 255, 109, 194, 255 }\n"
        /* 1419 */ "const RED* = Color{ 230, 41, 55, 255 }\n"
        /* 1420 */ "const MAROON* = Color{ 190, 33, 55, 255 }\n"
        /* 1421 */ "const GREEN* = Color{ 0, 228, 48, 255 }\n"
        /* 1422 */ "const LIME* = Color{ 0, 158, 47, 255 }\n"
        /* 1423 */ "const DARKGREEN* = Color{ 0, 117, 44, 255 }\n"
        /* 1424 */ "const SKYBLUE* = Color{ 102, 191, 255, 255 }\n"
        /* 1425 */ "const BLUE* = Color{ 0, 121, 241, 255 }\n"
        /* 1426 */ "const DARKBLUE* = Color{ 0, 82, 172, 255 }\n"
        /* 1427 */ "const PURPLE* = Color{ 200, 122, 255, 255 }\n"
        /* 1428 */ "const VIOLET* = Color{ 135, 60, 190, 255 }\n"
        /* 1429 */ "const DARKPURPLE* = Color{ 112, 31, 126, 255 }\n"
        /* 1430 */ "const BEIGE* = Color{ 211, 176, 131, 255 }\n"
        /* 1431 */ "const BROWN* = Color{ 127, 106, 79, 255 }\n"
        /* 1432 */ "const DARKBROWN* = Color{ 76, 63, 47, 255 }\n"
        /* 1433 */ "const WHITE* = Color{ 255, 255, 255, 255 }\n"
        /* 1434 */ "const BLACK* = Color{ 0, 0, 0, 255 }\n"
        /* 1435 */ "const BLANK* = Color{ 0, 0, 0, 0 }\n"
        /* 1436 */ "const MAGENTA* = Color{ 255, 0, 255, 255 }\n"
        /* 1437 */ "const RAYWHITE* = Color{ 245, 245, 245, 255 }\n"
        /* 1438 */ "// Skipped define: MOUSE_LEFT_BUTTON\n"
        /* 1439 */ "// Skipped define: MOUSE_RIGHT_BUTTON\n"
        /* 1440 */ "// Skipped define: MOUSE_MIDDLE_BUTTON\n"
        /* 1441 */ "// Skipped define: MATERIAL_MAP_DIFFUSE\n"
        /* 1442 */ "// Skipped define: MATERIAL_MAP_SPECULAR\n"
        /* 1443 */ "// Skipped define: SHADER_LOC_MAP_DIFFUSE\n"
        /* 1444 */ "// Skipped define: SHADER_LOC_MAP_SPECULAR\n"
        /* 1445 */ "// Skipped define: RMAPI\n"
        /* 1446 */ "const EPSILON* = 0.000001\n"
        /* 1447 */ "// Skipped define: MatrixToFloat(mat)\n"
        /* 1448 */ "// Skipped define: Vector3ToFloat(vec)\n"
        /* 1449 */ "const RLGL_VERSION* = \"4.0\"\n"
        /* 1450 */ "// Skipped define: TRACELOG(level, ...)\n"
        /* 1451 */ "// Skipped define: TRACELOGD(...)\n"
        /* 1452 */ "// Skipped define: RL_REALLOC(n,sz)\n"
        /* 1453 */ "// Skipped define: RL_FREE(p)\n"
        /* 1454 */ "// Skipped define: RL_DEFAULT_BATCH_BUFFER_ELEMENTS\n"
        /* 1455 */ "// Skipped define: RL_DEFAULT_BATCH_BUFFERS\n"
        /* 1456 */ "// Skipped define: RL_DEFAULT_BATCH_DRAWCALLS\n"
        /* 1457 */ "// Skipped define: RL_DEFAULT_BATCH_MAX_TEXTURE_UNITS\n"
        /* 1458 */ "// Skipped define: RL_MAX_MATRIX_STACK_SIZE\n"
        /* 1459 */ "// Skipped define: RL_MAX_SHADER_LOCATIONS\n"
        /* 1460 */ "// Skipped define: RL_CULL_DISTANCE_NEAR\n"
        /* 1461 */ "// Skipped define: RL_CULL_DISTANCE_FAR\n"
        /* 1462 */ "// Skipped define: RL_TEXTURE_WRAP_S\n"
        /* 1463 */ "// Skipped define: RL_TEXTURE_WRAP_T\n"
        /* 1464 */ "// Skipped define: RL_TEXTURE_MAG_FILTER\n"
        /* 1465 */ "// Skipped define: RL_TEXTURE_MIN_FILTER\n"
        /* 1466 */ "// Skipped define: RL_TEXTURE_FILTER_NEAREST\n"
        /* 1467 */ "// Skipped define: RL_TEXTURE_FILTER_LINEAR\n"
        /* 1468 */ "// Skipped define: RL_TEXTURE_FILTER_MIP_NEAREST\n"
        /* 1469 */ "// Skipped define: RL_TEXTURE_FILTER_NEAREST_MIP_LINEAR\n"
        /* 1470 */ "// Skipped define: RL_TEXTURE_FILTER_LINEAR_MIP_NEAREST\n"
        /* 1471 */ "// Skipped define: RL_TEXTURE_FILTER_MIP_LINEAR\n"
        /* 1472 */ "// Skipped define: RL_TEXTURE_FILTER_ANISOTROPIC\n"
        /* 1473 */ "// Skipped define: RL_TEXTURE_WRAP_REPEAT\n"
        /* 1474 */ "// Skipped define: RL_TEXTURE_WRAP_CLAMP\n"
        /* 1475 */ "// Skipped define: RL_TEXTURE_WRAP_MIRROR_REPEAT\n"
        /* 1476 */ "// Skipped define: RL_TEXTURE_WRAP_MIRROR_CLAMP\n"
        /* 1477 */ "// Skipped define: RL_MODELVIEW\n"
        /* 1478 */ "// Skipped define: RL_PROJECTION\n"
        /* 1479 */ "// Skipped define: RL_TEXTURE\n"
        /* 1480 */ "// Skipped define: RL_LINES\n"
        /* 1481 */ "// Skipped define: RL_TRIANGLES\n"
        /* 1482 */ "// Skipped define: RL_QUADS\n"
        /* 1483 */ "// Skipped define: RL_UNSIGNED_BYTE\n"
        /* 1484 */ "// Skipped define: RL_FLOAT\n"
        /* 1485 */ "// Skipped define: RL_STREAM_DRAW\n"
        /* 1486 */ "// Skipped define: RL_STREAM_READ\n"
        /* 1487 */ "// Skipped define: RL_STREAM_COPY\n"
        /* 1488 */ "// Skipped define: RL_STATIC_DRAW\n"
        /* 1489 */ "// Skipped define: RL_STATIC_READ\n"
        /* 1490 */ "// Skipped define: RL_STATIC_COPY\n"
        /* 1491 */ "// Skipped define: RL_DYNAMIC_DRAW\n"
        /* 1492 */ "// Skipped define: RL_DYNAMIC_READ\n"
        /* 1493 */ "// Skipped define: RL_DYNAMIC_COPY\n"
        /* 1494 */ "// Skipped define: RL_FRAGMENT_SHADER\n"
        /* 1495 */ "// Skipped define: RL_VERTEX_SHADER\n"
        /* 1496 */ "// Skipped define: RL_COMPUTE_SHADER\n"
        /* 1497 */ "// Skipped define: RL_SHADER_LOC_MAP_DIFFUSE\n"
        /* 1498 */ "// Skipped define: RL_SHADER_LOC_MAP_SPECULAR\n"

        // End of the module.
        " ";

    return umkaAddModule(umka, "raylib", moduleCode);
}

#endif  // RAYLIB_UMKA_NO_ADD_MODULE

#if defined(__cplusplus)
}
#endif

#endif // RAYLIB_UMKA_IMPLEMENTATION_ONCE
#endif // RAYLIB_UMKA_IMPLEMENTATION
